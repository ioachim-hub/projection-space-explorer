{"version":3,"file":"src_components_Utility_DistanceFunctions_ts-src_components_Utility_UMAP_umap_ts.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;CAGA;AACA;;AACM,SAAUG,KAAV,CAAgBC,YAAhB,EAAgC;EACpC,OAAO,UAAUC,CAAV,EAAuBC,CAAvB,EAAkC;IACvC,IAAIC,MAAM,GAAG,CAAb;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACI,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;MACjC,QAAQJ,YAAY,CAACI,CAAD,CAApB;QACE,KAAKN,wEAAL;UACEK,MAAM,IAAII,IAAI,CAACC,GAAL,CAASP,CAAC,CAACG,CAAD,CAAD,GAAOF,CAAC,CAACE,CAAD,CAAjB,CAAV;UACA;;QACF,KAAKN,kEAAL;UACEK,MAAM,IAAIF,CAAC,CAACG,CAAD,CAAD,KAASF,CAAC,CAACE,CAAD,CAAV,GAAgB,CAAhB,GAAoB,CAA9B,CADF,CACmC;;UACjC;;QACF,KAAKN,uEAAL;UACEK,MAAM,IAAIF,CAAC,CAACG,CAAD,CAAD,KAASF,CAAC,CAACE,CAAD,CAAV,GAAgB,CAAhB,GAAoB,CAA9B,CADF,CACmC;;UACjC;;QACF,KAAKN,mEAAL;UACE;UACA;;QACF;UACE;MAdJ;IAgBD;;IACD,OAAOK,MAAP;EACD,CArBD;AAsBD,EAED;;AACM,SAAUS,OAAV,CAAkBX,CAAlB,EAA+BC,CAA/B,EAA0C;EAC9C,OAAON,6CAAA,CAAsBK,CAAtB,EAAyBC,CAAzB,CAAP;AACD;AAEK,SAAUY,SAAV,CAAoBb,CAApB,EAAiCC,CAAjC,EAA4C;EAChD,IAAIC,MAAM,GAAG,CAAb;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACI,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;IACjCD,MAAM,aAAKF,CAAC,CAACG,CAAD,CAAD,GAAOF,CAAC,CAACE,CAAD,CAAb,EAAqB,CAArB,CAAN;EACD;;EACD,OAAOG,IAAI,CAACQ,IAAL,CAAUZ,MAAV,CAAP;AACD;AAEK,SAAUa,SAAV,CAAoBf,CAApB,EAAiCC,CAAjC,EAA4C;EAChD,IAAIC,MAAM,GAAG,CAAb;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACI,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;IACjCD,MAAM,IAAII,IAAI,CAACC,GAAL,CAASP,CAAC,CAACG,CAAD,CAAD,GAAOF,CAAC,CAACE,CAAD,CAAjB,CAAV;EACD;;EACD,OAAOD,MAAP;AACD;AAEK,SAAUc,MAAV,CAAiBhB,CAAjB,EAA8BC,CAA9B,EAAyC;EAC7C,IAAIC,MAAM,GAAG,GAAb;EACA,IAAIe,KAAK,GAAG,GAAZ;EACA,IAAIC,KAAK,GAAG,GAAZ;;EAEA,KAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACI,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;IACjCD,MAAM,IAAIF,CAAC,CAACG,CAAD,CAAD,GAAOF,CAAC,CAACE,CAAD,CAAlB;IACAc,KAAK,aAAIjB,CAAC,CAACG,CAAD,CAAL,EAAY,CAAZ,CAAL;IACAe,KAAK,aAAIjB,CAAC,CAACE,CAAD,CAAL,EAAY,CAAZ,CAAL;EACD;;EAED,IAAIc,KAAK,KAAK,CAAV,IAAeC,KAAK,KAAK,CAA7B,EAAgC;IAC9B,OAAO,CAAP;EACD;;EACD,IAAID,KAAK,KAAK,CAAV,IAAeC,KAAK,KAAK,CAA7B,EAAgC;IAC9B,OAAO,GAAP;EACD;;EACD,OAAO,MAAMhB,MAAM,GAAGI,IAAI,CAACQ,IAAL,CAAUG,KAAK,GAAGC,KAAlB,CAAtB;AACD;AAEK,SAAUC,eAAV,CAA0BC,cAA1B,EAA0CC,CAA1C,EAA2C;EAC/C,QAAQD,cAAR;IACE,KAAKxB,2EAAL;MACE,OAAOiB,SAAP;;IACF,KAAKjB,yEAAL;MACE,OAAOe,OAAP;;IACF,KAAKf,2EAAL;MACE,OAAOmB,SAAP;;IACF,KAAKnB,wEAAL;MACE,OAAOoB,MAAP;;IACF,KAAKpB,uEAAL;MACE,OAAOE,KAAK,CAACuB,CAAC,CAACM,IAAF,CAAO5B,YAAR,CAAZ;;IACF;MACE,OAAOc,SAAP;EAZJ;AAcD;;;;;;;;;;;;;;;;;;;;;ACvFD;;;;;;;;;;;;;;;;;;AA4DA;AAIA;;;;;;;;;;;AAUM,SAAUgB,QAAV,CAAmBC,OAAnB,EAAoCC,IAApC,EAAgD;EACpD,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACC,SAAD,EAAsB;IACvC,OAAOL,yCAAA,CAAYE,OAAZ,EAAqBK,GAArB,CAAyB,YAAK;MACnC,OAAOP,0CAAA,CAAaG,IAAb,EAAmBE,SAAnB,CAAP;IACD,CAFM,CAAP;EAGD,CAJD;;EAMA,IAAMI,IAAI,GAAS,EAAnB;EACAA,IAAI,CAACC,IAAL,CAAUN,UAAU,CAAC,CAAC,CAAF,CAApB;EACAK,IAAI,CAACC,IAAL,CAAUN,UAAU,CAACO,QAAD,CAApB;EACAF,IAAI,CAACC,IAAL,CAAUN,UAAU,CAAC,CAAD,CAApB;EACA,OAAOK,IAAP;AACD;AAED;;;;;;AAKM,SAAUG,eAAV,CAA0BC,QAA1B,EAA4CC,QAA5C,EAA8DC,MAA9D,EAA8E;EAClF,IAAMzC,MAAM,GAAG0B,yCAAA,CAAYa,QAAZ,CAAf;;EACA,KAAK,IAAItC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,QAApB,EAA8BtC,CAAC,EAA/B,EAAmC;IACjC,IAAI0C,YAAY,GAAG,IAAnB;IACA,IAAIC,CAAC,GAAG,CAAR;;IACA,OAAOD,YAAP,EAAqB;MACnBC,CAAC,GAAGlB,8CAAA,CAAiBc,QAAjB,EAA2BC,MAA3B,CAAJ;MACA,IAAIK,MAAM,GAAG,KAAb;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG9C,CAApB,EAAuB8C,CAAC,EAAxB,EAA4B;QAC1B,IAAIH,CAAC,KAAK5C,MAAM,CAAC+C,CAAD,CAAhB,EAAqB;UACnBD,MAAM,GAAG,IAAT;UACA;QACD;MACF;;MACD,IAAI,CAACA,MAAL,EAAaH,YAAY,GAAG,KAAf;IACd;;IACD3C,MAAM,CAACC,CAAD,CAAN,GAAY2C,CAAZ;EACD;;EACD,OAAO5C,MAAP;AACD;AAED;;;;;;;;AAOM,SAAUgD,QAAV,CAAmBb,IAAnB,EAA+Bc,GAA/B,EAA4CC,MAA5C,EAA4DC,KAA5D,EAA2EC,IAA3E,EAAuF;EAC3FH,GAAG,GAAG7C,IAAI,CAACiD,KAAL,CAAWJ,GAAX,CAAN;EACA,IAAMK,OAAO,GAAGnB,IAAI,CAAC,CAAD,CAAJ,CAAQc,GAAR,CAAhB;EACA,IAAMM,OAAO,GAAGpB,IAAI,CAAC,CAAD,CAAJ,CAAQc,GAAR,CAAhB;EACA,IAAMO,KAAK,GAAGrB,IAAI,CAAC,CAAD,CAAJ,CAAQc,GAAR,CAAd;;EAEA,IAAIC,MAAM,IAAIK,OAAO,CAAC,CAAD,CAArB,EAA0B;IACxB,OAAO,CAAP;EACD,CAR0F,CAU3F;;;EACA,KAAK,IAAItD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqD,OAAO,CAACpD,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;IACvC,IAAIkD,KAAK,KAAKG,OAAO,CAACrD,CAAD,CAArB,EAA0B;MACxB,OAAO,CAAP;IACD;EACF;;EAED,OAAOwD,iBAAiB,CAACtB,IAAD,EAAOc,GAAP,EAAYC,MAAZ,EAAoBC,KAApB,EAA2BC,IAA3B,CAAxB;AACD;AAED;;;;;;;;AAOM,SAAUK,iBAAV,CAA4BtB,IAA5B,EAAwCc,GAAxC,EAAqDC,MAArD,EAAqEC,KAArE,EAAoFC,IAApF,EAAgG;EACpG,IAAME,OAAO,GAAGnB,IAAI,CAAC,CAAD,CAAJ,CAAQc,GAAR,CAAhB;EACA,IAAMM,OAAO,GAAGpB,IAAI,CAAC,CAAD,CAAJ,CAAQc,GAAR,CAAhB;EACA,IAAMO,KAAK,GAAGrB,IAAI,CAAC,CAAD,CAAJ,CAAQc,GAAR,CAAd;;EAEA,IAAIC,MAAM,IAAIK,OAAO,CAAC,CAAD,CAArB,EAA0B;IACxB,OAAO,CAAP;EACD,CAPmG,CASpG;;;EACAA,OAAO,CAAC,CAAD,CAAP,GAAaL,MAAb;EACAI,OAAO,CAAC,CAAD,CAAP,GAAaH,KAAb;EACAK,KAAK,CAAC,CAAD,CAAL,GAAWJ,IAAX,CAZoG,CAcpG;;EACA,IAAInD,CAAC,GAAG,CAAR;EACA,IAAIyD,KAAK,GAAG,CAAZ;;EACA,OAAO,IAAP,EAAa;IACX,IAAMC,GAAG,GAAG,IAAI1D,CAAJ,GAAQ,CAApB;IACA,IAAM2D,GAAG,GAAGD,GAAG,GAAG,CAAlB;IAEA,IAAME,UAAU,GAAG1B,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,EAAWjC,MAA9B;;IACA,IAAIyD,GAAG,IAAIE,UAAX,EAAuB;MACrB;IACD,CAFD,MAEO,IAAID,GAAG,IAAIC,UAAX,EAAuB;MAC5B,IAAIN,OAAO,CAACI,GAAD,CAAP,GAAeT,MAAnB,EAA2B;QACzBQ,KAAK,GAAGC,GAAR;MACD,CAFD,MAEO;QACL;MACD;IACF,CANM,MAMA,IAAIJ,OAAO,CAACI,GAAD,CAAP,IAAgBJ,OAAO,CAACK,GAAD,CAA3B,EAAkC;MACvC,IAAIV,MAAM,GAAGK,OAAO,CAACI,GAAD,CAApB,EAA2B;QACzBD,KAAK,GAAGC,GAAR;MACD,CAFD,MAEO;QACL;MACD;IACF,CANM,MAMA,IAAIT,MAAM,GAAGK,OAAO,CAACK,GAAD,CAApB,EAA2B;MAChCF,KAAK,GAAGE,GAAR;IACD,CAFM,MAEA;MACL;IACD;;IAEDL,OAAO,CAACtD,CAAD,CAAP,GAAasD,OAAO,CAACG,KAAD,CAApB;IACAJ,OAAO,CAACrD,CAAD,CAAP,GAAaqD,OAAO,CAACI,KAAD,CAApB;IACAF,KAAK,CAACvD,CAAD,CAAL,GAAWuD,KAAK,CAACE,KAAD,CAAhB;IAEAzD,CAAC,GAAGyD,KAAJ;EACD;;EAEDH,OAAO,CAACtD,CAAD,CAAP,GAAaiD,MAAb;EACAI,OAAO,CAACrD,CAAD,CAAP,GAAakD,KAAb;EACAK,KAAK,CAACvD,CAAD,CAAL,GAAWmD,IAAX;EACA,OAAO,CAAP;AACD;AAED;;;;;;AAKM,SAAUU,eAAV,CAA0BC,YAA1B,EAA8CC,SAA9C,EAAiEC,UAAjE,EAAqFC,aAArF,EAA4GzB,MAA5G,EAA4H;EAChI,IAAM0B,kBAAkB,GAAGxC,QAAQ,CAACqC,SAAD,EAAYE,aAAZ,CAAnC;;EACA,KAAK,IAAIjE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+D,SAApB,EAA+B/D,CAAC,EAAhC,EAAoC;IAClC,KAAK,IAAI2C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,UAApB,EAAgCrB,CAAC,EAAjC,EAAqC;MACnC,IAAImB,YAAY,CAAC,CAAD,CAAZ,CAAgB9D,CAAhB,EAAmB2C,CAAnB,IAAwB,CAA5B,EAA+B;QAC7B;MACD;;MACD,IAAMwB,GAAG,GAAGL,YAAY,CAAC,CAAD,CAAZ,CAAgB9D,CAAhB,EAAmB2C,CAAnB,CAAZ;MACA,IAAMyB,GAAG,GAAGN,YAAY,CAAC,CAAD,CAAZ,CAAgB9D,CAAhB,EAAmB2C,CAAnB,CAAZ;MACA,IAAM0B,CAAC,GAAG5C,2CAAA,CAAce,MAAd,CAAV;MACAO,QAAQ,CAACmB,kBAAD,EAAqBlE,CAArB,EAAwBqE,CAAxB,EAA2BF,GAA3B,EAAgCC,GAAhC,CAAR;MACArB,QAAQ,CAACmB,kBAAD,EAAqBC,GAArB,EAA0BE,CAA1B,EAA6BrE,CAA7B,EAAgCoE,GAAhC,CAAR;MACAN,YAAY,CAAC,CAAD,CAAZ,CAAgB9D,CAAhB,EAAmB2C,CAAnB,IAAwB,CAAxB;IACD;EACF;;EACD,OAAOuB,kBAAP;AACD;AAED;;;;;;;AAMM,SAAUK,UAAV,CAAqBrC,IAArB,EAA+B;EACnC,IAAMmB,OAAO,GAAGnB,IAAI,CAAC,CAAD,CAApB;EACA,IAAMoB,OAAO,GAAGpB,IAAI,CAAC,CAAD,CAApB;;EAEA,KAAK,IAAIlC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqD,OAAO,CAACpD,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;IACvC,IAAMwE,OAAO,GAAGnB,OAAO,CAACrD,CAAD,CAAvB;IACA,IAAMyE,QAAQ,GAAGnB,OAAO,CAACtD,CAAD,CAAxB;;IAEA,KAAK,IAAI2C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6B,OAAO,CAACvE,MAAR,GAAiB,CAArC,EAAwC0C,CAAC,EAAzC,EAA6C;MAC3C,IAAM+B,YAAY,GAAGF,OAAO,CAACvE,MAAR,GAAiB0C,CAAjB,GAAqB,CAA1C;MACA,IAAMgC,aAAa,GAAGF,QAAQ,CAACxE,MAAT,GAAkB0C,CAAlB,GAAsB,CAA5C;MAEA,IAAMiC,KAAK,GAAGJ,OAAO,CAAC,CAAD,CAArB;MACAA,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAACE,YAAD,CAApB;MACAF,OAAO,CAACE,YAAD,CAAP,GAAwBE,KAAxB;MAEA,IAAMC,KAAK,GAAGJ,QAAQ,CAAC,CAAD,CAAtB;MACAA,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAACE,aAAD,CAAtB;MACAF,QAAQ,CAACE,aAAD,CAAR,GAA0BE,KAA1B;MAEAC,QAAQ,CAACL,QAAD,EAAWD,OAAX,EAAoBG,aAApB,EAAmC,CAAnC,CAAR;IACD;EACF;;EACD,OAAO;IAAEtB,OAAO,EAAPA,OAAF;IAAWC,OAAO,EAAPA;EAAX,CAAP;AACD;AAED;;;;;;AAKA,SAASwB,QAAT,CAAkBC,KAAlB,EAAmCC,KAAnC,EAAoDC,OAApD,EAAqEC,GAArE,EAAgF;EAC9E,OAAOA,GAAG,GAAG,CAAN,GAAU,CAAV,GAAcD,OAArB,EAA8B;IAC5B,IAAME,SAAS,GAAGD,GAAG,GAAG,CAAN,GAAU,CAA5B;IACA,IAAME,UAAU,GAAGD,SAAS,GAAG,CAA/B;IACA,IAAIE,IAAI,GAAGH,GAAX;;IAEA,IAAIH,KAAK,CAACM,IAAD,CAAL,GAAcN,KAAK,CAACI,SAAD,CAAvB,EAAoC;MAClCE,IAAI,GAAGF,SAAP;IACD;;IACD,IAAIC,UAAU,GAAGH,OAAb,IAAwBF,KAAK,CAACM,IAAD,CAAL,GAAcN,KAAK,CAACK,UAAD,CAA/C,EAA6D;MAC3DC,IAAI,GAAGD,UAAP;IACD;;IAED,IAAIC,IAAI,KAAKH,GAAb,EAAkB;MAChB;IACD,CAFD,MAEO;MACL,IAAMN,KAAK,GAAGG,KAAK,CAACG,GAAD,CAAnB;MACAH,KAAK,CAACG,GAAD,CAAL,GAAaH,KAAK,CAACM,IAAD,CAAlB;MACAN,KAAK,CAACM,IAAD,CAAL,GAAcT,KAAd;MAEA,IAAMC,KAAK,GAAGG,KAAK,CAACE,GAAD,CAAnB;MACAF,KAAK,CAACE,GAAD,CAAL,GAAaF,KAAK,CAACK,IAAD,CAAlB;MACAL,KAAK,CAACK,IAAD,CAAL,GAAcR,KAAd;MACAK,GAAG,GAAGG,IAAN;IACD;EACF;AACF;AAED;;;;;AAGM,SAAUC,eAAV,CAA0BpD,IAA1B,EAAsCc,GAAtC,EAAiD;EACrD,IAAMuC,GAAG,GAAGrD,IAAI,CAAC,CAAD,CAAJ,CAAQc,GAAR,CAAZ;EACA,IAAMwC,IAAI,GAAGtD,IAAI,CAAC,CAAD,CAAJ,CAAQc,GAAR,CAAb;EACA,IAAMG,IAAI,GAAGjB,IAAI,CAAC,CAAD,CAAJ,CAAQc,GAAR,CAAb;EAEA,IAAIyC,OAAO,GAAGrD,QAAd;EACA,IAAIsD,WAAW,GAAG,CAAC,CAAnB;;EAEA,KAAK,IAAI1F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuF,GAAG,CAACtF,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;IACnC,IAAImD,IAAI,CAACnD,CAAD,CAAJ,KAAY,CAAZ,IAAiBwF,IAAI,CAACxF,CAAD,CAAJ,GAAUyF,OAA/B,EAAwC;MACtCA,OAAO,GAAGD,IAAI,CAACxF,CAAD,CAAd;MACA0F,WAAW,GAAG1F,CAAd;IACD;EACF;;EAED,IAAI0F,WAAW,IAAI,CAAnB,EAAsB;IACpBvC,IAAI,CAACuC,WAAD,CAAJ,GAAoB,CAApB;IACA,OAAOvF,IAAI,CAACiD,KAAL,CAAWmC,GAAG,CAACG,WAAD,CAAd,CAAP;EACD;;EACD,OAAO,CAAC,CAAR;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1TD;;;;;;;;;;;;;;;;;;AAmBA;AAIA;;;;AAGO,IAAMC,YAAb;EAOE,sBAAYC,IAAZ,EAA4BC,IAA5B,EAA4CC,MAA5C,EAA8DC,IAA9D,EAA4E;IAAA;;IANpE,eAAU,IAAIC,GAAJ,EAAV;IAEC,aAAgB,CAAhB;IAEA,aAAgB,CAAhB;;IAGP,IAAIJ,IAAI,CAAC3F,MAAL,KAAgB4F,IAAI,CAAC5F,MAArB,IAA+B2F,IAAI,CAAC3F,MAAL,KAAgB6F,MAAM,CAAC7F,MAA1D,EAAkE;MAChE,MAAM,IAAIgG,KAAJ,CAAU,4DAAV,CAAN;IACD,CAHyE,CAK1E;;;IACA,KAAKC,KAAL,GAAaH,IAAI,CAAC,CAAD,CAAjB;IACA,KAAKI,KAAL,GAAaJ,IAAI,CAAC,CAAD,CAAjB;;IACA,KAAK,IAAI/F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8F,MAAM,CAAC7F,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;MACtC,IAAMgD,GAAG,GAAG4C,IAAI,CAAC5F,CAAD,CAAhB;MACA,IAAMoG,GAAG,GAAGP,IAAI,CAAC7F,CAAD,CAAhB;MACA,KAAKqG,SAAL,CAAerD,GAAf,EAAoBoD,GAApB;MACA,IAAME,GAAG,GAAG,KAAKC,OAAL,CAAavD,GAAb,EAAkBoD,GAAlB,CAAZ;MACA,KAAKI,OAAL,CAAaC,GAAb,CAAiBH,GAAjB,EAAsB;QAAEI,KAAK,EAAEZ,MAAM,CAAC9F,CAAD,CAAf;QAAoBgD,GAAG,EAAHA,GAApB;QAAyBoD,GAAG,EAAHA;MAAzB,CAAtB;IACD;EACF;;EAtBH;IAAA;IAAA,OAwBU,iBAAQpD,GAAR,EAAqBoD,GAArB,EAAgC;MACtC,iBAAUpD,GAAV,cAAiBoD,GAAjB;IACD;EA1BH;IAAA;IAAA,OA4BU,mBAAUpD,GAAV,EAAuBoD,GAAvB,EAAkC;MACxC,IAAMO,YAAY,GAAG3D,GAAG,GAAG,KAAKkD,KAAX,IAAoBE,GAAG,GAAG,KAAKD,KAApD;;MACA,IAAI,CAACQ,YAAL,EAAmB;QACjB,MAAM,IAAIV,KAAJ,CAAU,uDAAV,CAAN;MACD;IACF;EAjCH;IAAA;IAAA,OAmCE,aAAIjD,GAAJ,EAAiBoD,GAAjB,EAA8BM,KAA9B,EAA2C;MACzC,KAAKL,SAAL,CAAerD,GAAf,EAAoBoD,GAApB;MACA,IAAME,GAAG,GAAG,KAAKC,OAAL,CAAavD,GAAb,EAAkBoD,GAAlB,CAAZ;;MACA,IAAI,CAAC,KAAKI,OAAL,CAAaI,GAAb,CAAiBN,GAAjB,CAAL,EAA4B;QAC1B,KAAKE,OAAL,CAAaC,GAAb,CAAiBH,GAAjB,EAAsB;UAAEI,KAAK,EAALA,KAAF;UAAS1D,GAAG,EAAHA,GAAT;UAAcoD,GAAG,EAAHA;QAAd,CAAtB;MACD,CAFD,MAEO;QACL,KAAKI,OAAL,CAAaK,GAAb,CAAiBP,GAAjB,EAAuBI,KAAvB,GAA+BA,KAA/B;MACD;IACF;EA3CH;IAAA;IAAA,OA6CE,aAAI1D,GAAJ,EAAiBoD,GAAjB,EAA8C;MAAA,IAAhBU,YAAgB,uEAAD,CAAC;MAC5C,KAAKT,SAAL,CAAerD,GAAf,EAAoBoD,GAApB;MACA,IAAME,GAAG,GAAG,KAAKC,OAAL,CAAavD,GAAb,EAAkBoD,GAAlB,CAAZ;;MACA,IAAI,KAAKI,OAAL,CAAaI,GAAb,CAAiBN,GAAjB,CAAJ,EAA2B;QACzB,OAAO,KAAKE,OAAL,CAAaK,GAAb,CAAiBP,GAAjB,EAAuBI,KAA9B;MACD;;MACD,OAAOI,YAAP;IACD;EApDH;IAAA;IAAA,OAsDE,kBAAqB;MAAA,IAAdC,OAAc,uEAAJ,IAAI;MACnB,IAAMC,YAAY,GAAY,EAA9B;MACA,KAAKR,OAAL,CAAaS,OAAb,CAAqB,UAACP,KAAD,EAAU;QAC7BM,YAAY,CAAC7E,IAAb,CAAkBuE,KAAlB;MACD,CAFD;;MAGA,IAAIK,OAAJ,EAAa;QACX;QACAC,YAAY,CAACE,IAAb,CAAkB,UAACC,CAAD,EAAIC,CAAJ,EAAS;UACzB,IAAID,CAAC,CAACnE,GAAF,KAAUoE,CAAC,CAACpE,GAAhB,EAAqB;YACnB,OAAOmE,CAAC,CAACf,GAAF,GAAQgB,CAAC,CAAChB,GAAjB;UACD;;UACD,OAAOe,CAAC,CAACnE,GAAF,GAAQoE,CAAC,CAACpE,GAAjB;QACD,CALD;MAMD;;MACD,OAAOgE,YAAP;IACD;EArEH;IAAA;IAAA,OAuEE,mBAAO;MACL,OAAO,CAAC,KAAKd,KAAN,EAAa,KAAKC,KAAlB,CAAP;IACD;EAzEH;IAAA;IAAA,OA2EE,mBAAO;MACL,OAAOkB,KAAK,CAACC,IAAN,CAAW,KAAKd,OAAhB,EAAyB;QAAA;QAAA,IAAEF,GAAF;QAAA,IAAOI,KAAP;;QAAA,OAAkBA,KAAK,CAAC1D,GAAxB;MAAA,CAAzB,CAAP;IACD;EA7EH;IAAA;IAAA,OA+EE,mBAAO;MACL,OAAOqE,KAAK,CAACC,IAAN,CAAW,KAAKd,OAAhB,EAAyB;QAAA;QAAA,IAAEF,GAAF;QAAA,IAAOI,KAAP;;QAAA,OAAkBA,KAAK,CAACN,GAAxB;MAAA,CAAzB,CAAP;IACD;EAjFH;IAAA;IAAA,OAmFE,qBAAS;MACP,OAAOiB,KAAK,CAACC,IAAN,CAAW,KAAKd,OAAhB,EAAyB;QAAA;QAAA,IAAEF,GAAF;QAAA,IAAOI,KAAP;;QAAA,OAAkBA,KAAK,CAACA,KAAxB;MAAA,CAAzB,CAAP;IACD;EArFH;IAAA;IAAA,OAuFE,iBAAQa,EAAR,EAA6D;MAC3D,KAAKf,OAAL,CAAaS,OAAb,CAAqB,UAACP,KAAD;QAAA,OAAWa,EAAE,CAACb,KAAK,CAACA,KAAP,EAAcA,KAAK,CAAC1D,GAApB,EAAyB0D,KAAK,CAACN,GAA/B,CAAb;MAAA,CAArB;IACD;EAzFH;IAAA;IAAA,OA2FE,aAAImB,EAAJ,EAA2D;MACzD,IAAMC,IAAI,GAAa,EAAvB;MACA,KAAKhB,OAAL,CAAaS,OAAb,CAAqB,UAACP,KAAD,EAAU;QAC7Bc,IAAI,CAACrF,IAAL,CAAUoF,EAAE,CAACb,KAAK,CAACA,KAAP,EAAcA,KAAK,CAAC1D,GAApB,EAAyB0D,KAAK,CAACN,GAA/B,CAAZ;MACD,CAFD;MAGA,IAAML,IAAI,GAAG,CAAC,KAAKG,KAAN,EAAa,KAAKC,KAAlB,CAAb;MACA,OAAO,IAAIR,YAAJ,CAAiB,KAAK8B,OAAL,EAAjB,EAAiC,KAAKC,OAAL,EAAjC,EAAiDF,IAAjD,EAAuDzB,IAAvD,CAAP;IACD;EAlGH;IAAA;IAAA,OAoGE,mBAAO;MAAA;;MACL,IAAMH,IAAI,GAAgBnE,yCAAA,CAAY,KAAKyE,KAAjB,CAA1B;MACA,IAAMyB,MAAM,GAAG/B,IAAI,CAAC5D,GAAL,CAAS,YAAK;QAC3B,OAAOP,yCAAA,CAAY,KAAI,CAAC0E,KAAjB,CAAP;MACD,CAFc,CAAf;MAGA,KAAKK,OAAL,CAAaS,OAAb,CAAqB,UAACP,KAAD,EAAU;QAC7BiB,MAAM,CAACjB,KAAK,CAAC1D,GAAP,CAAN,CAAkB0D,KAAK,CAACN,GAAxB,IAA+BM,KAAK,CAACA,KAArC;MACD,CAFD;MAGA,OAAOiB,MAAP;IACD;EA7GH;;EAAA;AAAA;AAgHA;;;;AAGM,SAAUC,SAAV,CAAoBC,MAApB,EAAwC;EAC5C,IAAMhC,IAAI,GAAa,EAAvB;EACA,IAAMD,IAAI,GAAa,EAAvB;EACA,IAAM4B,IAAI,GAAa,EAAvB;EAEAK,MAAM,CAACZ,OAAP,CAAe,UAACP,KAAD,EAAQ1D,GAAR,EAAaoD,GAAb,EAAoB;IACjCP,IAAI,CAAC1D,IAAL,CAAUa,GAAV;IACA4C,IAAI,CAACzD,IAAL,CAAUiE,GAAV;IACAoB,IAAI,CAACrF,IAAL,CAAUuE,KAAV;EACD,CAJD;EAMA,IAAMX,IAAI,GAAG,CAAC8B,MAAM,CAAC1B,KAAR,EAAe0B,MAAM,CAAC3B,KAAtB,CAAb;EACA,OAAO,IAAIP,YAAJ,CAAiBC,IAAjB,EAAuBC,IAAvB,EAA6B2B,IAA7B,EAAmCzB,IAAnC,CAAP;AACD;AAED;;;;AAGM,SAAU+B,QAAV,CAAmBlG,IAAnB,EAAiC;EACrC,2BAAeA,IAAf;EAAA,IAAOgE,IAAP;;EACA,IAAMiC,MAAM,GAAG,IAAIlC,YAAJ,CAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB,EAA6B/D,IAA7B,CAAf;;EACA,KAAK,IAAI5B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4F,IAApB,EAA0B5F,CAAC,EAA3B,EAA+B;IAC7B6H,MAAM,CAACpB,GAAP,CAAWzG,CAAX,EAAcA,CAAd,EAAiB,CAAjB;EACD;;EACD,OAAO6H,MAAP;AACD;AAED;;;;AAGM,SAAUE,gBAAV,CAA2BZ,CAA3B,EAA4CC,CAA5C,EAA2D;EAC/D,OAAOY,WAAW,CAACb,CAAD,EAAIC,CAAJ,EAAO,UAACvH,CAAD,EAAIC,CAAJ;IAAA,OAAUD,CAAC,GAAGC,CAAd;EAAA,CAAP,CAAlB;AACD;AAED;;;;AAGM,SAAUmI,GAAV,CAAcd,CAAd,EAA+BC,CAA/B,EAA8C;EAClD,OAAOY,WAAW,CAACb,CAAD,EAAIC,CAAJ,EAAO,UAACvH,CAAD,EAAIC,CAAJ;IAAA,OAAUD,CAAC,GAAGC,CAAd;EAAA,CAAP,CAAlB;AACD;AAED;;;;AAGM,SAAUoI,QAAV,CAAmBf,CAAnB,EAAoCC,CAApC,EAAmD;EACvD,OAAOY,WAAW,CAACb,CAAD,EAAIC,CAAJ,EAAO,UAACvH,CAAD,EAAIC,CAAJ;IAAA,OAAUD,CAAC,GAAGC,CAAd;EAAA,CAAP,CAAlB;AACD;AAED;;;;AAGM,SAAUqI,OAAV,CAAkBhB,CAAlB,EAAmCC,CAAnC,EAAkD;EACtD,OAAOY,WAAW,CAACb,CAAD,EAAIC,CAAJ,EAAO,UAACvH,CAAD,EAAIC,CAAJ;IAAA,OAAWD,CAAC,GAAGC,CAAJ,GAAQD,CAAR,GAAYC,CAAvB;EAAA,CAAP,CAAlB;AACD;AAED;;;;AAGM,SAAUsI,cAAV,CAAyBjB,CAAzB,EAA0CkB,MAA1C,EAAwD;EAC5D,OAAOlB,CAAC,CAACnF,GAAF,CAAM,UAAC0E,KAAD,EAAkB;IAC7B,OAAOA,KAAK,GAAG2B,MAAf;EACD,CAFM,CAAP;AAGD;AAED;;;;AAGM,SAAUC,cAAV,CAAyBC,CAAzB,EAAwC;EAC5C,IAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;EACA,IAAM3C,MAAM,GAAGyC,CAAC,CAACG,SAAF,EAAf;EACA,IAAM9C,IAAI,GAAG2C,CAAC,CAACd,OAAF,EAAb;EACA,IAAM5B,IAAI,GAAG0C,CAAC,CAACb,OAAF,EAAb;;EACA,KAAK,IAAI1H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8F,MAAM,CAAC7F,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;IACtC,IAAI8F,MAAM,CAAC9F,CAAD,CAAN,KAAc,CAAlB,EAAqB;MACnBwI,WAAW,CAACP,GAAZ,CAAgBjI,CAAhB;IACD;EACF;;EACD,IAAM2I,iBAAiB,GAAG,SAApBA,iBAAoB,CAACC,CAAD,EAAI1F,KAAJ;IAAA,OAAsB,CAACsF,WAAW,CAAC5B,GAAZ,CAAgB1D,KAAhB,CAAvB;EAAA,CAA1B;;EACA,IAAM2F,UAAU,GAAG/C,MAAM,CAACgD,MAAP,CAAcH,iBAAd,CAAnB;EACA,IAAMI,QAAQ,GAAGnD,IAAI,CAACkD,MAAL,CAAYH,iBAAZ,CAAjB;EACA,IAAMK,QAAQ,GAAGnD,IAAI,CAACiD,MAAL,CAAYH,iBAAZ,CAAjB;EAEA,OAAO,IAAIhD,YAAJ,CAAiBoD,QAAjB,EAA2BC,QAA3B,EAAqCH,UAArC,EAAiDN,CAAC,CAACU,OAAF,EAAjD,CAAP;AACD;AAQD;;;;AAGM,SAAUC,SAAV,CAAoBX,CAApB,EAA2D;EAAA,IAAtBY,QAAsB,uEAAd,IAAc;EAC/D,IAAMC,MAAM,GAAGC,OAAO,CAACF,QAAD,CAAtB;EAEA,IAAMG,SAAS,GAAG,IAAItD,GAAJ,EAAlB;EACAuC,CAAC,CAACtB,OAAF,CAAU,UAAC2B,CAAD,EAAI5F,GAAJ,EAASoD,GAAT,EAAgB;IACxB,IAAMP,IAAI,GAAGyD,SAAS,CAACzC,GAAV,CAAc7D,GAAd,KAAsB,EAAnC;IACA6C,IAAI,CAAC1D,IAAL,CAAUiE,GAAV;IACAkD,SAAS,CAAC7C,GAAV,CAAczD,GAAd,EAAmB6C,IAAnB;EACD,CAJD;EAMA,IAAM0D,UAAU,GAAG,IAAI5D,YAAJ,CAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB,EAA6B4C,CAAC,CAACU,OAAF,EAA7B,CAAnB;;EAV+D,2CAY7CK,SAAS,CAACE,IAAV,EAZ6C;EAAA;;EAAA;IAAA;MAAA,IAYpDxG,GAZoD;MAa7D,IAAM6C,IAAI,GAAGyD,SAAS,CAACzC,GAAV,CAAc7D,GAAd,EAAoBkE,IAApB,EAAb;MAEA,IAAMM,IAAI,GAAG3B,IAAI,CAAC7D,GAAL,CAAS,UAACoE,GAAD;QAAA,OAASmC,CAAC,CAAC1B,GAAF,CAAM7D,GAAN,EAAWoD,GAAX,CAAT;MAAA,CAAT,CAAb;MACA,IAAMqD,IAAI,GAAGL,MAAM,CAAC5B,IAAD,CAAnB;;MACA,KAAK,IAAIxH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyJ,IAAI,CAACxJ,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;QACpCuJ,UAAU,CAAC9C,GAAX,CAAezD,GAAf,EAAoB6C,IAAI,CAAC7F,CAAD,CAAxB,EAA6ByJ,IAAI,CAACzJ,CAAD,CAAjC;MACD;IAnB4D;;IAY/D,oDAAoC;MAAA;IAQnC;EApB8D;IAAA;EAAA;IAAA;EAAA;;EAsB/D,OAAOuJ,UAAP;AACD;AAMD,IAAMF,OAAO,6CACX;AAAA;AADW,EACK,aAACK,EAAD,EAAiB;EAC/B,IAAIC,GAAG,GAAG,CAACvH,QAAX;;EACA,KAAK,IAAIpC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0J,EAAE,CAACzJ,MAAvB,EAA+BD,CAAC,EAAhC,EAAoC;IAClC2J,GAAG,GAAGD,EAAE,CAAC1J,CAAD,CAAF,GAAQ2J,GAAR,GAAcD,EAAE,CAAC1J,CAAD,CAAhB,GAAsB2J,GAA5B;EACD;;EACD,OAAOD,EAAE,CAAC1H,GAAH,CAAO,UAACnC,CAAD;IAAA,OAAOA,CAAC,GAAG8J,GAAX;EAAA,CAAP,CAAP;AACD,CAPU,6BAQX;AAAA;AARW,EAQI,YAACD,EAAD,EAAiB;EAC9B,IAAIE,GAAG,GAAG,CAAV;;EACA,KAAK,IAAI5J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0J,EAAE,CAACzJ,MAAvB,EAA+BD,CAAC,EAAhC,EAAoC;IAClC4J,GAAG,IAAIF,EAAE,CAAC1J,CAAD,CAAT;EACD;;EACD,OAAO0J,EAAE,CAAC1H,GAAH,CAAO,UAACnC,CAAD;IAAA,OAAOA,CAAC,GAAG+J,GAAX;EAAA,CAAP,CAAP;AACD,CAdU,6BAeX;AAAA;AAfW,EAeI,YAACF,EAAD,EAAiB;EAC9B,IAAIE,GAAG,GAAG,CAAV;;EACA,KAAK,IAAI5J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0J,EAAE,CAACzJ,MAAvB,EAA+BD,CAAC,EAAhC,EAAoC;IAClC4J,GAAG,aAAIF,EAAE,CAAC1J,CAAD,CAAN,EAAa,CAAb,CAAH;EACD;;EACD,OAAO0J,EAAE,CAAC1H,GAAH,CAAO,UAACnC,CAAD;IAAA,OAAOM,IAAI,CAACQ,IAAL,CAAU,UAAC,EAAI,CAAJ,CAAD,GAASiJ,GAAnB,CAAP;EAAA,CAAP,CAAP;AACD,CArBU,YAAb;AAwBA;;;;AAGA,SAAS5B,WAAT,CAAqBb,CAArB,EAAsCC,CAAtC,EAAuDyC,EAAvD,EAA2F;EACzF,IAAMC,OAAO,GAAG,IAAIrB,GAAJ,EAAhB;EACA,IAAM7C,IAAI,GAAa,EAAvB;EACA,IAAMC,IAAI,GAAa,EAAvB;EACA,IAAM2B,IAAI,GAAa,EAAvB;;EAEA,IAAMuC,OAAO,GAAG,SAAVA,OAAU,CAAC/G,GAAD,EAAcoD,GAAd,EAA6B;IAC3CR,IAAI,CAACzD,IAAL,CAAUa,GAAV;IACA6C,IAAI,CAAC1D,IAAL,CAAUiE,GAAV;IACA,IAAM4D,SAAS,GAAGH,EAAE,CAAC1C,CAAC,CAACN,GAAF,CAAM7D,GAAN,EAAWoD,GAAX,CAAD,EAAkBgB,CAAC,CAACP,GAAF,CAAM7D,GAAN,EAAWoD,GAAX,CAAlB,CAApB;IACAoB,IAAI,CAACrF,IAAL,CAAU6H,SAAV;EACD,CALD;;EAOA,IAAMC,OAAO,GAAG9C,CAAC,CAACuB,SAAF,EAAhB;EACA,IAAMwB,KAAK,GAAG/C,CAAC,CAACM,OAAF,EAAd;EACA,IAAM0C,KAAK,GAAGhD,CAAC,CAACO,OAAF,EAAd;;EACA,KAAK,IAAI1H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiK,OAAO,CAAChK,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;IACvC,IAAMgD,GAAG,GAAGkH,KAAK,CAAClK,CAAD,CAAjB;IACA,IAAMoG,GAAG,GAAG+D,KAAK,CAACnK,CAAD,CAAjB;IACA,IAAMsG,GAAG,aAAMtD,GAAN,cAAaoD,GAAb,CAAT;IACA0D,OAAO,CAAC7B,GAAR,CAAY3B,GAAZ;IACAyD,OAAO,CAAC/G,GAAD,EAAMoD,GAAN,CAAP;EACD;;EAED,IAAMgE,OAAO,GAAGhD,CAAC,CAACsB,SAAF,EAAhB;EACA,IAAM2B,KAAK,GAAGjD,CAAC,CAACK,OAAF,EAAd;EACA,IAAM6C,KAAK,GAAGlD,CAAC,CAACM,OAAF,EAAd;;EACA,KAAK,IAAI1H,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGoK,OAAO,CAACnK,MAA5B,EAAoCD,GAAC,EAArC,EAAyC;IACvC,IAAMgD,IAAG,GAAGqH,KAAK,CAACrK,GAAD,CAAjB;IACA,IAAMoG,IAAG,GAAGkE,KAAK,CAACtK,GAAD,CAAjB;;IACA,IAAMsG,IAAG,aAAMtD,IAAN,cAAaoD,IAAb,CAAT;;IACA,IAAI0D,OAAO,CAAClD,GAAR,CAAYN,IAAZ,CAAJ,EAAsB;IACtByD,OAAO,CAAC/G,IAAD,EAAMoD,IAAN,CAAP;EACD;;EAED,IAAML,IAAI,GAAG,CAACoB,CAAC,CAACjB,KAAH,EAAUiB,CAAC,CAAChB,KAAZ,CAAb;EACA,OAAO,IAAIR,YAAJ,CAAiBC,IAAjB,EAAuBC,IAAvB,EAA6B2B,IAA7B,EAAmCzB,IAAnC,CAAP;AACD;AAED;;;;;;;;AAMM,SAAUwE,MAAV,CAAiB1K,CAAjB,EAAgC;EACpC,IAAM2G,OAAO,GAAY,EAAzB;EAEA3G,CAAC,CAACoH,OAAF,CAAU,UAACP,KAAD,EAAQ1D,GAAR,EAAaoD,GAAb,EAAoB;IAC5BI,OAAO,CAACrE,IAAR,CAAa;MAAEuE,KAAK,EAALA,KAAF;MAAS1D,GAAG,EAAHA,GAAT;MAAcoD,GAAG,EAAHA;IAAd,CAAb;EACD,CAFD;EAIAI,OAAO,CAACU,IAAR,CAAa,UAACC,CAAD,EAAIC,CAAJ,EAAS;IACpB,IAAID,CAAC,CAACnE,GAAF,KAAUoE,CAAC,CAACpE,GAAhB,EAAqB;MACnB,OAAOmE,CAAC,CAACf,GAAF,GAAQgB,CAAC,CAAChB,GAAjB;IACD;;IACD,OAAOe,CAAC,CAACnE,GAAF,GAAQoE,CAAC,CAACpE,GAAjB;EACD,CALD;EAOA,IAAMK,OAAO,GAAa,EAA1B;EACA,IAAMyC,MAAM,GAAa,EAAzB;EACA,IAAM0E,MAAM,GAAa,EAAzB;EAEA,IAAIC,UAAU,GAAG,CAAC,CAAlB;;EACA,KAAK,IAAIzK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwG,OAAO,CAACvG,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;IACvC,iBAA4BwG,OAAO,CAACxG,CAAD,CAAnC;IAAA,IAAQgD,GAAR,cAAQA,GAAR;IAAA,IAAaoD,GAAb,cAAaA,GAAb;IAAA,IAAkBM,KAAlB,cAAkBA,KAAlB;;IACA,IAAI1D,GAAG,KAAKyH,UAAZ,EAAwB;MACtBA,UAAU,GAAGzH,GAAb;MACAwH,MAAM,CAACrI,IAAP,CAAYnC,CAAZ;IACD;;IACDqD,OAAO,CAAClB,IAAR,CAAaiE,GAAb;IACAN,MAAM,CAAC3D,IAAP,CAAYuE,KAAZ;EACD;;EAED,OAAO;IAAErD,OAAO,EAAPA,OAAF;IAAWyC,MAAM,EAANA,MAAX;IAAmB0E,MAAM,EAANA;EAAnB,CAAP;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9WD;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AACA;AACA;AACA;AAGA;;;;AAGM,SAAUG,aAAV,CAAwBC,UAAxB,EAAgDpI,MAAhD,EAAgE;EACpE,OAAO,SAASqI,SAAT,CACLrJ,IADK,EAELsJ,SAFK,EAGL9G,UAHK,EAQY;IAAA,IAJjB+G,MAIiB,uEAJR,EAIQ;IAAA,IAHjB9G,aAGiB,uEAHD,EAGC;IAAA,IAFjB+G,KAEiB,uEAFT,KAES;IAAA,IADjBC,GACiB,uEADX,GACW;IAAA,IAAjBC,UAAiB,uEAAJ,IAAI;IAEjB,IAAMnH,SAAS,GAAGvC,IAAI,CAACvB,MAAvB;IACA,IAAM6D,YAAY,GAAG5B,2CAAA,CAAcV,IAAI,CAACvB,MAAnB,EAA2B+D,UAA3B,CAArB;;IAEA,KAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwB,IAAI,CAACvB,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;MACpC,IAAMqD,OAAO,GAAGnB,kDAAA,CAAqB8B,UAArB,EAAiCxC,IAAI,CAACvB,MAAtC,EAA8CuC,MAA9C,CAAhB;;MACA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,OAAO,CAACpD,MAA5B,EAAoC0C,CAAC,EAArC,EAAyC;QACvC,IAAM0B,CAAC,GAAGuG,UAAU,CAACpJ,IAAI,CAACxB,CAAD,CAAL,EAAUwB,IAAI,CAAC6B,OAAO,CAACV,CAAD,CAAR,CAAd,CAApB;QAEAT,2CAAA,CAAc4B,YAAd,EAA4B9D,CAA5B,EAA+BqE,CAA/B,EAAkChB,OAAO,CAACV,CAAD,CAAzC,EAA8C,CAA9C;QACAT,2CAAA,CAAc4B,YAAd,EAA4BT,OAAO,CAACV,CAAD,CAAnC,EAAwC0B,CAAxC,EAA2CrE,CAA3C,EAA8C,CAA9C;MACD;IACF;;IACD,IAAIkL,UAAJ,EAAgB;MACd,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,SAAS,CAAC7K,MAA9B,EAAsCkL,CAAC,EAAvC,EAA2C;QACzC,KAAK,IAAInL,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAG8K,SAAS,CAACK,CAAD,CAAT,CAAalL,MAAjC,EAAyCD,EAAC,EAA1C,EAA8C;UAC5C,IAAI8K,SAAS,CAACK,CAAD,CAAT,CAAanL,EAAb,IAAkB,CAAtB,EAAyB;YACvB;UACD;;UACD,KAAK,IAAI2C,EAAC,GAAG3C,EAAC,GAAG,CAAjB,EAAoB2C,EAAC,GAAGmI,SAAS,CAACK,CAAD,CAAT,CAAalL,MAArC,EAA6C0C,EAAC,EAA9C,EAAkD;YAChD,IAAImI,SAAS,CAACK,CAAD,CAAT,CAAaxI,EAAb,IAAkB,CAAtB,EAAyB;cACvB;YACD;;YACD,IAAM0B,EAAC,GAAGuG,UAAU,CAACpJ,IAAI,CAACsJ,SAAS,CAACK,CAAD,CAAT,CAAanL,EAAb,CAAD,CAAL,EAAwBwB,IAAI,CAACsJ,SAAS,CAACK,CAAD,CAAT,CAAaxI,EAAb,CAAD,CAA5B,CAApB;;YACAT,2CAAA,CAAc4B,YAAd,EAA4BgH,SAAS,CAACK,CAAD,CAAT,CAAanL,EAAb,CAA5B,EAA6CqE,EAA7C,EAAgDyG,SAAS,CAACK,CAAD,CAAT,CAAaxI,EAAb,CAAhD,EAAiE,CAAjE;YACAT,2CAAA,CAAc4B,YAAd,EAA4BgH,SAAS,CAACK,CAAD,CAAT,CAAaxI,EAAb,CAA5B,EAA6C0B,EAA7C,EAAgDyG,SAAS,CAACK,CAAD,CAAT,CAAanL,EAAb,CAAhD,EAAiE,CAAjE;UACD;QACF;MACF;IACF;;IAED,KAAK,IAAImL,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGJ,MAApB,EAA4BI,EAAC,EAA7B,EAAiC;MAC/B,IAAMjH,kBAAkB,GAAGhC,kDAAA,CAAqB4B,YAArB,EAAmCC,SAAnC,EAA8CC,UAA9C,EAA0DC,aAA1D,EAAyEzB,MAAzE,CAA3B;MAEA,IAAI4I,CAAC,GAAG,CAAR;;MACA,KAAK,IAAIpL,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG+D,SAApB,EAA+B/D,GAAC,EAAhC,EAAoC;QAClC,KAAK,IAAI2C,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGsB,aAApB,EAAmCtB,GAAC,EAApC,EAAwC;UACtC,IAAM0I,CAAC,GAAGlL,IAAI,CAACiD,KAAL,CAAWc,kBAAkB,CAAC,CAAD,CAAlB,CAAsBlE,GAAtB,EAAyB2C,GAAzB,CAAX,CAAV;;UACA,IAAI0I,CAAC,GAAG,CAAJ,IAAS5J,2CAAA,CAAce,MAAd,IAAwByI,GAArC,EAA0C;YACxC;UACD;;UACD,KAAK,IAAInI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmB,aAApB,EAAmCnB,CAAC,EAApC,EAAwC;YACtC,IAAMwI,CAAC,GAAGnL,IAAI,CAACiD,KAAL,CAAWc,kBAAkB,CAAC,CAAD,CAAlB,CAAsBlE,GAAtB,EAAyB8C,CAAzB,CAAX,CAAV;YACA,IAAMyI,EAAE,GAAGrH,kBAAkB,CAAC,CAAD,CAAlB,CAAsBlE,GAAtB,EAAyB2C,GAAzB,CAAX;YACA,IAAM6I,EAAE,GAAGtH,kBAAkB,CAAC,CAAD,CAAlB,CAAsBlE,GAAtB,EAAyB8C,CAAzB,CAAX;;YACA,IAAIwI,CAAC,GAAG,CAAJ,IAAU,CAACC,EAAD,IAAO,CAACC,EAAtB,EAA2B;cACzB;YACD;;YAED,IAAMnH,GAAC,GAAGuG,UAAU,CAACpJ,IAAI,CAAC6J,CAAD,CAAL,EAAU7J,IAAI,CAAC8J,CAAD,CAAd,CAApB;;YACAF,CAAC,IAAIlJ,2CAAA,CAAc4B,YAAd,EAA4BuH,CAA5B,EAA+BhH,GAA/B,EAAkCiH,CAAlC,EAAqC,CAArC,CAAL;YACAF,CAAC,IAAIlJ,2CAAA,CAAc4B,YAAd,EAA4BwH,CAA5B,EAA+BjH,GAA/B,EAAkCgH,CAAlC,EAAqC,CAArC,CAAL;UACD;QACF;MACF;;MACD,IAAID,CAAC,IAAIJ,KAAK,GAAGhH,UAAR,GAAqBxC,IAAI,CAACvB,MAAnC,EAA2C;QACzC;MACD;IACF;;IACD,IAAMwL,MAAM,GAAGvJ,6CAAA,CAAgB4B,YAAhB,CAAf;IACA,OAAO2H,MAAP;EACD,CAtED;AAuED;AAMK,SAAUC,mBAAV,CAA8Bd,UAA9B,EAAoD;EACxD,SAASe,cAAT,CAAwB3H,UAAxB,EAA4CxC,IAA5C,EAA2DoK,WAA3D,EAAiFC,KAAjF,EAAmGrJ,MAAnG,EAAmH;IACjH,KAAK,IAAIxC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4L,WAAW,CAAC3L,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;MAC3C,IAAMqD,OAAO,GAAG5B,mDAAA,CAAsBuC,UAAtB,EAAkCxC,IAAI,CAACvB,MAAvC,EAA+CuC,MAA/C,CAAhB;;MACA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,OAAO,CAACpD,MAA5B,EAAoC0C,CAAC,EAArC,EAAyC;QACvC,IAAIU,OAAO,CAACV,CAAD,CAAP,GAAa,CAAjB,EAAoB;UAClB;QACD;;QACD,IAAM0B,CAAC,GAAGuG,UAAU,CAACpJ,IAAI,CAAC6B,OAAO,CAACV,CAAD,CAAR,CAAL,EAAmBiJ,WAAW,CAAC5L,CAAD,CAA9B,CAApB;QACAkC,2CAAA,CAAc2J,KAAd,EAAqB7L,CAArB,EAAwBqE,CAAxB,EAA2BhB,OAAO,CAACV,CAAD,CAAlC,EAAuC,CAAvC;MACD;IACF;EACF;;EAED,SAASmJ,YAAT,CAAsBC,KAAtB,EAA4CvK,IAA5C,EAA2DoK,WAA3D,EAAiFC,KAAjF,EAAmGrJ,MAAnG,EAAmH;IACjH,KAAK,IAAIxC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4L,WAAW,CAAC3L,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;MAC3C,IAAMqD,OAAO,GAAGqH,iDAAA,CAAoBkB,WAAW,CAAC5L,CAAD,CAA/B,EAAoC+L,KAApC,EAA2CvJ,MAA3C,CAAhB;;MAEA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,OAAO,CAACpD,MAA5B,EAAoC0C,CAAC,EAArC,EAAyC;QACvC,IAAIU,OAAO,CAACV,CAAD,CAAP,GAAa,CAAjB,EAAoB;UAClB;QACD;;QACD,IAAM0B,CAAC,GAAGuG,UAAU,CAACpJ,IAAI,CAAC6B,OAAO,CAACV,CAAD,CAAR,CAAL,EAAmBiJ,WAAW,CAAC5L,CAAD,CAA9B,CAApB;QACAkC,2CAAA,CAAc2J,KAAd,EAAqB7L,CAArB,EAAwBqE,CAAxB,EAA2BhB,OAAO,CAACV,CAAD,CAAlC,EAAuC,CAAvC;MACD;IACF;EACF;;EAED,OAAO;IAAEgJ,cAAc,EAAdA,cAAF;IAAkBG,YAAY,EAAZA;EAAlB,CAAP;AACD;AAIK,SAAUG,uBAAV,CAAkCrB,UAAlC,EAAwD;EAC5D,OAAO,SAASsB,UAAT,CAAoB1K,IAApB,EAAmC2K,KAAnC,EAA+DC,cAA/D,EAA0FR,WAA1F,EAA8G;IACnH,qBAA4B/D,2CAAA,CAAcsE,KAAd,CAA5B;IAAA,IAAQ9I,OAAR,kBAAQA,OAAR;IAAA,IAAiBmH,MAAjB,kBAAiBA,MAAjB;;IAEA,KAAK,IAAIxK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4L,WAAW,CAAC3L,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;MAC3C,IAAMqM,KAAK,GAAG,IAAI5D,GAAJ,CAAQ2D,cAAc,CAAC,CAAD,CAAd,CAAkBpM,CAAlB,CAAR,CAAd;;MACA,OAAO,IAAP,EAAa;QACX;QACA,IAAMsM,MAAM,GAAGpK,kDAAA,CAAqBkK,cAArB,EAAqCpM,CAArC,CAAf;;QAEA,IAAIsM,MAAM,KAAK,CAAC,CAAhB,EAAmB;UACjB;QACD;;QACD,IAAMC,UAAU,GAAGlJ,OAAO,CAACmJ,KAAR,CAAchC,MAAM,CAAC8B,MAAD,CAApB,EAA8B9B,MAAM,CAAC8B,MAAM,GAAG,CAAV,CAApC,CAAnB;;QAPW,2CAQaC,UARb;QAAA;;QAAA;UAQX,oDAAoC;YAAA,IAAzBE,SAAyB;;YAClC,IAAIA,SAAS,KAAKH,MAAd,IAAwBG,SAAS,KAAK,CAAC,CAAvC,IAA4CJ,KAAK,CAACzF,GAAN,CAAU6F,SAAV,CAAhD,EAAsE;cACpE;YACD;;YACD,IAAMpI,CAAC,GAAGuG,UAAU,CAACpJ,IAAI,CAACiL,SAAD,CAAL,EAAkBb,WAAW,CAAC5L,CAAD,CAA7B,CAApB;YACAkC,oDAAA,CAAuBkK,cAAvB,EAAuCpM,CAAvC,EAA0CqE,CAA1C,EAA6CoI,SAA7C,EAAwD,CAAxD;YACAJ,KAAK,CAACpE,GAAN,CAAUwE,SAAV;UACD;QAfU;UAAA;QAAA;UAAA;QAAA;MAgBZ;IACF;;IACD,OAAOL,cAAP;EACD,CAxBD;AAyBD;AAEK,SAAUM,gBAAV,CACJC,MADI,EAEJnL,IAFI,EAGJoK,WAHI,EAIJ5H,UAJI,EAKJ2H,cALI,EAMJG,YANI,EAOJtJ,MAPI,EAOY;EAEhB,IAAMoK,OAAO,GAAG1K,2CAAA,CAAc0J,WAAW,CAAC3L,MAA1B,EAAkC+D,UAAlC,CAAhB;EACA2H,cAAc,CAAC3H,UAAD,EAAaxC,IAAb,EAAmBoK,WAAnB,EAAgCgB,OAAhC,EAAyCpK,MAAzC,CAAd;;EACA,IAAImK,MAAJ,EAAY;IAAA,4CACSA,MADT;IAAA;;IAAA;MACV,uDAA2B;QAAA,IAAhBjC,MAAgB;QACzBoB,YAAY,CAACpB,MAAD,EAAOlJ,IAAP,EAAaoK,WAAb,EAA0BgB,OAA1B,EAAmCpK,MAAnC,CAAZ;MACD;IAHS;MAAA;IAAA;MAAA;IAAA;EAIX;;EACD,OAAOoK,OAAP;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChOD;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AAeO,IAAMC,QAAb,6BACE,kBAAmBC,WAAnB,EAAmDC,OAAnD,EAA6EC,QAA7E,EAA0G3J,OAA1G,EAA6H;EAAA;;EAA1G;EAAgC;EAA0B;EAA6B;AAAuB,CADnI;AAIA;;;;AAGM,SAAU4J,UAAV,CAAqBzL,IAArB,EAAoCwC,UAApC,EAAwDkJ,MAAxD,EAAwE1K,MAAxE,EAAwF;EAC5F,IAAM2K,QAAQ,GAAGhN,IAAI,CAACwJ,GAAL,CAAS,EAAT,EAAa3F,UAAb,CAAjB;EAEA,IAAMoJ,KAAK,GAAG3L,yCAAA,CAAYyL,MAAZ,EAAoBlL,GAApB,CAAwB,UAAC4G,CAAD,EAAI5I,CAAJ;IAAA,OAAUsN,QAAQ,CAAC9L,IAAD,EAAO2L,QAAP,EAAiBnN,CAAjB,EAAoBwC,MAApB,CAAlB;EAAA,CAAxB,CAAd;EACA,IAAMmK,MAAM,GAAGS,KAAK,CAACpL,GAAN,CAAU,UAAC0I,IAAD;IAAA,OAAU6C,WAAW,CAAC7C,IAAD,EAAOyC,QAAP,CAArB;EAAA,CAAV,CAAf;EAEA,OAAOR,MAAP;AACD;AAED;;;;;AAIA,SAASW,QAAT,CAAkB9L,IAAlB,EAA2E;EAAA,IAA1C2L,QAA0C,uEAA/B,EAA+B;EAAA,IAA3BhC,CAA2B;EAAA,IAAhB3I,MAAgB;EACzE,IAAMa,OAAO,GAAG5B,yCAAA,CAAYD,IAAI,CAACvB,MAAjB,CAAhB;EACA,IAAMyK,IAAI,GAAG8C,iBAAiB,CAAChM,IAAD,EAAO6B,OAAP,EAAgB8J,QAAhB,EAA0BhC,CAA1B,EAA6B3I,MAA7B,CAA9B;EACA,OAAOkI,IAAP;AACD;;AAED,SAAS8C,iBAAT,CAA2BhM,IAA3B,EAA0C6B,OAA1C,EAAuG;EAAA,IAA1C8J,QAA0C,uEAA/B,EAA+B;EAAA,IAA3B7B,CAA2B;EAAA,IAAhB9I,MAAgB;;EACrG,IAAIa,OAAO,CAACpD,MAAR,GAAiBkN,QAArB,EAA+B;IAC7B,IAAMM,YAAY,GAAGC,8BAA8B,CAAClM,IAAD,EAAO6B,OAAP,EAAgBb,MAAhB,CAAnD;IACA,IAAQmL,WAAR,GAA0DF,YAA1D,CAAQE,WAAR;IAAA,IAAqBC,YAArB,GAA0DH,YAA1D,CAAqBG,YAArB;IAAA,IAAmCC,UAAnC,GAA0DJ,YAA1D,CAAmCI,UAAnC;IAAA,IAA+CC,MAA/C,GAA0DL,YAA1D,CAA+CK,MAA/C;IAEA,IAAM3I,SAAS,GAAGqI,iBAAiB,CAAChM,IAAD,EAAOmM,WAAP,EAAoBR,QAApB,EAA8B7B,CAAC,GAAG,CAAlC,EAAqC9I,MAArC,CAAnC;IACA,IAAM4C,UAAU,GAAGoI,iBAAiB,CAAChM,IAAD,EAAOoM,YAAP,EAAqBT,QAArB,EAA+B7B,CAAC,GAAG,CAAnC,EAAsC9I,MAAtC,CAApC;IAEA,IAAMuL,KAAI,GAAG;MAAE5I,SAAS,EAATA,SAAF;MAAaC,UAAU,EAAVA,UAAb;MAAyB4I,MAAM,EAAE,KAAjC;MAAwCH,UAAU,EAAVA,UAAxC;MAAoDC,MAAM,EAANA;IAApD,CAAb;IACA,OAAOC,KAAP;EACD;;EACD,IAAMA,IAAI,GAAG;IAAE1K,OAAO,EAAPA,OAAF;IAAW2K,MAAM,EAAE;EAAnB,CAAb;EACA,OAAOD,IAAP;AACD;AAED;;;;;;;;;;AAQA,SAASL,8BAAT,CAAwClM,IAAxC,EAAuD6B,OAAvD,EAA0Eb,MAA1E,EAA0F;EACxF,IAAMyL,GAAG,GAAGzM,IAAI,CAAC,CAAD,CAAJ,CAAQvB,MAApB,CADwF,CAGxF;;EACA,IAAMiO,SAAS,GAAGzM,8CAAA,CAAiB4B,OAAO,CAACpD,MAAzB,EAAiCuC,MAAjC,CAAlB;EACA,IAAI2L,UAAU,GAAG1M,8CAAA,CAAiB4B,OAAO,CAACpD,MAAzB,EAAiCuC,MAAjC,CAAjB;EACA2L,UAAU,IAAID,SAAS,KAAKC,UAAd,GAA2B,CAA3B,GAA+B,CAA7C;EACAA,UAAU,IAAI9K,OAAO,CAACpD,MAAtB;EACA,IAAMmO,IAAI,GAAG/K,OAAO,CAAC6K,SAAD,CAApB;EACA,IAAMG,KAAK,GAAGhL,OAAO,CAAC8K,UAAD,CAArB,CATwF,CAWxF;EACA;;EACA,IAAIG,gBAAgB,GAAG,CAAvB;EACA,IAAMC,gBAAgB,GAAG9M,yCAAA,CAAYwM,GAAZ,CAAzB;;EAEA,KAAK,IAAIjO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuO,gBAAgB,CAACtO,MAArC,EAA6CD,CAAC,EAA9C,EAAkD;IAChDuO,gBAAgB,CAACvO,CAAD,CAAhB,GAAsBwB,IAAI,CAAC4M,IAAD,CAAJ,CAAWpO,CAAX,IAAgBwB,IAAI,CAAC6M,KAAD,CAAJ,CAAYrO,CAAZ,CAAtC;IACAsO,gBAAgB,IAAKC,gBAAgB,CAACvO,CAAD,CAAhB,IAAuBwB,IAAI,CAAC4M,IAAD,CAAJ,CAAWpO,CAAX,IAAgBwB,IAAI,CAAC6M,KAAD,CAAJ,CAAYrO,CAAZ,CAAvC,CAAD,GAA2D,GAA/E;EACD,CAnBuF,CAqBxF;EACA;EACA;;;EACA,IAAIwO,KAAK,GAAG,CAAZ;EACA,IAAIC,MAAM,GAAG,CAAb;EACA,IAAMC,IAAI,GAAGjN,yCAAA,CAAY4B,OAAO,CAACpD,MAApB,CAAb;;EACA,KAAK,IAAID,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGqD,OAAO,CAACpD,MAA5B,EAAoCD,EAAC,EAArC,EAAyC;IACvC,IAAI2O,MAAM,GAAGL,gBAAb;;IACA,KAAK,IAAIjK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4J,GAApB,EAAyB5J,CAAC,EAA1B,EAA8B;MAC5BsK,MAAM,IAAIJ,gBAAgB,CAAClK,CAAD,CAAhB,GAAsB7C,IAAI,CAAC6B,OAAO,CAACrD,EAAD,CAAR,CAAJ,CAAiBqE,CAAjB,CAAhC;IACD;;IACD,IAAIsK,MAAM,KAAK,CAAf,EAAkB;MAChBD,IAAI,CAAC1O,EAAD,CAAJ,GAAUyB,8CAAA,CAAiB,CAAjB,EAAoBe,MAApB,CAAV;;MACA,IAAIkM,IAAI,CAAC1O,EAAD,CAAJ,KAAY,CAAhB,EAAmB;QACjBwO,KAAK,IAAI,CAAT;MACD,CAFD,MAEO;QACLC,MAAM,IAAI,CAAV;MACD;IACF,CAPD,MAOO,IAAIE,MAAM,GAAG,CAAb,EAAgB;MACrBD,IAAI,CAAC1O,EAAD,CAAJ,GAAU,CAAV;MACAwO,KAAK,IAAI,CAAT;IACD,CAHM,MAGA;MACLE,IAAI,CAAC1O,EAAD,CAAJ,GAAU,CAAV;MACAyO,MAAM,IAAI,CAAV;IACD;EACF,CA9CuF,CAgDxF;;;EACA,IAAMd,WAAW,GAAGlM,yCAAA,CAAY+M,KAAZ,CAApB;EACA,IAAMZ,YAAY,GAAGnM,yCAAA,CAAYgN,MAAZ,CAArB,CAlDwF,CAoDxF;;EACAD,KAAK,GAAG,CAAR;EACAC,MAAM,GAAG,CAAT;;EACA,KAAK,IAAMzO,GAAX,IAAgByB,yCAAA,CAAYiN,IAAI,CAACzO,MAAjB,CAAhB,EAA0C;IACxC,IAAIyO,IAAI,CAAC1O,GAAD,CAAJ,KAAY,CAAhB,EAAmB;MACjB2N,WAAW,CAACa,KAAD,CAAX,GAAqBnL,OAAO,CAACrD,GAAD,CAA5B;MACAwO,KAAK,IAAI,CAAT;IACD,CAHD,MAGO;MACLZ,YAAY,CAACa,MAAD,CAAZ,GAAuBpL,OAAO,CAACrD,GAAD,CAA9B;MACAyO,MAAM,IAAI,CAAV;IACD;EACF;;EAED,OAAO;IACLd,WAAW,EAAXA,WADK;IAELC,YAAY,EAAZA,YAFK;IAGLC,UAAU,EAAEU,gBAHP;IAILT,MAAM,EAAEQ;EAJH,CAAP;AAMD;;AAED,SAASf,WAAT,CAAqB7C,IAArB,EAAqDyC,QAArD,EAAqE;EACnE,IAAMyB,MAAM,GAAGC,QAAQ,CAACnE,IAAD,CAAvB;EACA,IAAMoE,OAAO,GAAGC,SAAS,CAACrE,IAAD,CAAzB,CAFmE,CAInE;;EACA,IAAMoC,WAAW,GAAGrL,yCAAA,CAAYmN,MAAZ,EAAoB5M,GAApB,CAAwB;IAAA,OAAMP,yCAAA,CAAYiJ,IAAI,CAACmD,UAAL,GAAkBnD,IAAI,CAACmD,UAAL,CAAgB5N,MAAlC,GAA2C,CAAvD,CAAN;EAAA,CAAxB,CAApB;EAEA,IAAM8M,OAAO,GAAGtL,yCAAA,CAAYmN,MAAZ,CAAhB;EACA,IAAM5B,QAAQ,GAAGvL,yCAAA,CAAYmN,MAAZ,EAAoB5M,GAApB,CAAwB;IAAA,OAAM,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAN;EAAA,CAAxB,CAAjB;EACA,IAAMqB,OAAO,GAAG5B,yCAAA,CAAYqN,OAAZ,EAAqB9M,GAArB,CAAyB;IAAA,OAAMP,yCAAA,CAAY0L,QAAZ,EAAsBnL,GAAtB,CAA0B;MAAA,OAAM,CAAC,CAAP;IAAA,CAA1B,CAAN;EAAA,CAAzB,CAAhB;EACAgN,gBAAgB,CAACtE,IAAD,EAAOoC,WAAP,EAAoBC,OAApB,EAA6BC,QAA7B,EAAuC3J,OAAvC,EAAgD,CAAhD,EAAmD,CAAnD,CAAhB;EACA,OAAO,IAAIwJ,QAAJ,CAAaC,WAAb,EAA0BC,OAA1B,EAAmCC,QAAnC,EAA6C3J,OAA7C,CAAP;AACD;;AAED,SAAS2L,gBAAT,CACEtE,IADF,EAEEoC,WAFF,EAGEC,OAHF,EAIEC,QAJF,EAKE3J,OALF,EAME4L,OANF,EAOEC,OAPF,EAOiB;EAEf,IAAIxE,IAAI,CAACsD,MAAT,EAAiB;IAAA;;IACfhB,QAAQ,CAACiC,OAAD,CAAR,CAAkB,CAAlB,IAAuB,CAACC,OAAxB,CADe,CAGf;IACA;;IACA,2BAAO,CAACA,OAAD,CAAP,EAAiBC,MAAjB,0BAAwB,CAAxB,EAA2BzE,IAAI,CAACrH,OAAL,CAAcpD,MAAzC,4BAAoDyK,IAAI,CAACrH,OAAzD;;IACA6L,OAAO,IAAI,CAAX;IACA,OAAO;MAAED,OAAO,EAAPA,OAAF;MAAWC,OAAO,EAAPA;IAAX,CAAP;EACD;;EACDpC,WAAW,CAACmC,OAAD,CAAX,GAAuBvE,IAAI,CAACmD,UAA5B;EACAd,OAAO,CAACkC,OAAD,CAAP,GAAmBvE,IAAI,CAACoD,MAAxB;EACAd,QAAQ,CAACiC,OAAD,CAAR,CAAkB,CAAlB,IAAuBA,OAAO,GAAG,CAAjC;EACA,IAAMG,UAAU,GAAGH,OAAnB;EAEA,IAAII,GAAG,GAAGL,gBAAgB,CAACtE,IAAI,CAACvF,SAAN,EAAkB2H,WAAlB,EAA+BC,OAA/B,EAAwCC,QAAxC,EAAkD3J,OAAlD,EAA2D4L,OAAO,GAAG,CAArE,EAAwEC,OAAxE,CAA1B;EACAD,OAAO,GAAGI,GAAG,CAACJ,OAAd;EACAC,OAAO,GAAGG,GAAG,CAACH,OAAd;EAEAlC,QAAQ,CAACoC,UAAD,CAAR,CAAqB,CAArB,IAA0BH,OAAO,GAAG,CAApC;EAEAI,GAAG,GAAGL,gBAAgB,CAACtE,IAAI,CAACtF,UAAN,EAAmB0H,WAAnB,EAAgCC,OAAhC,EAAyCC,QAAzC,EAAmD3J,OAAnD,EAA4D4L,OAAO,GAAG,CAAtE,EAAyEC,OAAzE,CAAtB;EACA,OAAO;IAAED,OAAO,EAAEI,GAAG,CAACJ,OAAf;IAAwBC,OAAO,EAAEG,GAAG,CAACH;EAArC,CAAP;AACD;;AAED,SAASL,QAAT,CAAkBnE,IAAlB,EAAgD;EAC9C,IAAIA,IAAI,CAACsD,MAAT,EAAiB;IACf,OAAO,CAAP;EACD;;EACD,OAAO,IAAIa,QAAQ,CAACnE,IAAI,CAACvF,SAAN,CAAZ,GAAgC0J,QAAQ,CAACnE,IAAI,CAACtF,UAAN,CAA/C;AACD;;AAED,SAAS2J,SAAT,CAAmBrE,IAAnB,EAAiD;EAC/C,IAAIA,IAAI,CAACsD,MAAT,EAAiB;IACf,OAAO,CAAP;EACD;;EACD,OAAOe,SAAS,CAACrE,IAAI,CAACvF,SAAN,CAAT,GAA6B4J,SAAS,CAACrE,IAAI,CAACtF,UAAN,CAA7C;AACD;AAED;;;;;;;;;;;AASM,SAAUkK,aAAV,CAAwBC,QAAxB,EAA4C;EAChD,IAAIA,QAAQ,CAACtP,MAAT,GAAkB,CAAtB,EAAyB;IACvB,IAAM0H,MAAM,GAAe,EAA3B;;IADuB,2CAEJ4H,QAFI;IAAA;;IAAA;MAEvB,oDAA6B;QAAA,IAAlB7E,IAAkB;QAC3B/C,MAAM,CAACxF,IAAP,aAAM,qBAASuI,IAAI,CAACrH,OAAd,EAAN;MACD;IAJsB;MAAA;IAAA;MAAA;IAAA;;IAKvB,OAAOsE,MAAP;EACD;;EACD,OAAO,CAAC,CAAC,CAAC,CAAF,CAAD,CAAP;AACD;AAED;;;;AAGA,SAAS6H,UAAT,CAAoB3B,UAApB,EAA0CC,MAA1C,EAA0D2B,KAA1D,EAAyEjN,MAAzE,EAAyF;EACvF,IAAImM,MAAM,GAAGb,MAAb;;EACA,KAAK,IAAIzJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoL,KAAK,CAACxP,MAA1B,EAAkCoE,CAAC,EAAnC,EAAuC;IACrCsK,MAAM,IAAId,UAAU,CAACxJ,CAAD,CAAV,GAAgBoL,KAAK,CAACpL,CAAD,CAA/B;EACD;;EAED,IAAIsK,MAAM,KAAK,CAAf,EAAkB;IAChB,IAAMD,IAAI,GAAGjN,8CAAA,CAAiB,CAAjB,EAAoBe,MAApB,CAAb;IACA,OAAOkM,IAAP;EACD;;EACD,IAAIC,MAAM,GAAG,CAAb,EAAgB;IACd,OAAO,CAAP;EACD;;EACD,OAAO,CAAP;AACD;AAED;;;;;AAGM,SAAU3C,cAAV,CAAyByD,KAAzB,EAAwC/E,IAAxC,EAAwDlI,MAAxD,EAAwE;EAC5E,IAAIuL,IAAI,GAAG,CAAX;;EACA,OAAOrD,IAAI,CAACsC,QAAL,CAAce,IAAd,EAAoB,CAApB,IAAyB,CAAhC,EAAmC;IACjC,IAAMW,IAAI,GAAGc,UAAU,CAAC9E,IAAI,CAACoC,WAAL,CAAiBiB,IAAjB,CAAD,EAAyBrD,IAAI,CAACqC,OAAL,CAAagB,IAAb,CAAzB,EAA6C0B,KAA7C,EAAoDjN,MAApD,CAAvB;;IACA,IAAIkM,IAAI,KAAK,CAAb,EAAgB;MACdX,IAAI,GAAGrD,IAAI,CAACsC,QAAL,CAAce,IAAd,EAAoB,CAApB,CAAP;IACD,CAFD,MAEO;MACLA,IAAI,GAAGrD,IAAI,CAACsC,QAAL,CAAce,IAAd,EAAoB,CAApB,CAAP;IACD;EACF;;EAED,IAAM7K,KAAK,GAAG,CAAC,CAAD,GAAKwH,IAAI,CAACsC,QAAL,CAAce,IAAd,EAAoB,CAApB,CAAnB;EACA,OAAOrD,IAAI,CAACrH,OAAL,CAAaH,KAAb,CAAP;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxTD;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA,IAAM0M,kBAAkB,GAAG,IAA3B;AACA,IAAMC,gBAAgB,GAAG,IAAzB;AAmHA;;;;;;;;;;;;;;;;;;;;;AAoBO,IAAMC,IAAb;EAgEE,gBAAuC;IAAA;;IAAA,IAA3BC,MAA2B,uEAAF,EAAE;;IAAA;;IA/D/B,oBAAe,GAAf;IAEA,yBAAoB,GAApB;IAEA,eAAU,GAAV;IAEA,mBAAc,CAAd;IAEA,eAAU,CAAV;IAEA,kBAAa,EAAb;IAEA,0BAAqB,CAArB;IAEA,cAAS5P,IAAI,CAACqC,MAAd;IAEA,yBAAoB,GAApB;IAEA,qBAAgB,GAAhB;IAEA,cAAS,GAAT;IAEA,0BAAqB,GAArB,CAyC+B,CAvCvC;;IACQ,oBAAY;IAAA;IAAZ;IAEA,oBAAe,GAAf;IAEA,wBAAmB,KAAKwB,UAAxB;IAEA,kBAAyBtD,SAAzB;IAYA,qBAAgB,KAAhB;IAEA,gBAA4B,EAA5B,CAkB+B,CALvC;;IACQ,iBAAwB,EAAxB;IAEA,yBAAoB,IAAIsP,iBAAJ,EAApB;;IAGN,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAC3J,GAAD,EAAgB;MAC/B,IAAIyJ,MAAM,CAACzJ,GAAD,CAAN,KAAgB4J,SAApB,EAA+B,KAAI,CAAC5J,GAAD,CAAJ,GAAYyJ,MAAM,CAACzJ,GAAD,CAAlB;IAChC,CAFD;;IAIA2J,QAAQ,CAAC,YAAD,CAAR;IACAA,QAAQ,CAAC,cAAD,CAAR;IACAA,QAAQ,CAAC,mBAAD,CAAR;IACAA,QAAQ,CAAC,SAAD,CAAR;IACAA,QAAQ,CAAC,aAAD,CAAR;IACAA,QAAQ,CAAC,SAAD,CAAR;IACAA,QAAQ,CAAC,YAAD,CAAR;IACAA,QAAQ,CAAC,oBAAD,CAAR;IACAA,QAAQ,CAAC,QAAD,CAAR;IACAA,QAAQ,CAAC,mBAAD,CAAR;IACAA,QAAQ,CAAC,eAAD,CAAR;IACAA,QAAQ,CAAC,QAAD,CAAR;IACAA,QAAQ,CAAC,oBAAD,CAAR;EACD;EAED;;;;;EApFF;IAAA;IAAA,OAuFE,aAAIE,CAAJ,EAAgBC,gBAAhB,EAAqC;MACnC,KAAKC,aAAL,CAAmBF,CAAnB,EAAsBC,gBAAtB;MACA,KAAKE,cAAL;MAEA,OAAO,KAAKC,SAAZ;IACD;IAED;;;;;EA9FF;IAAA;IAAA;MAAA,2EAkGE,iBAAeJ,CAAf,EAA2BC,gBAA3B;QAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAkDI,QAAlD,2DAAsG;kBAAA,OAAM,IAAN;gBAAA,CAAtG;gBACE,KAAKH,aAAL,CAAmBF,CAAnB,EAAsBC,gBAAtB;gBADF;gBAAA,OAGQ,KAAKK,mBAAL,CAAyBD,QAAzB,CAHR;;cAAA;gBAAA,iCAIS,KAAKD,SAJd;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAlGF;;MAAA;QAAA;MAAA;;MAAA;IAAA;IAyGE;;;;EAzGF;IAAA;IAAA,OA4GE,iCAAwBG,CAAxB,EAAsE;MAAA,IAAjCX,MAAiC,uEAAF,EAAE;MACpE,KAAKW,CAAL,GAASA,CAAT;MACA,KAAKC,YAAL,GAAoBZ,MAAM,CAACY,YAAP,IAAuB,KAAKA,YAAhD;MACA,KAAKC,YAAL,GAAoBb,MAAM,CAACa,YAAP,IAAuB,KAAKA,YAAhD;MACA,KAAKC,gBAAL,GAAwBd,MAAM,CAACc,gBAAP,IAA2B,KAAKA,gBAAxD;IACD;IAED;;;;EAnHF;IAAA;IAAA,OAsHE,2BAAkBC,UAAlB,EAA0CC,YAA1C,EAAkE;MAChE,KAAKD,UAAL,GAAkBA,UAAlB;MACA,KAAKC,YAAL,GAAoBA,YAApB;IACD;IAED;;;;;;;EA3HF;IAAA;IAAA,OAiIE,uBAAcZ,CAAd,EAA0BC,gBAA1B,EAA+C;MAC7C,IAAID,CAAC,CAAClQ,MAAF,IAAY,KAAK+D,UAArB,EAAiC;QAC/B,MAAM,IAAIiC,KAAJ,mCAAqCkK,CAAC,CAAClQ,MAAvC,qCAAwE,KAAK+D,UAA7E,0DAAN;MACD,CAH4C,CAK7C;;;MACA,IAAI,KAAKmM,CAAL,KAAWA,CAAX,IAAgB,KAAKa,aAAzB,EAAwC;QACtC,OAAO,KAAKC,UAAL,EAAP;MACD;;MAED,KAAKd,CAAL,GAASA,CAAT;;MAEA,IAAI,CAAC,KAAKW,UAAN,IAAoB,CAAC,KAAKC,YAA9B,EAA4C;QAC1C,IAAMG,UAAU,GAAG,KAAKC,gBAAL,CAAsBhB,CAAtB,CAAnB;QACA,KAAKW,UAAL,GAAkBI,UAAU,CAACJ,UAA7B;QACA,KAAKC,YAAL,GAAoBG,UAAU,CAACH,YAA/B;MACD;;MAED,KAAK5E,KAAL,GAAa,KAAKiF,kBAAL,CAAwBjB,CAAxB,EAA2B,KAAKnM,UAAhC,EAA4C,KAAKqN,aAAjD,CAAb,CAlB6C,CAoB7C;;MACA,KAAKC,aAAL;MACA,KAAKC,WAAL,GAAmB,KAAKC,eAAL,CAAqBrB,CAArB,CAAnB,CAtB6C,CAwB7C;;MACA,KAAKsB,mCAAL;;MAEA,4BAAwC,KAAKC,gCAAL,CAAsCtB,gBAAtC,CAAxC;MAAA,IAAQuB,IAAR,yBAAQA,IAAR;MAAA,IAAcC,IAAd,yBAAcA,IAAd;MAAA,IAAoBC,eAApB,yBAAoBA,eAApB,CA3B6C,CA6B7C;;;MACA,KAAKC,iBAAL,CAAuBH,IAAvB,GAA8BA,IAA9B;MACA,KAAKG,iBAAL,CAAuBF,IAAvB,GAA8BA,IAA9B;MACA,KAAKE,iBAAL,CAAuBD,eAAvB,GAAyCA,eAAzC,CAhC6C,CAkC7C;;MACA,KAAKE,sBAAL;MACA,KAAKC,0BAAL;MACA,KAAKhB,aAAL,GAAqB,IAArB;MAEA,OAAO,KAAKC,UAAL,EAAP;IACD;EAzKH;IAAA;IAAA,OA2KU,yBAAa;MACnB,4BAAyCtB,4DAAA,CAA8B,KAAK/E,UAAnC,CAAzC;MAAA,IAAQkB,YAAR,yBAAQA,YAAR;MAAA,IAAsBH,cAAtB,yBAAsBA,cAAtB;;MACA,KAAKG,YAAL,GAAoBA,YAApB;MACA,KAAKH,cAAL,GAAsBA,cAAtB;MACA,KAAKsG,MAAL,GAActC,gEAAA,CAAkC,KAAK/E,UAAvC,CAAd;IACD;EAhLH;IAAA;IAAA,OAkLU,yBAAgBuF,CAAhB,EAA0B;MAChC,IAAMW,UAAU,GAAG,KAAKA,UAAxB;MACA,IAAMC,YAAY,GAAG,KAAKA,YAA1B;MACA,IAAMhL,IAAI,GAAG,CAACoK,CAAC,CAAClQ,MAAH,EAAWkQ,CAAC,CAAClQ,MAAb,CAAb;MACA,IAAMsR,WAAW,GAAG,IAAI1J,iDAAJ,CAAwB,EAAxB,EAA4B,EAA5B,EAAgC,EAAhC,EAAoC9B,IAApC,CAApB;;MACA,KAAK,IAAI/F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8Q,UAAU,CAAC7Q,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;QAC1C,IAAMkS,GAAG,GAAGpB,UAAU,CAAC9Q,CAAD,CAAtB;QACA,IAAMmS,SAAS,GAAGpB,YAAY,CAAC/Q,CAAD,CAA9B;;QACA,KAAK,IAAI2C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuP,GAAG,CAACjS,MAAxB,EAAgC0C,CAAC,EAAjC,EAAqC;UACnC,IAAMyP,QAAQ,GAAGF,GAAG,CAACvP,CAAD,CAApB;UACA,IAAMlC,QAAQ,GAAG0R,SAAS,CAACxP,CAAD,CAA1B;;UACA,IAAIlC,QAAQ,GAAG,CAAf,EAAkB;YAChB8Q,WAAW,CAAC9K,GAAZ,CAAgBzG,CAAhB,EAAmBoS,QAAnB,EAA6B3R,QAA7B;UACD;QACF;MACF;;MAED,IAAMmH,SAAS,GAAGC,8CAAA,CAAiB0J,WAAjB,CAAlB;MACA,OAAO1J,4CAAA,CAAe0J,WAAf,EAA4B3J,SAA5B,CAAP;IACD;IAED;;;;EAvMF;IAAA;IAAA,OA0ME,mBAAUyK,WAAV,EAA8B;MAAA;;MAC5B;MACA,IAAMC,OAAO,GAAG,KAAKnC,CAArB;;MACA,IAAImC,OAAO,KAAKpC,SAAZ,IAAyBoC,OAAO,CAACrS,MAAR,KAAmB,CAAhD,EAAmD;QACjD,MAAM,IAAIgG,KAAJ,CAAU,uBAAV,CAAN;MACD;;MAED,IAAIjC,UAAU,GAAG7D,IAAI,CAACiD,KAAL,CAAW,KAAKY,UAAL,GAAkB,KAAKuO,kBAAlC,CAAjB;MACAvO,UAAU,GAAG7D,IAAI,CAACqS,GAAL,CAASF,OAAO,CAACrS,MAAjB,EAAyB+D,UAAzB,CAAb;MACA,IAAMyO,IAAI,GAAG9C,yDAAA,CAA2B,KAAKJ,QAAhC,EAA0C+C,OAA1C,EAAmDD,WAAnD,EAAgErO,UAAhE,EAA4E,KAAK2H,cAAjF,EAAiG,KAAKG,YAAtG,EAAoH,KAAKtJ,MAAzH,CAAb;MAEA,IAAMzC,MAAM,GAAG,KAAKkS,MAAL,CAAYK,OAAZ,EAAqB,KAAKf,WAA1B,EAAuCkB,IAAvC,EAA6CJ,WAA7C,CAAf;;MAEA,uBAAsCnQ,6CAAA,CAAgBnC,MAAhB,CAAtC;MAAA,IAAMsD,OAAN,oBAAMA,OAAN;MAAA,IAAwB8O,SAAxB,oBAAe7O,OAAf;;MAEAD,OAAO,GAAGA,OAAO,CAACrB,GAAR,CAAY,UAACnC,CAAD;QAAA,OAAOA,CAAC,CAAC2M,KAAF,CAAQ,CAAR,EAAW,MAAI,CAACxI,UAAhB,CAAP;MAAA,CAAZ,CAAV;MACAmO,SAAS,GAAGA,SAAS,CAACnQ,GAAV,CAAc,UAACnC,CAAD;QAAA,OAAOA,CAAC,CAAC2M,KAAF,CAAQ,CAAR,EAAW,MAAI,CAACxI,UAAhB,CAAP;MAAA,CAAd,CAAZ;MAEA,IAAM0O,yBAAyB,GAAGvS,IAAI,CAACwJ,GAAL,CAAS,CAAT,EAAY,KAAKgJ,iBAAL,GAAyB,CAArC,CAAlC;;MACA,4BAAyB,KAAKC,iBAAL,CAAuBT,SAAvB,EAAkC,KAAKnO,UAAvC,EAAmD0O,yBAAnD,CAAzB;MAAA,IAAQG,MAAR,yBAAQA,MAAR;MAAA,IAAgBC,IAAhB,yBAAgBA,IAAhB;;MAEA,4BAA6B,KAAKC,0BAAL,CAAgC1P,OAAhC,EAAyC8O,SAAzC,EAAoDU,MAApD,EAA4DC,IAA5D,CAA7B;MAAA,IAAQlN,IAAR,yBAAQA,IAAR;MAAA,IAAcC,IAAd,yBAAcA,IAAd;MAAA,IAAoB2B,IAApB,yBAAoBA,IAApB;;MAEA,IAAM5F,IAAI,GAAG,CAACyQ,WAAW,CAACpS,MAAb,EAAqBqS,OAAO,CAACrS,MAA7B,CAAb;MACA,IAAIkM,KAAK,GAAG,IAAItE,iDAAJ,CAAwBjC,IAAxB,EAA8BC,IAA9B,EAAoC2B,IAApC,EAA0C5F,IAA1C,CAAZ,CAxB4B,CA0B5B;MACA;MACA;;MAEA,IAAMoR,MAAM,GAAGnL,8CAAA,CAAiBsE,KAAjB,EAAsB;MAAA;MAAtB,CAAf;MAEA,IAAM8G,SAAS,GAAGpL,2CAAA,CAAcmL,MAAd,CAAlB;MACA,IAAMrR,OAAO,GAAG0Q,WAAW,CAACpS,MAA5B;MAEA,IAAMiT,QAAQ,GAAGzR,6CAAA,CAAgBwR,SAAS,CAAC5P,OAA1B,EAAmC1B,OAAnC,EAA4C,KAAKqC,UAAjD,CAAjB;MAEA,IAAMoP,QAAQ,GAAG3R,6CAAA,CAAgBwR,SAAS,CAACnN,MAA1B,EAAkCnE,OAAlC,EAA2C,KAAKqC,UAAhD,CAAjB;MAEA,IAAMuM,SAAS,GAAG8C,aAAa,CAACH,QAAD,EAAWE,QAAX,EAAqB,KAAK7C,SAA1B,CAA/B;MAEA,IAAM+C,OAAO,GAAG,KAAKA,OAAL,GAAe,KAAKA,OAAL,GAAe,CAA9B,GAAkCnH,KAAK,CAACjG,KAAN,IAAe,KAAf,GAAuB,GAAvB,GAA6B,EAA/E;MAEA,IAAMqN,QAAQ,GAAGpH,KAAK,CAACzD,SAAN,GAAkB8K,MAAlB,CAAyB,UAAC7J,GAAD,EAAM8J,GAAN;QAAA,OAAeA,GAAG,GAAG9J,GAAN,GAAY8J,GAAZ,GAAkB9J,GAAjC;MAAA,CAAzB,EAAgE,CAAhE,CAAjB;MACAwC,KAAK,GAAGA,KAAK,CAACnK,GAAN,CAAU,UAAC0E,KAAD;QAAA,OAAYA,KAAK,GAAG6M,QAAQ,GAAGD,OAAnB,GAA6B,CAA7B,GAAiC5M,KAA7C;MAAA,CAAV,CAAR;MACAyF,KAAK,GAAGtE,mDAAA,CAAsBsE,KAAtB,CAAR;MAEA,IAAM0F,eAAe,GAAG,KAAK6B,mBAAL,CAAyBvH,KAAK,CAACzD,SAAN,EAAzB,EAA4C4K,OAA5C,CAAxB;MACA,IAAM3B,IAAI,GAAGxF,KAAK,CAAC1E,OAAN,EAAb;MACA,IAAMmK,IAAI,GAAGzF,KAAK,CAACzE,OAAN,EAAb,CAjD4B,CAmD5B;;MACA,KAAKiM,iCAAL,CAAuC;QACrCC,aAAa,EAAErD,SADsB;QAErCsD,aAAa,EAAE,KAAKtD,SAFiB;QAGrCoB,IAAI,EAAJA,IAHqC;QAIrCC,IAAI,EAAJA,IAJqC;QAKrCkC,YAAY,EAAE,CALuB;QAMrCR,OAAO,EAAPA,OANqC;QAOrCvP,SAAS,EAAEoI,KAAK,CAAClD,OAAN,GAAgB,CAAhB,CAP0B;QAQrC4I,eAAe,EAAfA;MARqC,CAAvC;MAUA,KAAKG,0BAAL;MAEA,OAAO,KAAK1B,cAAL,EAAP;IACD;IAED;;;;;EA7QF;IAAA;IAAA,OAiRU,+CAAmC;MACzC,IAAQI,CAAR,GAAiB,IAAjB,CAAQA,CAAR;MAAA,IAAWP,CAAX,GAAiB,IAAjB,CAAWA,CAAX;;MACA,IAAIO,CAAJ,EAAO;QACL,IAAIA,CAAC,CAACzQ,MAAF,KAAakQ,CAAC,CAAClQ,MAAnB,EAA2B;UACzB,MAAM,IAAIgG,KAAJ,CAAU,iCAAV,CAAN;QACD;;QAED,IAAI,KAAK0K,YAAL,KAAiB;QAAA;QAArB,EAAoD;UAClD,IAAMoD,EAAE,GAAG,KAAKnD,YAAL,GAAoB,GAA/B;UACA,IAAMoD,OAAO,GAAGD,EAAE,GAAG,OAAO,OAAO,MAAM,KAAKnD,YAAlB,CAAP,CAAH,GAA6C,MAA/D;UACA,KAAKzE,KAAL,GAAa,KAAK8H,oCAAL,CAA0C,KAAK9H,KAA/C,EAAsDuE,CAAtD,EAAyDsD,OAAzD,CAAb;QACD,CATI,CAUL;;MACD;IACF;IAED;;;;EAjSF;IAAA;IAAA,OAoSE,gBAAI;MACF,IAAQF,YAAR,GAAyB,KAAKhC,iBAA9B,CAAQgC,YAAR;;MAEA,IAAIA,YAAY,GAAG,KAAK7C,UAAL,EAAnB,EAAsC;QACpC,KAAKiD,kBAAL,CAAwBJ,YAAxB;MACD;;MACD,OAAO,KAAKhC,iBAAL,CAAuBgC,YAA9B;IACD;IAED;;;;EA7SF;IAAA;IAAA,OAgTE,wBAAY;MACV,OAAO,KAAKvD,SAAZ;IACD;IAED;;;;;;EApTF;IAAA;IAAA,OAyTU,0BAAiBJ,CAAjB,EAA2B;MACjC,IAAQvF,UAAR,GAAmC,IAAnC,CAAQA,UAAR;MAAA,IAAoB5G,UAApB,GAAmC,IAAnC,CAAoBA,UAApB;;MACA,IAAMmQ,IAAI,GAAG,SAAPA,IAAO,CAAChJ,CAAD;QAAA,OAAehL,IAAI,CAACiU,GAAL,CAASjJ,CAAT,IAAchL,IAAI,CAACiU,GAAL,CAAS,CAAT,CAA7B;MAAA,CAAb;;MACA,IAAMC,eAAe,GAAG1E,sDAAA,CAAwB/E,UAAxB,EAAoC,KAAKpI,MAAzC,CAAxB,CAHiC,CAKjC;;MACA,IAAM8R,KAAK,GAAG,SAARA,KAAQ,CAACnJ,CAAD,EAAc;QAC1B,OAAOA,CAAC,KAAK,GAAN,GAAY,CAAZ,GAAgBhL,IAAI,CAACmU,KAAL,CAAWnJ,CAAX,CAAvB;MACD,CAFD;;MAIA,IAAM+B,MAAM,GAAG,IAAI/M,IAAI,CAACiD,KAAL,CAAWkR,KAAK,CAAC,UAAC,CAACrU,MAAF,EAAY,GAAZ,IAAkB,IAAnB,CAAhB,CAAnB;MACA,IAAM8K,MAAM,GAAG5K,IAAI,CAACwJ,GAAL,CAAS,CAAT,EAAYxJ,IAAI,CAACiD,KAAL,CAAWjD,IAAI,CAACmU,KAAL,CAAWH,IAAI,CAAChE,CAAC,CAAClQ,MAAH,CAAf,CAAX,CAAZ,CAAf;MAEA,KAAKsP,QAAL,GAAgB7E,6CAAA,CAAgByF,CAAhB,EAAmBnM,UAAnB,EAA+BkJ,MAA/B,EAAuC,KAAK1K,MAA5C,CAAhB;MAEA,IAAMsI,SAAS,GAAGJ,gDAAA,CAAmB,KAAK6E,QAAxB,CAAlB;;MACA,uBAA6B8E,eAAe,CAAClE,CAAD,EAAIrF,SAAJ,EAAe9G,UAAf,EAA2B+G,MAA3B,CAA5C;MAAA,IAAQ1H,OAAR,oBAAQA,OAAR;MAAA,IAAiBC,OAAjB,oBAAiBA,OAAjB;;MACA,OAAO;QAAEwN,UAAU,EAAEzN,OAAd;QAAuB0N,YAAY,EAAEzN;MAArC,CAAP;IACD;IAED;;;;;;;;;EA7UF;IAAA;IAAA,OAqVU,4BAAmB6M,CAAnB,EAA+BnM,UAA/B,EAAsE;MAAA,IAAnBqN,aAAmB,uEAAH,GAAG;MAC5E,uBAAkE,IAAlE,CAAQP,UAAR;MAAA,IAAQA,UAAR,iCAAqB,EAArB;MAAA,yBAAkE,IAAlE,CAAyBC,YAAzB;MAAA,IAAyBA,YAAzB,mCAAwC,EAAxC;MAAA,IAA4C4B,iBAA5C,GAAkE,IAAlE,CAA4CA,iBAA5C;;MAEA,6BAAyB,KAAKC,iBAAL,CAAuB7B,YAAvB,EAAqC/M,UAArC,EAAiD2O,iBAAjD,CAAzB;MAAA,IAAQE,MAAR,0BAAQA,MAAR;MAAA,IAAgBC,IAAhB,0BAAgBA,IAAhB;;MAEA,6BAA6B,KAAKC,0BAAL,CAAgCjC,UAAhC,EAA4CC,YAA5C,EAA0D8B,MAA1D,EAAkEC,IAAlE,CAA7B;MAAA,IAAQlN,IAAR,0BAAQA,IAAR;MAAA,IAAcC,IAAd,0BAAcA,IAAd;MAAA,IAAoB2B,IAApB,0BAAoBA,IAApB;;MAEA,IAAM5F,IAAI,GAAG,CAACuO,CAAC,CAAClQ,MAAH,EAAWkQ,CAAC,CAAClQ,MAAb,CAAb;MACA,IAAMsU,YAAY,GAAG,IAAI1M,iDAAJ,CAAwBjC,IAAxB,EAA8BC,IAA9B,EAAoC2B,IAApC,EAA0C5F,IAA1C,CAArB;MAEA,IAAMgG,SAAS,GAAGC,8CAAA,CAAiB0M,YAAjB,CAAlB;MACA,IAAMC,UAAU,GAAG3M,qDAAA,CAAwB0M,YAAxB,EAAsC3M,SAAtC,CAAnB;MAEA,IAAMT,CAAC,GAAGU,6CAAA,CAAgBA,wCAAA,CAAW0M,YAAX,EAAyB3M,SAAzB,CAAhB,EAAqD4M,UAArD,CAAV;MACA,IAAMpN,CAAC,GAAGS,mDAAA,CAAsBV,CAAtB,EAAyBkK,aAAzB,CAAV;MACA,IAAMjG,CAAC,GAAGvD,mDAAA,CAAsB2M,UAAtB,EAAkC,MAAMnD,aAAxC,CAAV;MACA,IAAMtR,MAAM,GAAG8H,wCAAA,CAAWT,CAAX,EAAcgE,CAAd,CAAf;MAEA,OAAOrL,MAAP;IACD;IAED;;;;;;;EA1WF;IAAA;IAAA,OAgXU,8CAAqC0U,aAArC,EAAyEC,MAAzE,EAA2FV,OAA3F,EAA6H;MAAA,IAAjBW,WAAiB,uEAAH,GAAG;MACnI,IAAIC,YAAY,GAAGC,gBAAgB,CAACJ,aAAD,EAAgBC,MAAhB,EAAwBC,WAAxB,EAAqCX,OAArC,CAAnC;MACAY,YAAY,GAAG/M,mDAAA,CAAsB+M,YAAtB,CAAf;MACA,OAAOE,sBAAsB,CAACF,YAAD,CAA7B;IACD;IAED;;;;;;;;EAtXF;IAAA;IAAA,OA6XU,2BAAkBzC,SAAlB,EAAsCrP,CAAtC,EAAqG;MAAA,IAApD6P,iBAAoD,uEAAhC,GAAgC;MAAA,IAA3BoC,KAA2B,uEAAnB,EAAmB;MAAA,IAAfC,SAAe,uEAAH,GAAG;MAC3G,IAAMN,MAAM,GAAIvU,IAAI,CAACiU,GAAL,CAAStR,CAAT,IAAc3C,IAAI,CAACiU,GAAL,CAAS,CAAT,CAAf,GAA8BY,SAA7C;MACA,IAAM/J,GAAG,GAAGxJ,yCAAA,CAAY0Q,SAAS,CAAClS,MAAtB,CAAZ;MACA,IAAMF,MAAM,GAAG0B,yCAAA,CAAY0Q,SAAS,CAAClS,MAAtB,CAAf;;MAEA,KAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmS,SAAS,CAAClS,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;QACzC,IAAIiV,EAAE,GAAG,GAAT;QACA,IAAIC,EAAE,GAAG9S,QAAT;QACA,IAAI+S,GAAG,GAAG,GAAV,CAHyC,CAKzC;;QACA,IAAMC,YAAY,GAAGjD,SAAS,CAACnS,CAAD,CAA9B;QACA,IAAMqV,YAAY,GAAGD,YAAY,CAACtM,MAAb,CAAoB,UAACzE,CAAD;UAAA,OAAOA,CAAC,GAAG,GAAX;QAAA,CAApB,CAArB;;QAEA,IAAIgR,YAAY,CAACpV,MAAb,IAAuB0S,iBAA3B,EAA8C;UAC5C,IAAMzP,KAAK,GAAG/C,IAAI,CAACiD,KAAL,CAAWuP,iBAAX,CAAd;UACA,IAAM2C,aAAa,GAAG3C,iBAAiB,GAAGzP,KAA1C;;UACA,IAAIA,KAAK,GAAG,CAAZ,EAAe;YACb+H,GAAG,CAACjL,CAAD,CAAH,GAASqV,YAAY,CAACnS,KAAK,GAAG,CAAT,CAArB;;YACA,IAAIoS,aAAa,GAAG1F,kBAApB,EAAwC;cACtC3E,GAAG,CAACjL,CAAD,CAAH,IAAUsV,aAAa,IAAID,YAAY,CAACnS,KAAD,CAAZ,GAAsBmS,YAAY,CAACnS,KAAK,GAAG,CAAT,CAAtC,CAAvB;YACD;UACF,CALD,MAKO;YACL+H,GAAG,CAACjL,CAAD,CAAH,GAASsV,aAAa,GAAGD,YAAY,CAAC,CAAD,CAArC;UACD;QACF,CAXD,MAWO,IAAIA,YAAY,CAACpV,MAAb,GAAsB,CAA1B,EAA6B;UAClCgL,GAAG,CAACjL,CAAD,CAAH,GAASyB,uCAAA,CAAU4T,YAAV,CAAT;QACD;;QAED,KAAK,IAAIlK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4J,KAApB,EAA2B5J,CAAC,EAA5B,EAAgC;UAC9B,IAAIoK,IAAI,GAAG,GAAX;;UACA,KAAK,IAAI5S,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwP,SAAS,CAACnS,CAAD,CAAT,CAAaC,MAAjC,EAAyC0C,CAAC,EAA1C,EAA8C;YAC5C,IAAM0B,CAAC,GAAG8N,SAAS,CAACnS,CAAD,CAAT,CAAa2C,CAAb,IAAkBsI,GAAG,CAACjL,CAAD,CAA/B;;YACA,IAAIqE,CAAC,GAAG,CAAR,EAAW;cACTkR,IAAI,IAAIpV,IAAI,CAACqV,GAAL,CAAS,EAAEnR,CAAC,GAAG8Q,GAAN,CAAT,CAAR;YACD,CAFD,MAEO;cACLI,IAAI,IAAI,GAAR;YACD;UACF;;UAED,IAAIpV,IAAI,CAACC,GAAL,CAASmV,IAAI,GAAGb,MAAhB,IAA0B9E,kBAA9B,EAAkD;YAChD;UACD;;UAED,IAAI2F,IAAI,GAAGb,MAAX,EAAmB;YACjBQ,EAAE,GAAGC,GAAL;YACAA,GAAG,GAAG,CAACF,EAAE,GAAGC,EAAN,IAAY,GAAlB;UACD,CAHD,MAGO;YACLD,EAAE,GAAGE,GAAL;;YACA,IAAID,EAAE,KAAK9S,QAAX,EAAqB;cACnB+S,GAAG,IAAI,CAAP;YACD,CAFD,MAEO;cACLA,GAAG,GAAG,CAACF,EAAE,GAAGC,EAAN,IAAY,GAAlB;YACD;UACF;QACF;;QAEDnV,MAAM,CAACC,CAAD,CAAN,GAAYmV,GAAZ,CApDyC,CAsDzC;;QACA,IAAIlK,GAAG,CAACjL,CAAD,CAAH,GAAS,GAAb,EAAkB;UAChB,IAAMyV,gBAAgB,GAAGhU,wCAAA,CAAW2T,YAAX,CAAzB;;UACA,IAAIrV,MAAM,CAACC,CAAD,CAAN,GAAY6P,gBAAgB,GAAG4F,gBAAnC,EAAqD;YACnD1V,MAAM,CAACC,CAAD,CAAN,GAAY6P,gBAAgB,GAAG4F,gBAA/B;UACD;QACF,CALD,MAKO;UACL,IAAME,aAAa,GAAGlU,wCAAA,CAAW0Q,SAAS,CAACnQ,GAAV,CAAcP,wCAAd,CAAX,CAAtB;;UACA,IAAI1B,MAAM,CAACC,CAAD,CAAN,GAAY6P,gBAAgB,GAAG8F,aAAnC,EAAkD;YAChD5V,MAAM,CAACC,CAAD,CAAN,GAAY6P,gBAAgB,GAAG8F,aAA/B;UACD;QACF;MACF;;MAED,OAAO;QAAE9C,MAAM,EAAE9S,MAAV;QAAkB+S,IAAI,EAAE7H;MAAxB,CAAP;IACD;IAED;;;;;;;EAzcF;IAAA;IAAA,OA+cU,oCACN6F,UADM,EAENC,YAFM,EAGN8B,MAHM,EAINC,IAJM,EAIQ;MAEd,IAAMxQ,QAAQ,GAAGwO,UAAU,CAAC7Q,MAA5B;MACA,IAAM+D,UAAU,GAAG8M,UAAU,CAAC,CAAD,CAAV,CAAc7Q,MAAjC;MAEA,IAAM2F,IAAI,GAAGnE,yCAAA,CAAYa,QAAQ,GAAG0B,UAAvB,CAAb;MACA,IAAM6B,IAAI,GAAGpE,yCAAA,CAAYa,QAAQ,GAAG0B,UAAvB,CAAb;MACA,IAAMwD,IAAI,GAAG/F,yCAAA,CAAYa,QAAQ,GAAG0B,UAAvB,CAAb;;MAEA,KAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,QAApB,EAA8BtC,CAAC,EAA/B,EAAmC;QACjC,KAAK,IAAI2C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,UAApB,EAAgCrB,CAAC,EAAjC,EAAqC;UACnC,IAAI8Q,GAAG,GAAG,CAAV;;UACA,IAAI3C,UAAU,CAAC9Q,CAAD,CAAV,CAAc2C,CAAd,MAAqB,CAAC,CAA1B,EAA6B;YAC3B,SAD2B,CACjB;UACX;;UACD,IAAImO,UAAU,CAAC9Q,CAAD,CAAV,CAAc2C,CAAd,MAAqB3C,CAAzB,EAA4B;YAC1ByT,GAAG,GAAG,GAAN;UACD,CAFD,MAEO,IAAI1C,YAAY,CAAC/Q,CAAD,CAAZ,CAAgB2C,CAAhB,IAAqBmQ,IAAI,CAAC9S,CAAD,CAAzB,IAAgC,GAApC,EAAyC;YAC9CyT,GAAG,GAAG,GAAN;UACD,CAFM,MAEA;YACLA,GAAG,GAAGtT,IAAI,CAACqV,GAAL,CAAS,EAAE,CAACzE,YAAY,CAAC/Q,CAAD,CAAZ,CAAgB2C,CAAhB,IAAqBmQ,IAAI,CAAC9S,CAAD,CAA1B,IAAiC6S,MAAM,CAAC7S,CAAD,CAAzC,CAAT,CAAN;UACD;;UAED4F,IAAI,CAAC5F,CAAC,GAAGgE,UAAJ,GAAiBrB,CAAlB,CAAJ,GAA2B3C,CAA3B;UACA6F,IAAI,CAAC7F,CAAC,GAAGgE,UAAJ,GAAiBrB,CAAlB,CAAJ,GAA2BmO,UAAU,CAAC9Q,CAAD,CAAV,CAAc2C,CAAd,CAA3B;UACA6E,IAAI,CAACxH,CAAC,GAAGgE,UAAJ,GAAiBrB,CAAlB,CAAJ,GAA2B8Q,GAA3B;QACD;MACF;;MAED,OAAO;QAAE7N,IAAI,EAAJA,IAAF;QAAQC,IAAI,EAAJA,IAAR;QAAc2B,IAAI,EAAJA;MAAd,CAAP;IACD;IAED;;;;;;;EAnfF;IAAA;IAAA,OAyfU,0CAAiC4I,gBAAjC,EAAsD;MAAA;;MAC5D,IAAMkD,OAAO,GAAG,KAAKrC,UAAL,EAAhB;MAEA,IAAQ2E,WAAR,GAAwB,IAAxB,CAAQA,WAAR;MACA,IAAMC,WAAW,GAAG,KAAK1J,KAAL,CAAWzD,SAAX,EAApB;MACA,IAAI6K,QAAQ,GAAG,CAAf;;MACA,KAAK,IAAIvT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6V,WAAW,CAAC5V,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;QAC3C,IAAM0G,KAAK,GAAGmP,WAAW,CAAC7V,CAAD,CAAzB;;QACA,IAAIuT,QAAQ,GAAGsC,WAAW,CAAC7V,CAAD,CAA1B,EAA+B;UAC7BuT,QAAQ,GAAG7M,KAAX;QACD;MACF;;MAED,IAAMyF,KAAK,GAAG,KAAKA,KAAL,CAAWnK,GAAX,CAAe,UAAC0E,KAAD,EAAU;QACrC,IAAIA,KAAK,GAAG6M,QAAQ,GAAGD,OAAvB,EAAgC;UAC9B,OAAO,CAAP;QACD;;QACD,OAAO5M,KAAP;MACD,CALa,CAAd,CAb4D,CAoB5D;MACA;MACA;;MACA,IAAI0J,gBAAJ,EAAsB;QACpB,KAAKG,SAAL,GAAiBH,gBAAjB;MACD,CAFD,MAEO;QACL,KAAKG,SAAL,GAAiB9O,yCAAA,CAAY0K,KAAK,CAACjG,KAAlB,EAAyBlE,GAAzB,CAA6B,YAAK;UACjD,OAAOP,yCAAA,CAAYmU,WAAZ,EAAyB5T,GAAzB,CAA6B,YAAK;YACvC,OAAOP,2CAAA,CAAc,MAAI,CAACe,MAAnB,IAA6B,EAA7B,GAAkC,CAAC,EAA1C,CADuC,CACO;UAC/C,CAFM,CAAP;QAGD,CAJgB,CAAjB;MAKD,CA/B2D,CAiC5D;;;MACA,IAAMc,OAAO,GAAa,EAA1B;MACA,IAAMqO,IAAI,GAAa,EAAvB;MACA,IAAMC,IAAI,GAAa,EAAvB;MACA,IAAM5K,YAAY,GAAGmF,KAAK,CAAC2J,MAAN,EAArB;;MACA,KAAK,IAAI9V,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGgH,YAAY,CAAC/G,MAAjC,EAAyCD,EAAC,EAA1C,EAA8C;QAC5C,IAAM+V,KAAK,GAAG/O,YAAY,CAAChH,EAAD,CAA1B;;QACA,IAAI+V,KAAK,CAACrP,KAAV,EAAiB;UACfpD,OAAO,CAACnB,IAAR,CAAa4T,KAAK,CAACrP,KAAnB;UACAkL,IAAI,CAACzP,IAAL,CAAU4T,KAAK,CAAC/S,GAAhB;UACA2O,IAAI,CAACxP,IAAL,CAAU4T,KAAK,CAAC3P,GAAhB;QACD;MACF;;MACD,IAAMyL,eAAe,GAAG,KAAK6B,mBAAL,CAAyBpQ,OAAzB,EAAkCgQ,OAAlC,CAAxB;MAEA,OAAO;QAAE3B,IAAI,EAAJA,IAAF;QAAQC,IAAI,EAAJA,IAAR;QAAcC,eAAe,EAAfA;MAAd,CAAP;IACD;IAED;;;;;EA5iBF;IAAA;IAAA,OAgjBU,6BAAoBvO,OAApB,EAAuCgQ,OAAvC,EAAsD;MAC5D,IAAMvT,MAAM,GAAG0B,0CAAA,CAAa6B,OAAO,CAACrD,MAArB,EAA6B,CAAC,GAA9B,CAAf;MACA,IAAM0J,GAAG,GAAGlI,uCAAA,CAAU6B,OAAV,CAAZ;MACA,IAAMhB,QAAQ,GAAGgB,OAAO,CAACtB,GAAR,CAAY,UAACgU,CAAD;QAAA,OAAQA,CAAC,GAAGrM,GAAL,GAAY2J,OAAnB;MAAA,CAAZ,CAAjB;MACAhR,QAAQ,CAAC2E,OAAT,CAAiB,UAACkE,CAAD,EAAInL,CAAJ,EAAS;QACxB,IAAImL,CAAC,GAAG,CAAR,EAAWpL,MAAM,CAACC,CAAD,CAAN,GAAYsT,OAAO,GAAGhR,QAAQ,CAACtC,CAAD,CAA9B;MACZ,CAFD;MAGA,OAAOD,MAAP;IACD;IAED;;;;EA1jBF;IAAA;IAAA,OA6jBU,2CAAkCkW,KAAlC,EAAmE;MACzEC,MAAM,CAACC,MAAP,CAAc,KAAKrE,iBAAnB,EAAsCmE,KAAtC;IACD;IAED;;;;;EAjkBF;IAAA;IAAA,OAqkBU,sCAA0B;MAChC;MACA,IAAQG,iBAAR,GAAgE,IAAhE,CAAQA,iBAAR;MAAA,IAA2BC,YAA3B,GAAgE,IAAhE,CAA2BA,YAA3B;MAAA,IAAyCC,kBAAzC,GAAgE,IAAhE,CAAyCA,kBAAzC;MAEA,4BAA0D,KAAKxE,iBAA/D;MAAA,IAAQD,eAAR,yBAAQA,eAAR;MAAA,IAAyB+B,aAAzB,yBAAyBA,aAAzB;MAAA,IAAwCC,aAAxC,yBAAwCA,aAAxC;MAEA,IAAM5F,GAAG,GAAG2F,aAAa,CAAC,CAAD,CAAb,CAAiB3T,MAA7B;MACA,IAAMsW,SAAS,GAAG3C,aAAa,CAAC3T,MAAd,KAAyB4T,aAAa,CAAC5T,MAAzD;MAEA,IAAMuW,uBAAuB,GAAG3E,eAAe,CAAC7P,GAAhB,CAAoB,UAACd,CAAD;QAAA,OAAOA,CAAC,GAAGoV,kBAAX;MAAA,CAApB,CAAhC;;MACA,IAAMG,yBAAyB,sBAAOD,uBAAP,CAA/B;;MACA,IAAME,iBAAiB,sBAAO7E,eAAP,CAAvB;;MAEA,KAAK8B,iCAAL,CAAuC;QACrC+C,iBAAiB,EAAjBA,iBADqC;QAErCD,yBAAyB,EAAzBA,yBAFqC;QAGrCD,uBAAuB,EAAvBA,uBAHqC;QAIrCD,SAAS,EAATA,SAJqC;QAKrCI,YAAY,EAAEN,YALuB;QAMrCO,KAAK,EAAEP,YAN8B;QAOrCQ,KAAK,EAAET,iBAP8B;QAQrCnI,GAAG,EAAHA;MARqC,CAAvC;IAUD;IAED;;;;EA9lBF;IAAA;IAAA,OAimBU,kCAAsB;MAC5B;MACA,IAAM2F,aAAa,GAAG,KAAKrD,SAA3B;MACA,IAAMsD,aAAa,GAAG,KAAKtD,SAA3B,CAH4B,CAK5B;;MACA,6BAAwC,KAAKuB,iBAA7C;MAAA,IAAQH,IAAR,0BAAQA,IAAR;MAAA,IAAcC,IAAd,0BAAcA,IAAd;MAAA,IAAoBC,eAApB,0BAAoBA,eAApB;MAEA,IAAMyB,OAAO,GAAG,KAAKrC,UAAL,EAAhB;MACA,IAAMlN,SAAS,GAAG,KAAKoI,KAAL,CAAWhG,KAA7B;;MAEA,oBAAiB2Q,YAAY,CAAC,KAAKC,MAAN,EAAc,KAAKtR,OAAnB,CAA7B;MAAA,IAAQ0B,CAAR,iBAAQA,CAAR;MAAA,IAAWC,CAAX,iBAAWA,CAAX;;MAEA,KAAKuM,iCAAL,CAAuC;QACrCC,aAAa,EAAbA,aADqC;QAErCC,aAAa,EAAbA,aAFqC;QAGrClC,IAAI,EAAJA,IAHqC;QAIrCC,IAAI,EAAJA,IAJqC;QAKrCC,eAAe,EAAfA,eALqC;QAMrC1K,CAAC,EAADA,CANqC;QAOrCC,CAAC,EAADA,CAPqC;QAQrCkM,OAAO,EAAPA,OARqC;QASrCvP,SAAS,EAATA;MATqC,CAAvC;IAWD;IAED;;;;;;;;EA3nBF;IAAA;IAAA,OAkoBU,4BAAmBoH,CAAnB,EAA4B;MAClC,IAAQ2G,iBAAR,GAA8B,IAA9B,CAAQA,iBAAR;MACA,IACEH,IADF,GAkBIG,iBAlBJ,CACEH,IADF;MAAA,IAEEC,IAFF,GAkBIE,iBAlBJ,CAEEF,IAFF;MAAA,IAGEgC,aAHF,GAkBI9B,iBAlBJ,CAGE8B,aAHF;MAAA,IAIEC,aAJF,GAkBI/B,iBAlBJ,CAIE+B,aAJF;MAAA,IAKEhC,eALF,GAkBIC,iBAlBJ,CAKED,eALF;MAAA,IAME6E,iBANF,GAkBI5E,iBAlBJ,CAME4E,iBANF;MAAA,IAOED,yBAPF,GAkBI3E,iBAlBJ,CAOE2E,yBAPF;MAAA,IAQED,uBARF,GAkBI1E,iBAlBJ,CAQE0E,uBARF;MAAA,IASED,SATF,GAkBIzE,iBAlBJ,CASEyE,SATF;MAAA,IAUEI,YAVF,GAkBI7E,iBAlBJ,CAUE6E,YAVF;MAAA,IAWEC,KAXF,GAkBI9E,iBAlBJ,CAWE8E,KAXF;MAAA,IAYEC,KAZF,GAkBI/E,iBAlBJ,CAYE+E,KAZF;MAAA,IAaE1P,CAbF,GAkBI2K,iBAlBJ,CAaE3K,CAbF;MAAA,IAcEC,CAdF,GAkBI0K,iBAlBJ,CAcE1K,CAdF;MAAA,IAeE6G,GAfF,GAkBI6D,iBAlBJ,CAeE7D,GAfF;MAAA,IAgBEqF,OAhBF,GAkBIxB,iBAlBJ,CAgBEwB,OAhBF;MAAA,IAiBEvP,SAjBF,GAkBI+N,iBAlBJ,CAiBE/N,SAjBF;MAoBA,IAAMiT,SAAS,GAAG,GAAlB;;MAEA,KAAK,IAAIhX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6R,eAAe,CAAC5R,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;QAC/C,IAAI0W,iBAAiB,CAAC1W,CAAD,CAAjB,GAAuBmL,CAA3B,EAA8B;UAC5B;QACD;;QAED,IAAMxI,CAAC,GAAGgP,IAAI,CAAC3R,CAAD,CAAd;QACA,IAAM8C,CAAC,GAAG8O,IAAI,CAAC5R,CAAD,CAAd;QAEA,IAAMiX,OAAO,GAAGrD,aAAa,CAACjR,CAAD,CAA7B;QACA,IAAMuU,KAAK,GAAGrD,aAAa,CAAC/Q,CAAD,CAA3B;QAEA,IAAMqU,WAAW,GAAGC,KAAK,CAACH,OAAD,EAAUC,KAAV,CAAzB;QAEA,IAAIG,SAAS,GAAG,CAAhB;;QACA,IAAIF,WAAW,GAAG,CAAlB,EAAqB;UACnBE,SAAS,GAAG,CAAC,GAAD,GAAOlQ,CAAP,GAAWC,CAAX,YAAe+P,WAAf,EAA+B/P,CAAC,GAAG,GAAnC,CAAZ;UACAiQ,SAAS,IAAIlQ,CAAC,YAAGgQ,WAAH,EAAkB/P,CAAlB,CAAD,GAAuB,GAApC;QACD;;QAED,KAAK,IAAI/C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4J,GAApB,EAAyB5J,CAAC,EAA1B,EAA8B;UAC5B,IAAMiT,KAAK,GAAGC,IAAI,CAACF,SAAS,IAAIJ,OAAO,CAAC5S,CAAD,CAAP,GAAa6S,KAAK,CAAC7S,CAAD,CAAtB,CAAV,EAAsC2S,SAAtC,CAAlB;UACAC,OAAO,CAAC5S,CAAD,CAAP,IAAciT,KAAK,GAAGV,KAAtB;;UACA,IAAIL,SAAJ,EAAe;YACbW,KAAK,CAAC7S,CAAD,CAAL,IAAY,CAACiT,KAAD,GAASV,KAArB;UACD;QACF;;QAEDF,iBAAiB,CAAC1W,CAAD,CAAjB,IAAwB6R,eAAe,CAAC7R,CAAD,CAAvC;QAEA,IAAMwX,WAAW,GAAGrX,IAAI,CAACiD,KAAL,CAAW,CAAC+H,CAAC,GAAGsL,yBAAyB,CAACzW,CAAD,CAA9B,IAAqCwW,uBAAuB,CAACxW,CAAD,CAAvE,CAApB;;QAEA,KAAK,IAAIqL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmM,WAApB,EAAiCnM,CAAC,EAAlC,EAAsC;UACpC,IAAMvI,EAAC,GAAGrB,8CAAA,CAAiBsC,SAAjB,EAA4B,KAAKvB,MAAjC,CAAV;;UACA,IAAM0U,MAAK,GAAGrD,aAAa,CAAC/Q,EAAD,CAA3B;;UAEA,IAAMqU,YAAW,GAAGC,KAAK,CAACH,OAAD,EAAUC,MAAV,CAAzB;;UAEA,IAAIG,UAAS,GAAG,GAAhB;;UACA,IAAIF,YAAW,GAAG,GAAlB,EAAuB;YACrBE,UAAS,GAAG,MAAMR,KAAN,GAAczP,CAA1B;YACAiQ,UAAS,IAAI,CAAC,QAAQF,YAAT,KAAyBhQ,CAAC,YAAGgQ,YAAH,EAAkB/P,CAAlB,CAAD,GAAuB,CAAhD,CAAb;UACD,CAHD,MAGO,IAAIzE,CAAC,KAAKG,EAAV,EAAa;YAClB;UACD;;UAED,KAAK,IAAIuB,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAG4J,GAApB,EAAyB5J,EAAC,EAA1B,EAA8B;YAC5B,IAAIiT,MAAK,GAAG,GAAZ;;YACA,IAAID,UAAS,GAAG,GAAhB,EAAqB;cACnBC,MAAK,GAAGC,IAAI,CAACF,UAAS,IAAIJ,OAAO,CAAC5S,EAAD,CAAP,GAAa6S,MAAK,CAAC7S,EAAD,CAAtB,CAAV,EAAsC2S,SAAtC,CAAZ;YACD;;YACDC,OAAO,CAAC5S,EAAD,CAAP,IAAciT,MAAK,GAAGV,KAAtB;UACD;QACF;;QACDH,yBAAyB,CAACzW,CAAD,CAAzB,IAAgCwX,WAAW,GAAGhB,uBAAuB,CAACxW,CAAD,CAArE;MACD;;MACD8R,iBAAiB,CAAC8E,KAAlB,GAA0BD,YAAY,IAAI,MAAMxL,CAAC,GAAGmI,OAAd,CAAtC;MAEAxB,iBAAiB,CAACgC,YAAlB,IAAkC,CAAlC;MACA,OAAOF,aAAP;IACD;IAED;;;;;;;;EAvtBF;IAAA;IAAA,OA8tBU,+BAAuF;MAAA;;MAAA,IAAnE6D,aAAmE,uEAAV;QAAA,OAAM,IAAN;MAAA,CAAU;MAC7F,OAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAoB;QACrC,IAAMC,IAAI;UAAA,sEAAG;YAAA;;YAAA;cAAA;gBAAA;kBAAA;oBAAA;oBAAA,wBAEyB,MAAI,CAAC/F,iBAF9B,EAEDwB,OAFC,yBAEDA,OAFC,EAEQQ,YAFR,yBAEQA,YAFR;oBAGT,MAAI,CAACvD,SAAL,GAAiB,MAAI,CAAC2D,kBAAL,CAAwBJ,YAAxB,CAAjB;oBACMgE,cAJG,GAIc,MAAI,CAAChG,iBAAL,CAAuBgC,YAJrC;oBAKHiE,UALG,GAKUN,aAAa,CAACK,cAAD,CAAb,KAAkC,KAL5C;oBAMHE,UANG,GAMUF,cAAc,KAAKxE,OAN7B;;oBAAA,MAOL,CAACyE,UAAD,IAAe,CAACC,UAPX;sBAAA;sBAAA;oBAAA;;oBAQPC,UAAU,CAAC;sBAAA,OAAMJ,IAAI,EAAV;oBAAA,CAAD,EAAe,CAAf,CAAV;oBARO;oBAAA;;kBAAA;oBAAA,kCAUAF,OAAO,CAACK,UAAD,CAVP;;kBAAA;oBAAA;oBAAA;;kBAAA;oBAAA;oBAAA;oBAaTJ,MAAM,cAAN;;kBAbS;kBAAA;oBAAA;gBAAA;cAAA;YAAA;UAAA,CAAH;;UAAA,gBAAJC,IAAI;YAAA;UAAA;QAAA,GAAV;;QAgBAI,UAAU,CAAC;UAAA,OAAMJ,IAAI,EAAV;QAAA,CAAD,EAAe,CAAf,CAAV;MACD,CAlBM,CAAP;IAmBD;IAED;;;;;;;;EApvBF;IAAA;IAAA,OA2vBU,0BAAkF;MAAA,IAAnEJ,aAAmE,uEAAV;QAAA,OAAM,IAAN;MAAA,CAAU;MACxF,IAAIO,UAAU,GAAG,KAAjB;MACA,IAAIzH,SAAS,GAAY,EAAzB;;MACA,OAAO,CAACyH,UAAR,EAAoB;QAClB,6BAAkC,KAAKlG,iBAAvC;QAAA,IAAQwB,OAAR,0BAAQA,OAAR;QAAA,IAAiBQ,YAAjB,0BAAiBA,YAAjB;QACAvD,SAAS,GAAG,KAAK2D,kBAAL,CAAwBJ,YAAxB,CAAZ;QACA,IAAMgE,cAAc,GAAG,KAAKhG,iBAAL,CAAuBgC,YAA9C;QACA,IAAMiE,UAAU,GAAGN,aAAa,CAACK,cAAD,CAAb,KAAkC,KAArD;QACAE,UAAU,GAAGF,cAAc,KAAKxE,OAAnB,IAA8ByE,UAA3C;MACD;;MACD,OAAOxH,SAAP;IACD;IAED;;;;;EAxwBF;IAAA;IAAA,OA4wBU,sBAAU;MAChB,IAAQpE,KAAR,GAAkB,IAAlB,CAAQA,KAAR;;MAEA,IAAI,KAAKmH,OAAL,GAAe,CAAnB,EAAsB;QACpB,OAAO,KAAKA,OAAZ;MACD;;MAED,IAAMrT,MAAM,GAAGkM,KAAK,CAACjG,KAArB;;MACA,IAAIjG,MAAM,IAAI,IAAd,EAAoB;QAClB,OAAO,GAAP;MACD;;MACD,IAAIA,MAAM,IAAI,IAAd,EAAoB;QAClB,OAAO,GAAP;MACD;;MACD,IAAIA,MAAM,IAAI,IAAd,EAAoB;QAClB,OAAO,GAAP;MACD;;MACD,OAAO,GAAP;IACD;EA9xBH;;EAAA;AAAA,KAiyBA;;AACM,SAAUO,OAAV,CAAkBX,CAAlB,EAA6BC,CAA7B,EAAsC;EAC1C,OAAON,0CAAA,CAAmBK,CAAnB,EAAsBC,CAAtB,CAAP;AACD;AAEK,SAAUY,SAAV,CAAoBb,CAApB,EAA+BC,CAA/B,EAAwC;EAC5C,IAAIC,MAAM,GAAG,CAAb;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACI,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;IACjCD,MAAM,aAAKF,CAAC,CAACG,CAAD,CAAD,GAAOF,CAAC,CAACE,CAAD,CAAb,EAAqB,CAArB,CAAN;EACD;;EACD,OAAOG,IAAI,CAACQ,IAAL,CAAUZ,MAAV,CAAP;AACD;AAEK,SAAUc,MAAV,CAAiBhB,CAAjB,EAA4BC,CAA5B,EAAqC;EACzC,IAAIC,MAAM,GAAG,GAAb;EACA,IAAIe,KAAK,GAAG,GAAZ;EACA,IAAIC,KAAK,GAAG,GAAZ;;EAEA,KAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACI,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;IACjCD,MAAM,IAAIF,CAAC,CAACG,CAAD,CAAD,GAAOF,CAAC,CAACE,CAAD,CAAlB;IACAc,KAAK,aAAIjB,CAAC,CAACG,CAAD,CAAL,EAAY,CAAZ,CAAL;IACAe,KAAK,aAAIjB,CAAC,CAACE,CAAD,CAAL,EAAY,CAAZ,CAAL;EACD;;EAED,IAAIc,KAAK,KAAK,CAAV,IAAeC,KAAK,KAAK,CAA7B,EAAgC;IAC9B,OAAO,CAAP;EACD;;EACD,IAAID,KAAK,KAAK,CAAV,IAAeC,KAAK,KAAK,CAA7B,EAAgC;IAC9B,OAAO,GAAP;EACD;;EACD,OAAO,MAAMhB,MAAM,GAAGI,IAAI,CAACQ,IAAL,CAAUG,KAAK,GAAGC,KAAlB,CAAtB;AACD;AAED;;;;;IAIMiP,8CAAN;EAAA;;EACE,oBAAe,CAAf,CADF,CAGE;;EACA,qBAA4B,EAA5B;EAEA,qBAA4B,EAA5B;EAEA,YAAiB,EAAjB;EAEA,YAAiB,EAAjB;EAEA,uBAA4B,EAA5B;EAEA,yBAA8B,EAA9B;EAEA,iCAAsC,EAAtC;EAEA,+BAAoC,EAApC;EAEA,iBAAY,IAAZ;EAEA,oBAAe,GAAf;EAEA,aAAQ,GAAR;EAEA,aAAQ,GAAR;EAEA,SAAI,kBAAJ;EAEA,SAAI,kBAAJ;EAEA,WAAM,CAAN;EAEA,eAAU,GAAV;EAEA,iBAAY,CAAZ;AACD;AAED;;;;;AAGA,SAASuH,IAAT,CAAc1X,CAAd,EAAyBmX,SAAzB,EAA0C;EACxC,IAAInX,CAAC,GAAGmX,SAAR,EAAmB,OAAOA,SAAP;EACnB,IAAInX,CAAC,GAAG,CAACmX,SAAT,EAAoB,OAAO,CAACA,SAAR;EACpB,OAAOnX,CAAP;AACD;AAED;;;;;AAGA,SAASuX,KAAT,CAAevX,CAAf,EAA4BC,CAA5B,EAAuC;EACrC,IAAIC,MAAM,GAAG,GAAb;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACI,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;IACjCD,MAAM,aAAKF,CAAC,CAACG,CAAD,CAAD,GAAOF,CAAC,CAACE,CAAD,CAAb,EAAqB,CAArB,CAAN;EACD;;EACD,OAAOD,MAAP;AACD;AAED;;;;;;;;AAMM,SAAU+W,YAAV,CAAuBC,MAAvB,EAAuCtR,OAAvC,EAAsD;EAC1D,IAAMyS,KAAK,GACT,SADIA,KACJ;IAAA;IAAA,IAAE/Q,CAAF;IAAA,IAAKC,CAAL;;IAAA,OACA,UAACvH,CAAD,EAAc;MACZ,OAAO,OAAO,MAAMsH,CAAC,YAAGtH,CAAH,EAAS,IAAIuH,CAAb,CAAd,CAAP;IACD,CAHD;EAAA,CADF;;EAMA,IAAM+Q,EAAE,GAAG1W,0CAAA,CAAa,CAAb,EAAgBsV,MAAM,GAAG,CAAzB,EAA4B,GAA5B,EAAiC/U,GAAjC,CAAqC,UAACyR,GAAD;IAAA,OAAUA,GAAG,GAAGhO,OAAN,GAAgB,GAAhB,GAAsBgO,GAAhC;EAAA,CAArC,CAAX;EAEA,IAAM4E,EAAE,GAAG5W,yCAAA,CAAY0W,EAAE,CAAClY,MAAf,EAAuB+B,GAAvB,CAA2B,UAACyR,GAAD,EAAMvQ,KAAN,EAAe;IACnD,IAAMoV,GAAG,GAAGH,EAAE,CAACjV,KAAD,CAAF,IAAauC,OAAzB;IACA,OAAO6S,GAAG,GAAGnY,IAAI,CAACqV,GAAL,CAAS,EAAE2C,EAAE,CAACjV,KAAD,CAAF,GAAYuC,OAAd,IAAyBsR,MAAlC,CAAH,GAA+CtD,GAAzD;EACD,CAHU,CAAX;EAKA,IAAM8E,aAAa,GAAG,CAAC,GAAD,EAAM,GAAN,CAAtB;EACA,IAAM/W,IAAI,GAAG;IAAE3B,CAAC,EAAEsY,EAAL;IAASrY,CAAC,EAAEuY;EAAZ,CAAb,CAf0D,CAiB1D;;EACA,IAAMG,OAAO,GAAG;IACdC,OAAO,EAAE,GADK;IAEdF,aAAa,EAAbA,aAFc;IAGdG,kBAAkB,EAAE,KAHN;IAIdC,aAAa,EAAE,GAJD;IAKdC,cAAc,EAAE;EALF,CAAhB;;EAQA,UAA4BlJ,kEAAE,CAAClO,IAAD,EAAO0W,KAAP,EAAcM,OAAd,CAA9B;EAAA,IAAQK,eAAR,OAAQA,eAAR;;EACA,sCAAeA,eAAf;EAAA,IAAO1R,CAAP;EAAA,IAAUC,CAAV;;EACA,OAAO;IAAED,CAAC,EAADA,CAAF;IAAKC,CAAC,EAADA;EAAL,CAAP;AACD;AAED;;;;;AAIM,SAAUyN,gBAAV,CAA2B1I,KAA3B,EAAuDuI,MAAvD,EAAyG;EAAA,IAAhCC,WAAgC,uEAAlB,GAAkB;EAAA,IAAbX,OAAa,uEAAH,GAAG;EAC7G,OAAO7H,KAAK,CAACnK,GAAN,CAAU,UAAC0E,KAAD,EAAQ1D,GAAR,EAAaoD,GAAb,EAAoB;IACnC,IAAIsO,MAAM,CAAC1R,GAAD,CAAN,KAAgB,CAAC,CAAjB,IAAsB0R,MAAM,CAACtO,GAAD,CAAN,KAAgB,CAAC,CAA3C,EAA8C;MAC5C,OAAOM,KAAK,GAAGvG,IAAI,CAACqV,GAAL,CAAS,CAACb,WAAV,CAAf;IACD;;IACD,IAAID,MAAM,CAAC1R,GAAD,CAAN,KAAgB0R,MAAM,CAACtO,GAAD,CAA1B,EAAiC;MAC/B,OAAOM,KAAK,GAAGvG,IAAI,CAACqV,GAAL,CAAS,CAACxB,OAAV,CAAf;IACD;;IACD,OAAOtN,KAAP;EACD,CARM,CAAP;AASD;AAED;;;;;;;AAMM,SAAUoO,sBAAV,CAAiCL,aAAjC,EAAmE;EACvEA,aAAa,GAAG5M,8CAAA,CAAiB4M,aAAjB,EAA8B;EAAA;EAA9B,CAAhB;EACA,IAAM7M,SAAS,GAAGC,8CAAA,CAAiB4M,aAAjB,CAAlB;EACA,IAAMD,UAAU,GAAG3M,qDAAA,CAAwBD,SAAxB,EAAmC6M,aAAnC,CAAnB;EACAA,aAAa,GAAG5M,wCAAA,CAAW4M,aAAX,EAA0B5M,6CAAA,CAAgBD,SAAhB,EAA2B4M,UAA3B,CAA1B,CAAhB;EACA,OAAO3M,mDAAA,CAAsB4M,aAAtB,CAAP;AACD;AAED;;;;;;AAKM,SAAUpB,aAAV,CAAwBhQ,OAAxB,EAA6CC,OAA7C,EAAkEiN,SAAlE,EAAoF;EACxF,IAAMxQ,MAAM,GAAG0B,yCAAA,CAAY4B,OAAO,CAACpD,MAApB,EAA4B+B,GAA5B,CAAgC,UAAC8W,CAAD;IAAA,OAAOrX,yCAAA,CAAY8O,SAAS,CAAC,CAAD,CAAT,CAAatQ,MAAzB,CAAP;EAAA,CAAhC,CAAf;;EAEA,KAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqD,OAAO,CAACpD,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;IACvC,KAAK,IAAI2C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,OAAO,CAAC,CAAD,CAAP,CAAWpD,MAA/B,EAAuC0C,CAAC,EAAxC,EAA4C;MAC1C,KAAK,IAAI0B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkM,SAAS,CAAC,CAAD,CAAT,CAAatQ,MAAjC,EAAyCoE,CAAC,EAA1C,EAA8C;QAC5C,IAAM8C,CAAC,GAAG9D,OAAO,CAACrD,CAAD,CAAP,CAAW2C,CAAX,CAAV;QACA5C,MAAM,CAACC,CAAD,CAAN,CAAUqE,CAAV,KAAgBf,OAAO,CAACtD,CAAD,CAAP,CAAW2C,CAAX,IAAgB4N,SAAS,CAACpJ,CAAD,CAAT,CAAa9C,CAAb,CAAhC;MACD;IACF;EACF;;EACD,OAAOtE,MAAP;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3qCD;;;;;;;;;;;;;;;;;;;AAqBA;;;AAGM,SAAU6C,UAAV,CAAqBuI,CAArB,EAAgC3I,MAAhC,EAAgD;EACpD,OAAOrC,IAAI,CAACiD,KAAL,CAAWZ,MAAM,KAAK2I,CAAtB,CAAP;AACD;AAED;;;;AAGM,SAAU7G,OAAV,CAAkB9B,MAAlB,EAAkC;EACtC,OAAOA,MAAM,EAAb;AACD;AACD;;;;AAGM,SAAUiH,IAAV,CAAesP,GAAf,EAA4B;EAChC,IAAIhZ,MAAM,GAAG,CAAb;;EADgC,2CAEbgZ,GAFa;EAAA;;EAAA;IAEhC,oDAAwB;MAAA,IAAbC,IAAa;MACtBjZ,MAAM,aAAIiZ,IAAJ,EAAY,CAAZ,CAAN;IACD;EAJ+B;IAAA;EAAA;IAAA;EAAA;;EAKhC,OAAO7Y,IAAI,CAACQ,IAAL,CAAUZ,MAAV,CAAP;AACD;AAED;;;;AAGM,SAAUgC,KAAV,CAAgBoJ,CAAhB,EAAyB;EAC7B,IAAMxD,MAAM,GAAgB,EAA5B;;EACA,KAAK,IAAI3H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmL,CAApB,EAAuBnL,CAAC,EAAxB,EAA4B;IAC1B2H,MAAM,CAACxF,IAAP,CAAY+N,SAAZ;EACD;;EACD,OAAOvI,MAAP;AACD;AAED;;;;AAGM,SAAU0F,KAAV,CAAgBlC,CAAhB,EAAyB;EAC7B,OAAOpJ,KAAK,CAACoJ,CAAD,CAAL,CAASnJ,GAAT,CAAa,UAAC4G,CAAD,EAAI5I,CAAJ;IAAA,OAAUA,CAAV;EAAA,CAAb,CAAP;AACD;AAED;;;;AAGM,SAAUiC,MAAV,CAAiBkJ,CAAjB,EAA4B8N,CAA5B,EAAqC;EACzC,OAAOlX,KAAK,CAACoJ,CAAD,CAAL,CAASnJ,GAAT,CAAa;IAAA,OAAMiX,CAAN;EAAA,CAAb,CAAP;AACD;AAED;;;;AAGM,SAAUxW,KAAV,CAAgB0I,CAAhB,EAAyB;EAC7B,OAAOlJ,MAAM,CAACkJ,CAAD,EAAI,CAAJ,CAAb;AACD;AAED;;;;AAGM,SAAU+N,IAAV,CAAe/N,CAAf,EAAwB;EAC5B,OAAOlJ,MAAM,CAACkJ,CAAD,EAAI,CAAJ,CAAb;AACD;AAED;;;;AAGM,SAAUiN,MAAV,CAAiBjR,CAAjB,EAA4BC,CAA5B,EAAuC+R,GAAvC,EAAkD;EACtD,OAAOpX,KAAK,CAACoX,GAAD,CAAL,CAAWnX,GAAX,CAAe,UAAC4G,CAAD,EAAI5I,CAAJ,EAAS;IAC7B,OAAOmH,CAAC,GAAGnH,CAAC,IAAI,CAACoH,CAAC,GAAGD,CAAL,KAAWgS,GAAG,GAAG,CAAjB,CAAJ,CAAZ;EACD,CAFM,CAAP;AAGD;AAED;;;;AAGM,SAAUvP,GAAV,CAAcwP,KAAd,EAA6B;EACjC,OAAOA,KAAK,CAAC5F,MAAN,CAAa,UAAC5J,GAAD,EAAM6J,GAAN;IAAA,OAAc7J,GAAG,GAAG6J,GAApB;EAAA,CAAb,CAAP;AACD;AAED;;;;AAGM,SAAUiC,IAAV,CAAe0D,KAAf,EAA8B;EAClC,OAAOxP,GAAG,CAACwP,KAAD,CAAH,GAAaA,KAAK,CAACnZ,MAA1B;AACD;AAED;;;;AAGM,SAAU0J,GAAV,CAAcyP,KAAd,EAA6B;EACjC,IAAIzP,GAAG,GAAG,CAAV;;EACA,KAAK,IAAI3J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoZ,KAAK,CAACnZ,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;IACrC2J,GAAG,GAAGyP,KAAK,CAACpZ,CAAD,CAAL,GAAW2J,GAAX,GAAiByP,KAAK,CAACpZ,CAAD,CAAtB,GAA4B2J,GAAlC;EACD;;EACD,OAAOA,GAAP;AACD;AAED;;;;AAGM,SAAU0P,KAAV,CAAgBD,KAAhB,EAAiC;EACrC,IAAIzP,GAAG,GAAG,CAAV;;EACA,KAAK,IAAI3J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoZ,KAAK,CAACnZ,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;IACrC,KAAK,IAAI2C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyW,KAAK,CAACpZ,CAAD,CAAL,CAASC,MAA7B,EAAqC0C,CAAC,EAAtC,EAA0C;MACxCgH,GAAG,GAAGyP,KAAK,CAACpZ,CAAD,CAAL,CAAS2C,CAAT,IAAcgH,GAAd,GAAoByP,KAAK,CAACpZ,CAAD,CAAL,CAAS2C,CAAT,CAApB,GAAkCgH,GAAxC;IACD;EACF;;EACD,OAAOA,GAAP;AACD;AAED;;;;;;AAKM,SAAUtH,eAAV,CAA0BC,QAA1B,EAA4CC,QAA5C,EAA8DC,MAA9D,EAA8E;EAClF,IAAMzC,MAAM,GAAG0C,KAAK,CAACH,QAAD,CAApB;;EACA,KAAK,IAAItC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,QAApB,EAA8BtC,CAAC,EAA/B,EAAmC;IACjC,IAAI0C,YAAY,GAAG,IAAnB;;IACA,OAAOA,YAAP,EAAqB;MACnB,IAAMC,CAAC,GAAGC,UAAU,CAACL,QAAD,EAAWC,MAAX,CAApB;MACA,IAAIK,MAAM,GAAG,KAAb;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG9C,CAApB,EAAuB8C,CAAC,EAAxB,EAA4B;QAC1B,IAAIH,CAAC,KAAK5C,MAAM,CAAC+C,CAAD,CAAhB,EAAqB;UACnBD,MAAM,GAAG,IAAT;UACA;QACD;MACF;;MACD,IAAI,CAACA,MAAL,EAAa;QACXH,YAAY,GAAG,KAAf;MACD;;MACD3C,MAAM,CAACC,CAAD,CAAN,GAAY2C,CAAZ;IACD;EACF;;EACD,OAAO5C,MAAP;AACD;AAED;;;;AAGM,SAAUoT,SAAV,CAAuBtT,CAAvB,EAA+BsH,CAA/B,EAA0CC,CAA1C,EAAmD;EACvD,IAAMxB,IAAI,GAAU,EAApB;EACA,IAAI0T,KAAK,GAAG,CAAZ;EACA,IAAIpW,KAAK,GAAG,CAAZ;;EAEA,IAAIrD,CAAC,CAACI,MAAF,KAAakH,CAAC,GAAGC,CAArB,EAAwB;IACtB,MAAM,IAAInB,KAAJ,CAAU,2CAAV,CAAN;EACD;;EAED,KAAK,IAAIjG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmH,CAApB,EAAuBnH,CAAC,EAAxB,EAA4B;IAC1B,IAAMoG,GAAG,GAAQ,EAAjB;;IACA,KAAK,IAAIzD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyE,CAApB,EAAuBzE,CAAC,EAAxB,EAA4B;MAC1ByD,GAAG,CAACjE,IAAJ,CAAStC,CAAC,CAACqD,KAAD,CAAV;MACAA,KAAK,IAAI,CAAT;IACD;;IACD0C,IAAI,CAACzD,IAAL,CAAUiE,GAAV;IACAkT,KAAK,IAAI,CAAT;EACD;;EACD,OAAO1T,IAAP;AACD;;;;;;;;;;;;;;ACpLM,IAAKnG,cAAZ;;AAAA,WAAYA,cAAZ,EAA0B;EACxBA;EACAA;EACAA;EACAA;EACAA;AACD,CAND,EAAYA,cAAc,KAAdA,cAAc,MAA1B;;;;;;;;;;;;;;ACAA;;;AAGO,IAAKC,WAAZ;;AAAA,WAAYA,WAAZ,EAAuB;EACrB;;;EAGAA;EAEA;;;;EAGAA;EAEA;;;;EAGAA;EAEA;;;;EAGAA;EAEA;;;;EAGAA;EAEAA;EAEA;;;;EAGAA;AACD,CAhCD,EAAYA,WAAW,KAAXA,WAAW,MAAvB","sources":["webpack://PSE/./src/components/Utility/DistanceFunctions.ts","webpack://PSE/./src/components/Utility/UMAP/heap.ts","webpack://PSE/./src/components/Utility/UMAP/matrix.ts","webpack://PSE/./src/components/Utility/UMAP/nn_descent.ts","webpack://PSE/./src/components/Utility/UMAP/tree.ts","webpack://PSE/./src/components/Utility/UMAP/umap.ts","webpack://PSE/./src/components/Utility/UMAP/utils.ts","webpack://PSE/./src/model/DistanceMetric.ts","webpack://PSE/./src/model/FeatureType.ts"],"sourcesContent":["import * as jaccard_dist from 'jaccard';\nimport { DistanceMetric } from '../../model/DistanceMetric';\nimport { FeatureType } from '../../model/FeatureType';\n\n// for mixed datatypes\n// gower's distance is usually normalized by the range of values of this feature;  we never see all values at once --> normalize between 0 and 1 before delivers same result\nexport function gower(featureTypes: []) {\n  return function (x: number[], y: number[]) {\n    let result = 0;\n    for (let i = 0; i < x.length; i++) {\n      switch (featureTypes[i]) {\n        case FeatureType.Quantitative:\n          result += Math.abs(x[i] - y[i]);\n          break;\n        case FeatureType.Binary:\n          result += x[i] === y[i] ? 0 : 1; // this is equivalent to the formular for quantititive features when having binary data\n          break;\n        case FeatureType.Categorical:\n          result += x[i] === y[i] ? 0 : 1; // see binary\n          break;\n        case FeatureType.Ordinal:\n          // TODO: handle ordinal data\n          break;\n        default:\n          break;\n      }\n    }\n    return result;\n  };\n}\n\n// https://github.com/ecto/jaccard TODO: also for tsne and other projection methods\nexport function jaccard(x: number[], y: number[]) {\n  return jaccard_dist.distance(x, y);\n}\n\nexport function euclidean(x: number[], y: number[]) {\n  let result = 0;\n  for (let i = 0; i < x.length; i++) {\n    result += (x[i] - y[i]) ** 2;\n  }\n  return Math.sqrt(result);\n}\n\nexport function manhattan(x: number[], y: number[]) {\n  let result = 0;\n  for (let i = 0; i < x.length; i++) {\n    result += Math.abs(x[i] - y[i]);\n  }\n  return result;\n}\n\nexport function cosine(x: number[], y: number[]) {\n  let result = 0.0;\n  let normX = 0.0;\n  let normY = 0.0;\n\n  for (let i = 0; i < x.length; i++) {\n    result += x[i] * y[i];\n    normX += x[i] ** 2;\n    normY += y[i] ** 2;\n  }\n\n  if (normX === 0 && normY === 0) {\n    return 0;\n  }\n  if (normX === 0 || normY === 0) {\n    return 1.0;\n  }\n  return 1.0 - result / Math.sqrt(normX * normY);\n}\n\nexport function get_distance_fn(distanceMetric, e) {\n  switch (distanceMetric) {\n    case DistanceMetric.EUCLIDEAN:\n      return euclidean;\n    case DistanceMetric.JACCARD:\n      return jaccard;\n    case DistanceMetric.MANHATTAN:\n      return manhattan;\n    case DistanceMetric.COSINE:\n      return cosine;\n    case DistanceMetric.GOWER:\n      return gower(e.data.featureTypes);\n    default:\n      return euclidean;\n  }\n}\n","/**\n * @license\n *\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ==============================================================================\n */\n\n/**\n * This is a JavaScript reimplementation of UMAP (original license below), from\n * the python implementation found at https://github.com/lmcinnes/umap.\n *\n * @author andycoenen@google.com (Andy Coenen)\n */\n\n/**\n * @license\n * BSD 3-Clause License\n *\n * Copyright (c) 2017, Leland McInnes\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport { RandomFn } from './umap';\nimport * as utils from './utils';\n\nexport type Heap = number[][][];\n\n/**\n *  Constructor for the heap objects. The heaps are used\n * for approximate nearest neighbor search, maintaining a list of potential\n * neighbors sorted by their distance. We also flag if potential neighbors\n * are newly added to the list or not. Internally this is stored as\n * a single array; the first axis determines whether we are looking at the\n * array of candidate indices, the array of distances, or the flag array for\n * whether elements are new or not. Each of these arrays are of shape\n * (``nPoints``, ``size``)\n */\nexport function makeHeap(nPoints: number, size: number): Heap {\n  const makeArrays = (fillValue: number) => {\n    return utils.empty(nPoints).map(() => {\n      return utils.filled(size, fillValue);\n    });\n  };\n\n  const heap: Heap = [];\n  heap.push(makeArrays(-1));\n  heap.push(makeArrays(Infinity));\n  heap.push(makeArrays(0));\n  return heap;\n}\n\n/**\n * Generate n_samples many integers from 0 to pool_size such that no\n * integer is selected twice. The duplication constraint is achieved via\n * rejection sampling.\n */\nexport function rejectionSample(nSamples: number, poolSize: number, random: RandomFn) {\n  const result = utils.zeros(nSamples);\n  for (let i = 0; i < nSamples; i++) {\n    let rejectSample = true;\n    let j = 0;\n    while (rejectSample) {\n      j = utils.tauRandInt(poolSize, random);\n      let broken = false;\n      for (let k = 0; k < i; k++) {\n        if (j === result[k]) {\n          broken = true;\n          break;\n        }\n      }\n      if (!broken) rejectSample = false;\n    }\n    result[i] = j;\n  }\n  return result;\n}\n\n/**\n * Push a new element onto the heap. The heap stores potential neighbors\n * for each data point. The ``row`` parameter determines which data point we\n * are addressing, the ``weight`` determines the distance (for heap sorting),\n * the ``index`` is the element to add, and the flag determines whether this\n * is to be considered a new addition.\n */\nexport function heapPush(heap: Heap, row: number, weight: number, index: number, flag: number): number {\n  row = Math.floor(row);\n  const indices = heap[0][row];\n  const weights = heap[1][row];\n  const isNew = heap[2][row];\n\n  if (weight >= weights[0]) {\n    return 0;\n  }\n\n  // Break if we already have this element.\n  for (let i = 0; i < indices.length; i++) {\n    if (index === indices[i]) {\n      return 0;\n    }\n  }\n\n  return uncheckedHeapPush(heap, row, weight, index, flag);\n}\n\n/**\n * Push a new element onto the heap. The heap stores potential neighbors\n * for each data point. The ``row`` parameter determines which data point we\n * are addressing, the ``weight`` determines the distance (for heap sorting),\n * the ``index`` is the element to add, and the flag determines whether this\n * is to be considered a new addition.\n */\nexport function uncheckedHeapPush(heap: Heap, row: number, weight: number, index: number, flag: number): number {\n  const indices = heap[0][row];\n  const weights = heap[1][row];\n  const isNew = heap[2][row];\n\n  if (weight >= weights[0]) {\n    return 0;\n  }\n\n  // Insert val at position zero\n  weights[0] = weight;\n  indices[0] = index;\n  isNew[0] = flag;\n\n  // Descend the heap, swapping values until the max heap criterion is met\n  let i = 0;\n  let iSwap = 0;\n  while (true) {\n    const ic1 = 2 * i + 1;\n    const ic2 = ic1 + 1;\n\n    const heapShape2 = heap[0][0].length;\n    if (ic1 >= heapShape2) {\n      break;\n    } else if (ic2 >= heapShape2) {\n      if (weights[ic1] > weight) {\n        iSwap = ic1;\n      } else {\n        break;\n      }\n    } else if (weights[ic1] >= weights[ic2]) {\n      if (weight < weights[ic1]) {\n        iSwap = ic1;\n      } else {\n        break;\n      }\n    } else if (weight < weights[ic2]) {\n      iSwap = ic2;\n    } else {\n      break;\n    }\n\n    weights[i] = weights[iSwap];\n    indices[i] = indices[iSwap];\n    isNew[i] = isNew[iSwap];\n\n    i = iSwap;\n  }\n\n  weights[i] = weight;\n  indices[i] = index;\n  isNew[i] = flag;\n  return 1;\n}\n\n/**\n * Build a heap of candidate neighbors for nearest neighbor descent. For\n * each vertex the candidate neighbors are any current neighbors, and any\n * vertices that have the vertex as one of their nearest neighbors.\n */\nexport function buildCandidates(currentGraph: Heap, nVertices: number, nNeighbors: number, maxCandidates: number, random: RandomFn) {\n  const candidateNeighbors = makeHeap(nVertices, maxCandidates);\n  for (let i = 0; i < nVertices; i++) {\n    for (let j = 0; j < nNeighbors; j++) {\n      if (currentGraph[0][i][j] < 0) {\n        continue;\n      }\n      const idx = currentGraph[0][i][j];\n      const isn = currentGraph[2][i][j];\n      const d = utils.tauRand(random);\n      heapPush(candidateNeighbors, i, d, idx, isn);\n      heapPush(candidateNeighbors, idx, d, i, isn);\n      currentGraph[2][i][j] = 0;\n    }\n  }\n  return candidateNeighbors;\n}\n\n/**\n * Given an array of heaps (of indices and weights), unpack the heap\n * out to give and array of sorted lists of indices and weights by increasing\n * weight. This is effectively just the second half of heap sort (the first\n * half not being required since we already have the data in a heap).\n */\nexport function deheapSort(heap: Heap) {\n  const indices = heap[0];\n  const weights = heap[1];\n\n  for (let i = 0; i < indices.length; i++) {\n    const indHeap = indices[i];\n    const distHeap = weights[i];\n\n    for (let j = 0; j < indHeap.length - 1; j++) {\n      const indHeapIndex = indHeap.length - j - 1;\n      const distHeapIndex = distHeap.length - j - 1;\n\n      const temp1 = indHeap[0];\n      indHeap[0] = indHeap[indHeapIndex];\n      indHeap[indHeapIndex] = temp1;\n\n      const temp2 = distHeap[0];\n      distHeap[0] = distHeap[distHeapIndex];\n      distHeap[distHeapIndex] = temp2;\n\n      siftDown(distHeap, indHeap, distHeapIndex, 0);\n    }\n  }\n  return { indices, weights };\n}\n\n/**\n * Restore the heap property for a heap with an out of place element\n * at position ``elt``. This works with a heap pair where heap1 carries\n * the weights and heap2 holds the corresponding elements.\n */\nfunction siftDown(heap1: number[], heap2: number[], ceiling: number, elt: number) {\n  while (elt * 2 + 1 < ceiling) {\n    const leftChild = elt * 2 + 1;\n    const rightChild = leftChild + 1;\n    let swap = elt;\n\n    if (heap1[swap] < heap1[leftChild]) {\n      swap = leftChild;\n    }\n    if (rightChild < ceiling && heap1[swap] < heap1[rightChild]) {\n      swap = rightChild;\n    }\n\n    if (swap === elt) {\n      break;\n    } else {\n      const temp1 = heap1[elt];\n      heap1[elt] = heap1[swap];\n      heap1[swap] = temp1;\n\n      const temp2 = heap2[elt];\n      heap2[elt] = heap2[swap];\n      heap2[swap] = temp2;\n      elt = swap;\n    }\n  }\n}\n\n/**\n * Search the heap for the smallest element that is still flagged.\n */\nexport function smallestFlagged(heap: Heap, row: number) {\n  const ind = heap[0][row];\n  const dist = heap[1][row];\n  const flag = heap[2][row];\n\n  let minDist = Infinity;\n  let resultIndex = -1;\n\n  for (let i = 0; i > ind.length; i++) {\n    if (flag[i] === 1 && dist[i] < minDist) {\n      minDist = dist[i];\n      resultIndex = i;\n    }\n  }\n\n  if (resultIndex >= 0) {\n    flag[resultIndex] = 0;\n    return Math.floor(ind[resultIndex]);\n  }\n  return -1;\n}\n","/**\n * @license\n *\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ==============================================================================\n */\n\nimport * as utils from './utils';\n\ntype Entry = { value: number; row: number; col: number };\n\n/**\n * Internal 2-dimensional sparse matrix class\n */\nexport class SparseMatrix {\n  private entries = new Map<string, Entry>();\n\n  readonly nRows: number = 0;\n\n  readonly nCols: number = 0;\n\n  constructor(rows: number[], cols: number[], values: number[], dims: number[]) {\n    if (rows.length !== cols.length || rows.length !== values.length) {\n      throw new Error('rows, cols and values arrays must all have the same length');\n    }\n\n    // TODO: Assert that dims are legit.\n    this.nRows = dims[0];\n    this.nCols = dims[1];\n    for (let i = 0; i < values.length; i++) {\n      const row = rows[i];\n      const col = cols[i];\n      this.checkDims(row, col);\n      const key = this.makeKey(row, col);\n      this.entries.set(key, { value: values[i], row, col });\n    }\n  }\n\n  private makeKey(row: number, col: number): string {\n    return `${row}:${col}`;\n  }\n\n  private checkDims(row: number, col: number) {\n    const withinBounds = row < this.nRows && col < this.nCols;\n    if (!withinBounds) {\n      throw new Error('row and/or col specified outside of matrix dimensions');\n    }\n  }\n\n  set(row: number, col: number, value: number) {\n    this.checkDims(row, col);\n    const key = this.makeKey(row, col);\n    if (!this.entries.has(key)) {\n      this.entries.set(key, { value, row, col });\n    } else {\n      this.entries.get(key)!.value = value;\n    }\n  }\n\n  get(row: number, col: number, defaultValue = 0) {\n    this.checkDims(row, col);\n    const key = this.makeKey(row, col);\n    if (this.entries.has(key)) {\n      return this.entries.get(key)!.value;\n    }\n    return defaultValue;\n  }\n\n  getAll(ordered = true): { value: number; row: number; col: number }[] {\n    const rowColValues: Entry[] = [];\n    this.entries.forEach((value) => {\n      rowColValues.push(value);\n    });\n    if (ordered) {\n      // Ordering the result isn't required for processing but it does make it easier to write tests\n      rowColValues.sort((a, b) => {\n        if (a.row === b.row) {\n          return a.col - b.col;\n        }\n        return a.row - b.row;\n      });\n    }\n    return rowColValues;\n  }\n\n  getDims(): number[] {\n    return [this.nRows, this.nCols];\n  }\n\n  getRows(): number[] {\n    return Array.from(this.entries, ([key, value]) => value.row);\n  }\n\n  getCols(): number[] {\n    return Array.from(this.entries, ([key, value]) => value.col);\n  }\n\n  getValues(): number[] {\n    return Array.from(this.entries, ([key, value]) => value.value);\n  }\n\n  forEach(fn: (value: number, row: number, col: number) => void): void {\n    this.entries.forEach((value) => fn(value.value, value.row, value.col));\n  }\n\n  map(fn: (value: number, row: number, col: number) => number): SparseMatrix {\n    const vals: number[] = [];\n    this.entries.forEach((value) => {\n      vals.push(fn(value.value, value.row, value.col));\n    });\n    const dims = [this.nRows, this.nCols];\n    return new SparseMatrix(this.getRows(), this.getCols(), vals, dims);\n  }\n\n  toArray() {\n    const rows: undefined[] = utils.empty(this.nRows);\n    const output = rows.map(() => {\n      return utils.zeros(this.nCols);\n    });\n    this.entries.forEach((value) => {\n      output[value.row][value.col] = value.value;\n    });\n    return output;\n  }\n}\n\n/**\n * Transpose a sparse matrix\n */\nexport function transpose(matrix: SparseMatrix): SparseMatrix {\n  const cols: number[] = [];\n  const rows: number[] = [];\n  const vals: number[] = [];\n\n  matrix.forEach((value, row, col) => {\n    cols.push(row);\n    rows.push(col);\n    vals.push(value);\n  });\n\n  const dims = [matrix.nCols, matrix.nRows];\n  return new SparseMatrix(rows, cols, vals, dims);\n}\n\n/**\n * Construct a sparse identity matrix\n */\nexport function identity(size: number[]): SparseMatrix {\n  const [rows] = size;\n  const matrix = new SparseMatrix([], [], [], size);\n  for (let i = 0; i < rows; i++) {\n    matrix.set(i, i, 1);\n  }\n  return matrix;\n}\n\n/**\n * Element-wise multiplication of two matrices\n */\nexport function pairwiseMultiply(a: SparseMatrix, b: SparseMatrix): SparseMatrix {\n  return elementWise(a, b, (x, y) => x * y);\n}\n\n/**\n * Element-wise addition of two matrices\n */\nexport function add(a: SparseMatrix, b: SparseMatrix): SparseMatrix {\n  return elementWise(a, b, (x, y) => x + y);\n}\n\n/**\n * Element-wise subtraction of two matrices\n */\nexport function subtract(a: SparseMatrix, b: SparseMatrix): SparseMatrix {\n  return elementWise(a, b, (x, y) => x - y);\n}\n\n/**\n * Element-wise maximum of two matrices\n */\nexport function maximum(a: SparseMatrix, b: SparseMatrix): SparseMatrix {\n  return elementWise(a, b, (x, y) => (x > y ? x : y));\n}\n\n/**\n * Scalar multiplication of two matrices\n */\nexport function multiplyScalar(a: SparseMatrix, scalar: number): SparseMatrix {\n  return a.map((value: number) => {\n    return value * scalar;\n  });\n}\n\n/**\n * Returns a new matrix with zero entries removed.\n */\nexport function eliminateZeros(m: SparseMatrix) {\n  const zeroIndices = new Set();\n  const values = m.getValues();\n  const rows = m.getRows();\n  const cols = m.getCols();\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] === 0) {\n      zeroIndices.add(i);\n    }\n  }\n  const removeByZeroIndex = (_, index: number) => !zeroIndices.has(index);\n  const nextValues = values.filter(removeByZeroIndex);\n  const nextRows = rows.filter(removeByZeroIndex);\n  const nextCols = cols.filter(removeByZeroIndex);\n\n  return new SparseMatrix(nextRows, nextCols, nextValues, m.getDims());\n}\n\nexport const enum NormType {\n  max = 'max',\n  l1 = 'l1',\n  l2 = 'l2',\n}\n\n/**\n * Normalization of a sparse matrix.\n */\nexport function normalize(m: SparseMatrix, normType = NormType.l2) {\n  const normFn = normFns[normType];\n\n  const colsByRow = new Map<number, number[]>();\n  m.forEach((_, row, col) => {\n    const cols = colsByRow.get(row) || [];\n    cols.push(col);\n    colsByRow.set(row, cols);\n  });\n\n  const nextMatrix = new SparseMatrix([], [], [], m.getDims());\n\n  for (const row of colsByRow.keys()) {\n    const cols = colsByRow.get(row)!.sort();\n\n    const vals = cols.map((col) => m.get(row, col));\n    const norm = normFn(vals);\n    for (let i = 0; i < norm.length; i++) {\n      nextMatrix.set(row, cols[i], norm[i]);\n    }\n  }\n\n  return nextMatrix;\n}\n\n/**\n * Vector normalization functions\n */\ntype NormFns = { [key in NormType]: (v: number[]) => number[] };\nconst normFns: NormFns = {\n  [NormType.max]: (xs: number[]) => {\n    let max = -Infinity;\n    for (let i = 0; i < xs.length; i++) {\n      max = xs[i] > max ? xs[i] : max;\n    }\n    return xs.map((x) => x / max);\n  },\n  [NormType.l1]: (xs: number[]) => {\n    let sum = 0;\n    for (let i = 0; i < xs.length; i++) {\n      sum += xs[i];\n    }\n    return xs.map((x) => x / sum);\n  },\n  [NormType.l2]: (xs: number[]) => {\n    let sum = 0;\n    for (let i = 0; i < xs.length; i++) {\n      sum += xs[i] ** 2;\n    }\n    return xs.map((x) => Math.sqrt(x ** 2 / sum));\n  },\n};\n\n/**\n * Helper function for element-wise operations.\n */\nfunction elementWise(a: SparseMatrix, b: SparseMatrix, op: (x: number, y: number) => number): SparseMatrix {\n  const visited = new Set<string>();\n  const rows: number[] = [];\n  const cols: number[] = [];\n  const vals: number[] = [];\n\n  const operate = (row: number, col: number) => {\n    rows.push(row);\n    cols.push(col);\n    const nextValue = op(a.get(row, col), b.get(row, col));\n    vals.push(nextValue);\n  };\n\n  const valuesA = a.getValues();\n  const rowsA = a.getRows();\n  const colsA = a.getCols();\n  for (let i = 0; i < valuesA.length; i++) {\n    const row = rowsA[i];\n    const col = colsA[i];\n    const key = `${row}:${col}`;\n    visited.add(key);\n    operate(row, col);\n  }\n\n  const valuesB = b.getValues();\n  const rowsB = b.getRows();\n  const colsB = b.getCols();\n  for (let i = 0; i < valuesB.length; i++) {\n    const row = rowsB[i];\n    const col = colsB[i];\n    const key = `${row}:${col}`;\n    if (visited.has(key)) continue;\n    operate(row, col);\n  }\n\n  const dims = [a.nRows, a.nCols];\n  return new SparseMatrix(rows, cols, vals, dims);\n}\n\n/**\n * Helper function for getting data, indices, and inptr arrays from a sparse\n * matrix to follow csr matrix conventions. Super inefficient (and kind of\n * defeats the purpose of this convention) but a lot of the ported python tree\n * search logic depends on this data format.\n */\nexport function getCSR(x: SparseMatrix) {\n  const entries: Entry[] = [];\n\n  x.forEach((value, row, col) => {\n    entries.push({ value, row, col });\n  });\n\n  entries.sort((a, b) => {\n    if (a.row === b.row) {\n      return a.col - b.col;\n    }\n    return a.row - b.row;\n  });\n\n  const indices: number[] = [];\n  const values: number[] = [];\n  const indptr: number[] = [];\n\n  let currentRow = -1;\n  for (let i = 0; i < entries.length; i++) {\n    const { row, col, value } = entries[i];\n    if (row !== currentRow) {\n      currentRow = row;\n      indptr.push(i);\n    }\n    indices.push(col);\n    values.push(value);\n  }\n\n  return { indices, values, indptr };\n}\n","/**\n * @license\n *\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ==============================================================================\n */\n\n/**\n * This is a JavaScript reimplementation of UMAP (original license below), from\n * the python implementation found at https://github.com/lmcinnes/umap.\n *\n * @author andycoenen@google.com (Andy Coenen)\n */\n\n/**\n * @license\n * BSD 3-Clause License\n *\n * Copyright (c) 2017, Leland McInnes\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as heap from './heap';\nimport * as matrix from './matrix';\nimport * as tree from './tree';\nimport * as utils from './utils';\nimport { RandomFn, Vectors, DistanceFn } from './umap';\n\n/**\n * Create a version of nearest neighbor descent.\n */\nexport function makeNNDescent(distanceFn: DistanceFn, random: RandomFn) {\n  return function nNDescent(\n    data: Vectors,\n    leafArray: Vectors,\n    nNeighbors: number,\n    nIters = 10,\n    maxCandidates = 50,\n    delta = 0.001,\n    rho = 0.5,\n    rpTreeInit = true,\n  ) {\n    const nVertices = data.length;\n    const currentGraph = heap.makeHeap(data.length, nNeighbors);\n\n    for (let i = 0; i < data.length; i++) {\n      const indices = heap.rejectionSample(nNeighbors, data.length, random);\n      for (let j = 0; j < indices.length; j++) {\n        const d = distanceFn(data[i], data[indices[j]]);\n\n        heap.heapPush(currentGraph, i, d, indices[j], 1);\n        heap.heapPush(currentGraph, indices[j], d, i, 1);\n      }\n    }\n    if (rpTreeInit) {\n      for (let n = 0; n < leafArray.length; n++) {\n        for (let i = 0; i < leafArray[n].length; i++) {\n          if (leafArray[n][i] < 0) {\n            break;\n          }\n          for (let j = i + 1; j < leafArray[n].length; j++) {\n            if (leafArray[n][j] < 0) {\n              break;\n            }\n            const d = distanceFn(data[leafArray[n][i]], data[leafArray[n][j]]);\n            heap.heapPush(currentGraph, leafArray[n][i], d, leafArray[n][j], 1);\n            heap.heapPush(currentGraph, leafArray[n][j], d, leafArray[n][i], 1);\n          }\n        }\n      }\n    }\n\n    for (let n = 0; n < nIters; n++) {\n      const candidateNeighbors = heap.buildCandidates(currentGraph, nVertices, nNeighbors, maxCandidates, random);\n\n      let c = 0;\n      for (let i = 0; i < nVertices; i++) {\n        for (let j = 0; j < maxCandidates; j++) {\n          const p = Math.floor(candidateNeighbors[0][i][j]);\n          if (p < 0 || utils.tauRand(random) < rho) {\n            continue;\n          }\n          for (let k = 0; k < maxCandidates; k++) {\n            const q = Math.floor(candidateNeighbors[0][i][k]);\n            const cj = candidateNeighbors[2][i][j];\n            const ck = candidateNeighbors[2][i][k];\n            if (q < 0 || (!cj && !ck)) {\n              continue;\n            }\n\n            const d = distanceFn(data[p], data[q]);\n            c += heap.heapPush(currentGraph, p, d, q, 1);\n            c += heap.heapPush(currentGraph, q, d, p, 1);\n          }\n        }\n      }\n      if (c <= delta * nNeighbors * data.length) {\n        break;\n      }\n    }\n    const sorted = heap.deheapSort(currentGraph);\n    return sorted;\n  };\n}\n\nexport type InitFromRandomFn = (nNeighbors: number, data: Vectors, queryPoints: Vectors, _heap: heap.Heap, random: RandomFn) => void;\n\nexport type InitFromTreeFn = (_tree: tree.FlatTree, data: Vectors, queryPoints: Vectors, _heap: heap.Heap, random: RandomFn) => void;\n\nexport function makeInitializations(distanceFn: DistanceFn) {\n  function initFromRandom(nNeighbors: number, data: Vectors, queryPoints: Vectors, _heap: heap.Heap, random: RandomFn) {\n    for (let i = 0; i < queryPoints.length; i++) {\n      const indices = utils.rejectionSample(nNeighbors, data.length, random);\n      for (let j = 0; j < indices.length; j++) {\n        if (indices[j] < 0) {\n          continue;\n        }\n        const d = distanceFn(data[indices[j]], queryPoints[i]);\n        heap.heapPush(_heap, i, d, indices[j], 1);\n      }\n    }\n  }\n\n  function initFromTree(_tree: tree.FlatTree, data: Vectors, queryPoints: Vectors, _heap: heap.Heap, random: RandomFn) {\n    for (let i = 0; i < queryPoints.length; i++) {\n      const indices = tree.searchFlatTree(queryPoints[i], _tree, random);\n\n      for (let j = 0; j < indices.length; j++) {\n        if (indices[j] < 0) {\n          return;\n        }\n        const d = distanceFn(data[indices[j]], queryPoints[i]);\n        heap.heapPush(_heap, i, d, indices[j], 1);\n      }\n    }\n  }\n\n  return { initFromRandom, initFromTree };\n}\n\nexport type SearchFn = (data: Vectors, graph: matrix.SparseMatrix, initialization: heap.Heap, queryPoints: Vectors) => heap.Heap;\n\nexport function makeInitializedNNSearch(distanceFn: DistanceFn) {\n  return function nnSearchFn(data: Vectors, graph: matrix.SparseMatrix, initialization: heap.Heap, queryPoints: Vectors) {\n    const { indices, indptr } = matrix.getCSR(graph);\n\n    for (let i = 0; i < queryPoints.length; i++) {\n      const tried = new Set(initialization[0][i]);\n      while (true) {\n        // Find smallest flagged vertex\n        const vertex = heap.smallestFlagged(initialization, i);\n\n        if (vertex === -1) {\n          break;\n        }\n        const candidates = indices.slice(indptr[vertex], indptr[vertex + 1]);\n        for (const candidate of candidates) {\n          if (candidate === vertex || candidate === -1 || tried.has(candidate)) {\n            continue;\n          }\n          const d = distanceFn(data[candidate], queryPoints[i]);\n          heap.uncheckedHeapPush(initialization, i, d, candidate, 1);\n          tried.add(candidate);\n        }\n      }\n    }\n    return initialization;\n  };\n}\n\nexport function initializeSearch(\n  forest: tree.FlatTree[],\n  data: Vectors,\n  queryPoints: Vectors,\n  nNeighbors: number,\n  initFromRandom: InitFromRandomFn,\n  initFromTree: InitFromTreeFn,\n  random: RandomFn,\n) {\n  const results = heap.makeHeap(queryPoints.length, nNeighbors);\n  initFromRandom(nNeighbors, data, queryPoints, results, random);\n  if (forest) {\n    for (const tree of forest) {\n      initFromTree(tree, data, queryPoints, results, random);\n    }\n  }\n  return results;\n}\n","/**\n * @license\n *\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ==============================================================================\n */\n\n/**\n * This is a JavaScript reimplementation of UMAP (original license below), from\n * the python implementation found at https://github.com/lmcinnes/umap.\n *\n * @author andycoenen@google.com (Andy Coenen)\n */\n\n/**\n * @license\n * BSD 3-Clause License\n *\n * Copyright (c) 2017, Leland McInnes\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as utils from './utils';\nimport { RandomFn, Vector, Vectors } from './umap';\n\n/**\n * Tree functionality for approximating nearest neighbors\n */\ninterface RandomProjectionTreeNode {\n  isLeaf: boolean;\n  indices?: number[];\n  leftChild?: RandomProjectionTreeNode;\n  rightChild?: RandomProjectionTreeNode;\n  hyperplane?: number[];\n  offset?: number;\n}\n\nexport class FlatTree {\n  constructor(public hyperplanes: number[][], public offsets: number[], public children: number[][], public indices: number[][]) {}\n}\n\n/**\n * Build a random projection forest with ``nTrees``.\n */\nexport function makeForest(data: Vectors, nNeighbors: number, nTrees: number, random: RandomFn) {\n  const leafSize = Math.max(10, nNeighbors);\n\n  const trees = utils.range(nTrees).map((_, i) => makeTree(data, leafSize, i, random));\n  const forest = trees.map((tree) => flattenTree(tree, leafSize));\n\n  return forest;\n}\n\n/**\n * Construct a random projection tree based on ``data`` with leaves\n * of size at most ``leafSize``\n */\nfunction makeTree(data: Vectors, leafSize = 30, n: number, random: RandomFn): RandomProjectionTreeNode {\n  const indices = utils.range(data.length);\n  const tree = makeEuclideanTree(data, indices, leafSize, n, random);\n  return tree;\n}\n\nfunction makeEuclideanTree(data: Vectors, indices: number[], leafSize = 30, q: number, random: RandomFn): RandomProjectionTreeNode {\n  if (indices.length > leafSize) {\n    const splitResults = euclideanRandomProjectionSplit(data, indices, random);\n    const { indicesLeft, indicesRight, hyperplane, offset } = splitResults;\n\n    const leftChild = makeEuclideanTree(data, indicesLeft, leafSize, q + 1, random);\n    const rightChild = makeEuclideanTree(data, indicesRight, leafSize, q + 1, random);\n\n    const node = { leftChild, rightChild, isLeaf: false, hyperplane, offset };\n    return node;\n  }\n  const node = { indices, isLeaf: true };\n  return node;\n}\n\n/**\n * Given a set of ``indices`` for data points from ``data``, create\n * a random hyperplane to split the data, returning two arrays indices\n * that fall on either side of the hyperplane. This is the basis for a\n * random projection tree, which simply uses this splitting recursively.\n * This particular split uses euclidean distance to determine the hyperplane\n * and which side each data sample falls on.\n */\nfunction euclideanRandomProjectionSplit(data: Vectors, indices: number[], random: RandomFn) {\n  const dim = data[0].length;\n\n  // Select two random points, set the hyperplane between them\n  const leftIndex = utils.tauRandInt(indices.length, random);\n  let rightIndex = utils.tauRandInt(indices.length, random);\n  rightIndex += leftIndex === rightIndex ? 1 : 0;\n  rightIndex %= indices.length;\n  const left = indices[leftIndex];\n  const right = indices[rightIndex];\n\n  // Compute the normal vector to the hyperplane (the vector between the two\n  // points) and the offset from the origin\n  let hyperplaneOffset = 0;\n  const hyperplaneVector = utils.zeros(dim);\n\n  for (let i = 0; i < hyperplaneVector.length; i++) {\n    hyperplaneVector[i] = data[left][i] - data[right][i];\n    hyperplaneOffset -= (hyperplaneVector[i] * (data[left][i] + data[right][i])) / 2.0;\n  }\n\n  // For each point compute the margin (project into normal vector)\n  // If we are on lower side of the hyperplane put in one pile, otherwise\n  // put it in the other pile (if we hit hyperplane on the nose, flip a coin)\n  let nLeft = 0;\n  let nRight = 0;\n  const side = utils.zeros(indices.length);\n  for (let i = 0; i < indices.length; i++) {\n    let margin = hyperplaneOffset;\n    for (let d = 0; d < dim; d++) {\n      margin += hyperplaneVector[d] * data[indices[i]][d];\n    }\n    if (margin === 0) {\n      side[i] = utils.tauRandInt(2, random);\n      if (side[i] === 0) {\n        nLeft += 1;\n      } else {\n        nRight += 1;\n      }\n    } else if (margin > 0) {\n      side[i] = 0;\n      nLeft += 1;\n    } else {\n      side[i] = 1;\n      nRight += 1;\n    }\n  }\n\n  // Now that we have the counts, allocate arrays\n  const indicesLeft = utils.zeros(nLeft);\n  const indicesRight = utils.zeros(nRight);\n\n  // Populate the arrays with indices according to which side they fell on\n  nLeft = 0;\n  nRight = 0;\n  for (const i in utils.range(side.length)) {\n    if (side[i] === 0) {\n      indicesLeft[nLeft] = indices[i];\n      nLeft += 1;\n    } else {\n      indicesRight[nRight] = indices[i];\n      nRight += 1;\n    }\n  }\n\n  return {\n    indicesLeft,\n    indicesRight,\n    hyperplane: hyperplaneVector,\n    offset: hyperplaneOffset,\n  };\n}\n\nfunction flattenTree(tree: RandomProjectionTreeNode, leafSize: number) {\n  const nNodes = numNodes(tree);\n  const nLeaves = numLeaves(tree);\n\n  // TODO: Verify that sparse code is not relevant...\n  const hyperplanes = utils.range(nNodes).map(() => utils.zeros(tree.hyperplane ? tree.hyperplane.length : 0));\n\n  const offsets = utils.zeros(nNodes);\n  const children = utils.range(nNodes).map(() => [-1, -1]);\n  const indices = utils.range(nLeaves).map(() => utils.range(leafSize).map(() => -1));\n  recursiveFlatten(tree, hyperplanes, offsets, children, indices, 0, 0);\n  return new FlatTree(hyperplanes, offsets, children, indices);\n}\n\nfunction recursiveFlatten(\n  tree: RandomProjectionTreeNode,\n  hyperplanes: number[][],\n  offsets: number[],\n  children: number[][],\n  indices: number[][],\n  nodeNum: number,\n  leafNum: number,\n): { nodeNum: number; leafNum: number } {\n  if (tree.isLeaf) {\n    children[nodeNum][0] = -leafNum;\n\n    // TODO: Triple check this operation corresponds to\n    // indices[leafNum : tree.indices.shape[0]] = tree.indices\n    indices[leafNum].splice(0, tree.indices!.length, ...tree.indices!);\n    leafNum += 1;\n    return { nodeNum, leafNum };\n  }\n  hyperplanes[nodeNum] = tree.hyperplane!;\n  offsets[nodeNum] = tree.offset!;\n  children[nodeNum][0] = nodeNum + 1;\n  const oldNodeNum = nodeNum;\n\n  let res = recursiveFlatten(tree.leftChild!, hyperplanes, offsets, children, indices, nodeNum + 1, leafNum);\n  nodeNum = res.nodeNum;\n  leafNum = res.leafNum;\n\n  children[oldNodeNum][1] = nodeNum + 1;\n\n  res = recursiveFlatten(tree.rightChild!, hyperplanes, offsets, children, indices, nodeNum + 1, leafNum);\n  return { nodeNum: res.nodeNum, leafNum: res.leafNum };\n}\n\nfunction numNodes(tree: RandomProjectionTreeNode): number {\n  if (tree.isLeaf) {\n    return 1;\n  }\n  return 1 + numNodes(tree.leftChild!) + numNodes(tree.rightChild!);\n}\n\nfunction numLeaves(tree: RandomProjectionTreeNode): number {\n  if (tree.isLeaf) {\n    return 1;\n  }\n  return numLeaves(tree.leftChild!) + numLeaves(tree.rightChild!);\n}\n\n/**\n * Generate an array of sets of candidate nearest neighbors by\n * constructing a random projection forest and taking the leaves of all the\n * trees. Any given tree has leaves that are a set of potential nearest\n * neighbors. Given enough trees the set of all such leaves gives a good\n * likelihood of getting a good set of nearest neighbors in composite. Since\n * such a random projection forest is inexpensive to compute, this can be a\n * useful means of seeding other nearest neighbor algorithms.\n */\nexport function makeLeafArray(rpForest: FlatTree[]): number[][] {\n  if (rpForest.length > 0) {\n    const output: number[][] = [];\n    for (const tree of rpForest) {\n      output.push(...tree.indices!);\n    }\n    return output;\n  }\n  return [[-1]];\n}\n\n/**\n * Selects the side of the tree to search during flat tree search.\n */\nfunction selectSide(hyperplane: number[], offset: number, point: Vector, random: RandomFn) {\n  let margin = offset;\n  for (let d = 0; d < point.length; d++) {\n    margin += hyperplane[d] * point[d];\n  }\n\n  if (margin === 0) {\n    const side = utils.tauRandInt(2, random);\n    return side;\n  }\n  if (margin > 0) {\n    return 0;\n  }\n  return 1;\n}\n\n/**\n * Searches a flattened rp-tree for a point.\n */\nexport function searchFlatTree(point: Vector, tree: FlatTree, random: RandomFn) {\n  let node = 0;\n  while (tree.children[node][0] > 0) {\n    const side = selectSide(tree.hyperplanes[node], tree.offsets[node], point, random);\n    if (side === 0) {\n      node = tree.children[node][0];\n    } else {\n      node = tree.children[node][1];\n    }\n  }\n\n  const index = -1 * tree.children[node][0];\n  return tree.indices[index];\n}\n","/**\n * @license\n *\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ==============================================================================\n */\n\n/**\n * This is a JavaScript reimplementation of UMAP (original license below), from\n * the python implementation found at https://github.com/lmcinnes/umap.\n *\n * @author andycoenen@google.com (Andy Coenen)\n */\n\n/**\n * @license\n * BSD 3-Clause License\n *\n * Copyright (c) 2017, Leland McInnes\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport LM from 'ml-levenberg-marquardt';\nimport * as heap from './heap';\nimport * as matrix from './matrix';\nimport * as nnDescent from './nn_descent';\nimport * as tree from './tree';\nimport * as utils from './utils';\nimport * as jaccard_dist from 'jaccard';\n\nexport type DistanceFn = (x: Vector, y: Vector) => number;\nexport type RandomFn = () => number;\nexport type EpochCallback = (epoch: number) => boolean | void;\nexport type Vector = number[];\nexport type Vectors = Vector[];\nexport const enum TargetMetric {\n  categorical = 'categorical',\n  l1 = 'l1',\n  l2 = 'l2',\n}\n\nconst SMOOTH_K_TOLERANCE = 1e-5;\nconst MIN_K_DIST_SCALE = 1e-3;\n\nexport interface UMAPParameters {\n  /**\n   * The distance function with which to assess nearest neighbors, defaults\n   * to euclidean distance.\n   */\n  distanceFn?: DistanceFn;\n  /**\n   * The initial learning rate for the embedding optimization.\n   */\n  learningRate?: number;\n  /**\n   * The local connectivity required -- i.e. the number of nearest\n   * neighbors that should be assumed to be connected at a local level.\n   * The higher this value the more connected the manifold becomes\n   * locally. In practice this should be not more than the local intrinsic\n   * dimension of the manifold.\n   */\n  localConnectivity?: number;\n  /**\n   * The effective minimum distance between embedded points. Smaller values\n   * will result in a more clustered/clumped embedding where nearby points\n   * on the manifold are drawn closer together, while larger values will\n   * result on a more even dispersal of points. The value should be set\n   * relative to the ``spread`` value, which determines the scale at which\n   * embedded points will be spread out.\n   */\n  minDist?: number;\n  /**\n   * The dimension of the space to embed into. This defaults to 2 to\n   * provide easy visualization, but can reasonably be set to any\n   * integer value in the range 2 to 100.\n   */\n  nComponents?: number;\n  /**\n   * The number of training epochs to be used in optimizing the\n   * low dimensional embedding. Larger values result in more accurate\n   * embeddings. If None is specified a value will be selected based on\n   * the size of the input dataset (200 for large datasets, 500 for small).\n   */\n  nEpochs?: number;\n  /**\n   * The size of local neighborhood (in terms of number of neighboring\n   * sample points) used for manifold approximation. Larger values\n   * result in more global views of the manifold, while smaller\n   * values result in more local data being preserved. In general\n   * values should be in the range 2 to 100.\n   */\n  nNeighbors?: number;\n  /**\n   * The number of negative samples to select per positive sample\n   * in the optimization process. Increasing this value will result\n   * in greater repulsive force being applied, greater optimization\n   * cost, but slightly more accuracy.\n   */\n  negativeSampleRate?: number;\n  /**\n   * Weighting applied to negative samples in low dimensional embedding\n   * optimization. Values higher than one will result in greater weight\n   * being given to negative samples.\n   */\n  repulsionStrength?: number;\n  /**\n   * The pseudo-random number generator used by the stochastic parts of the\n   * algorithm.\n   */\n  random?: RandomFn;\n  /**\n   * Interpolate between (fuzzy) union and intersection as the set operation\n   * used to combine local fuzzy simplicial sets to obtain a global fuzzy\n   * simplicial sets. Both fuzzy set operations use the product t-norm.\n   * The value of this parameter should be between 0.0 and 1.0; a value of\n   * 1.0 will use a pure fuzzy union, while 0.0 will use a pure fuzzy\n   * intersection.\n   */\n  setOpMixRatio?: number;\n  /**\n   * The effective scale of embedded points. In combination with ``min_dist``\n   * this determines how clustered/clumped the embedded points are.\n   */\n  spread?: number;\n  /**\n   * For transform operations (embedding new points using a trained model)\n   * this will control how aggressively to search for nearest neighbors.\n   * Larger values will result in slower performance but more accurate\n   * nearest neighbor evaluation.\n   */\n  transformQueueSize?: number;\n}\n\nexport interface UMAPSupervisedParams {\n  /**\n   * The metric used to measure distance for a target array is using supervised\n   * dimension reduction. By default this is 'categorical' which will measure\n   * distance in terms of whether categories match or are different. Furthermore,\n   * if semi-supervised is required target values of -1 will be treated as\n   * unlabelled under the 'categorical' metric. If the target array takes\n   * continuous values (e.g. for a regression problem) then metric of 'l1'\n   * or 'l2' is probably more appropriate.\n   */\n  targetMetric?: TargetMetric;\n  /**\n   * Weighting factor between data topology and target topology. A value of\n   * 0.0 weights entirely on data, a value of 1.0 weights entirely on target.\n   * The default of 0.5 balances the weighting equally between data and target.\n   */\n  targetWeight?: number;\n  /**\n   * The number of nearest neighbors to use to construct the target simplcial\n   * set. Defaults to the `nearestNeighbors` parameter.\n   */\n  targetNNeighbors?: number;\n}\n\n/**\n * UMAP projection system, based on the python implementation from McInnes, L,\n * Healy, J, UMAP: Uniform Manifold Approximation and Projection for Dimension\n * Reduction (https://github.com/lmcinnes/umap).\n *\n * This implementation differs in a few regards:\n * a) The initialization of the embedding for optimization is not computed using\n *    a spectral method, rather it is initialized randomly. This avoids some\n *    computationally intensive matrix eigen computations that aren't easily\n *    ported to JavaScript.\n * b) A lot of \"extra\" functionality has been omitted from this implementation,\n *    most notably a great deal of alternate distance functions.\n *\n * This implementation provides three methods of reducing dimensionality:\n * 1) fit: fit the data synchronously\n * 2) fitAsync: fit the data asynchronously, with a callback function provided\n *      that is invoked on each optimization step.\n * 3) initializeFit / step: manually initialize the algorithm then explictly\n *      step through each epoch of the SGD optimization\n */\nexport class UMAP {\n  private learningRate = 1.0;\n\n  private localConnectivity = 1.0;\n\n  private minDist = 0.1;\n\n  private nComponents = 2;\n\n  private nEpochs = 0;\n\n  private nNeighbors = 15;\n\n  private negativeSampleRate = 5;\n\n  private random = Math.random;\n\n  private repulsionStrength = 1.0;\n\n  private setOpMixRatio = 1.0;\n\n  private spread = 1.0;\n\n  private transformQueueSize = 4.0;\n\n  // Supervised projection params\n  private targetMetric = TargetMetric.categorical;\n\n  private targetWeight = 0.5;\n\n  private targetNNeighbors = this.nNeighbors;\n\n  private distanceFn: DistanceFn = euclidean;\n\n  // KNN state (can be precomputed and supplied via initializeFit)\n  private knnIndices?: number[][];\n\n  private knnDistances?: number[][];\n\n  // Internal graph connectivity representation\n  private graph!: matrix.SparseMatrix;\n\n  private X!: Vectors;\n\n  private isInitialized = false;\n\n  private rpForest: tree.FlatTree[] = [];\n\n  private initFromRandom!: nnDescent.InitFromRandomFn;\n\n  private initFromTree!: nnDescent.InitFromTreeFn;\n\n  private search!: nnDescent.SearchFn;\n\n  private searchGraph!: matrix.SparseMatrix;\n\n  // Supervised projection labels / targets\n  private Y?: number[];\n\n  // Projected embedding\n  private embedding: number[][] = [];\n\n  private optimizationState = new OptimizationState();\n\n  constructor(params: UMAPParameters = {}) {\n    const setParam = (key: string) => {\n      if (params[key] !== undefined) this[key] = params[key];\n    };\n\n    setParam('distanceFn');\n    setParam('learningRate');\n    setParam('localConnectivity');\n    setParam('minDist');\n    setParam('nComponents');\n    setParam('nEpochs');\n    setParam('nNeighbors');\n    setParam('negativeSampleRate');\n    setParam('random');\n    setParam('repulsionStrength');\n    setParam('setOpMixRatio');\n    setParam('spread');\n    setParam('transformQueueSize');\n  }\n\n  /**\n   * Fit the data to a projected embedding space synchronously.\n   */\n  fit(X: Vectors, initialEmbedding: any) {\n    this.initializeFit(X, initialEmbedding);\n    this.optimizeLayout();\n\n    return this.embedding;\n  }\n\n  /**\n   * Fit the data to a projected embedding space asynchronously, with a callback\n   * function invoked on every epoch of optimization.\n   */\n  async fitAsync(X: Vectors, initialEmbedding: any, callback: (epochNumber: number) => void | boolean = () => true) {\n    this.initializeFit(X, initialEmbedding);\n\n    await this.optimizeLayoutAsync(callback);\n    return this.embedding;\n  }\n\n  /**\n   * Initializes parameters needed for supervised projection.\n   */\n  setSupervisedProjection(Y: number[], params: UMAPSupervisedParams = {}) {\n    this.Y = Y;\n    this.targetMetric = params.targetMetric || this.targetMetric;\n    this.targetWeight = params.targetWeight || this.targetWeight;\n    this.targetNNeighbors = params.targetNNeighbors || this.targetNNeighbors;\n  }\n\n  /**\n   * Initializes umap with precomputed KNN indices and distances.\n   */\n  setPrecomputedKNN(knnIndices: number[][], knnDistances: number[][]) {\n    this.knnIndices = knnIndices;\n    this.knnDistances = knnDistances;\n  }\n\n  /**\n   * Initializes fit by computing KNN and a fuzzy simplicial set, as well as\n   * initializing the projected embeddings. Sets the optimization state ahead\n   * of optimization steps. Returns the number of epochs to be used for the\n   * SGD optimization.\n   */\n  initializeFit(X: Vectors, initialEmbedding: any): number {\n    if (X.length <= this.nNeighbors) {\n      throw new Error(`Not enough data points (${X.length}) to create nNeighbors: ${this.nNeighbors}.  Add more data points or adjust the configuration.`);\n    }\n\n    // We don't need to reinitialize if we've already initialized for this data.\n    if (this.X === X && this.isInitialized) {\n      return this.getNEpochs();\n    }\n\n    this.X = X;\n\n    if (!this.knnIndices && !this.knnDistances) {\n      const knnResults = this.nearestNeighbors(X);\n      this.knnIndices = knnResults.knnIndices;\n      this.knnDistances = knnResults.knnDistances;\n    }\n\n    this.graph = this.fuzzySimplicialSet(X, this.nNeighbors, this.setOpMixRatio);\n\n    // Set up the search graph for subsequent transformation.\n    this.makeSearchFns();\n    this.searchGraph = this.makeSearchGraph(X);\n\n    // Check if supervised projection, then adjust the graph.\n    this.processGraphForSupervisedProjection();\n\n    const { head, tail, epochsPerSample } = this.initializeSimplicialSetEmbedding(initialEmbedding);\n\n    // Set the optimization routine state\n    this.optimizationState.head = head;\n    this.optimizationState.tail = tail;\n    this.optimizationState.epochsPerSample = epochsPerSample;\n\n    // Now, initialize the optimization steps\n    this.initializeOptimization();\n    this.prepareForOptimizationLoop();\n    this.isInitialized = true;\n\n    return this.getNEpochs();\n  }\n\n  private makeSearchFns() {\n    const { initFromTree, initFromRandom } = nnDescent.makeInitializations(this.distanceFn);\n    this.initFromTree = initFromTree;\n    this.initFromRandom = initFromRandom;\n    this.search = nnDescent.makeInitializedNNSearch(this.distanceFn);\n  }\n\n  private makeSearchGraph(X: Vectors) {\n    const knnIndices = this.knnIndices!;\n    const knnDistances = this.knnDistances!;\n    const dims = [X.length, X.length];\n    const searchGraph = new matrix.SparseMatrix([], [], [], dims);\n    for (let i = 0; i < knnIndices.length; i++) {\n      const knn = knnIndices[i];\n      const distances = knnDistances[i];\n      for (let j = 0; j < knn.length; j++) {\n        const neighbor = knn[j];\n        const distance = distances[j];\n        if (distance > 0) {\n          searchGraph.set(i, neighbor, distance);\n        }\n      }\n    }\n\n    const transpose = matrix.transpose(searchGraph);\n    return matrix.maximum(searchGraph, transpose);\n  }\n\n  /**\n   * Transforms data to the existing embedding space.\n   */\n  transform(toTransform: Vectors) {\n    // Use the previous rawData\n    const rawData = this.X;\n    if (rawData === undefined || rawData.length === 0) {\n      throw new Error('No data has been fit.');\n    }\n\n    let nNeighbors = Math.floor(this.nNeighbors * this.transformQueueSize);\n    nNeighbors = Math.min(rawData.length, nNeighbors);\n    const init = nnDescent.initializeSearch(this.rpForest, rawData, toTransform, nNeighbors, this.initFromRandom, this.initFromTree, this.random);\n\n    const result = this.search(rawData, this.searchGraph, init, toTransform);\n\n    let { indices, weights: distances } = heap.deheapSort(result);\n\n    indices = indices.map((x) => x.slice(0, this.nNeighbors));\n    distances = distances.map((x) => x.slice(0, this.nNeighbors));\n\n    const adjustedLocalConnectivity = Math.max(0, this.localConnectivity - 1);\n    const { sigmas, rhos } = this.smoothKNNDistance(distances, this.nNeighbors, adjustedLocalConnectivity);\n\n    const { rows, cols, vals } = this.computeMembershipStrengths(indices, distances, sigmas, rhos);\n\n    const size = [toTransform.length, rawData.length];\n    let graph = new matrix.SparseMatrix(rows, cols, vals, size);\n\n    // This was a very specially constructed graph with constant degree.\n    // That lets us do fancy unpacking by reshaping the csr matrix indices\n    // and data. Doing so relies on the constant degree assumption!\n\n    const normed = matrix.normalize(graph, matrix.NormType.l1);\n\n    const csrMatrix = matrix.getCSR(normed);\n    const nPoints = toTransform.length;\n\n    const eIndices = utils.reshape2d(csrMatrix.indices, nPoints, this.nNeighbors);\n\n    const eWeights = utils.reshape2d(csrMatrix.values, nPoints, this.nNeighbors);\n\n    const embedding = initTransform(eIndices, eWeights, this.embedding);\n\n    const nEpochs = this.nEpochs ? this.nEpochs / 3 : graph.nRows <= 10000 ? 100 : 30;\n\n    const graphMax = graph.getValues().reduce((max, val) => (val > max ? val : max), 0);\n    graph = graph.map((value) => (value < graphMax / nEpochs ? 0 : value));\n    graph = matrix.eliminateZeros(graph);\n\n    const epochsPerSample = this.makeEpochsPerSample(graph.getValues(), nEpochs);\n    const head = graph.getRows();\n    const tail = graph.getCols();\n\n    // Initialize optimization slightly differently than the fit method.\n    this.assignOptimizationStateParameters({\n      headEmbedding: embedding,\n      tailEmbedding: this.embedding,\n      head,\n      tail,\n      currentEpoch: 0,\n      nEpochs,\n      nVertices: graph.getDims()[1],\n      epochsPerSample,\n    });\n    this.prepareForOptimizationLoop();\n\n    return this.optimizeLayout();\n  }\n\n  /**\n   * Checks if we're using supervised projection, then process the graph\n   * accordingly.\n   */\n  private processGraphForSupervisedProjection() {\n    const { Y, X } = this;\n    if (Y) {\n      if (Y.length !== X.length) {\n        throw new Error('Length of X and y must be equal');\n      }\n\n      if (this.targetMetric === TargetMetric.categorical) {\n        const lt = this.targetWeight < 1.0;\n        const farDist = lt ? 2.5 * (1.0 / (1.0 - this.targetWeight)) : 1.0e12;\n        this.graph = this.categoricalSimplicialSetIntersection(this.graph, Y, farDist);\n      }\n      // TODO (andycoenen@): add non-categorical supervised embeddings.\n    }\n  }\n\n  /**\n   * Manually step through the optimization process one epoch at a time.\n   */\n  step() {\n    const { currentEpoch } = this.optimizationState;\n\n    if (currentEpoch < this.getNEpochs()) {\n      this.optimizeLayoutStep(currentEpoch);\n    }\n    return this.optimizationState.currentEpoch;\n  }\n\n  /**\n   * Returns the computed projected embedding.\n   */\n  getEmbedding() {\n    return this.embedding;\n  }\n\n  /**\n   * Compute the ``nNeighbors`` nearest points for each data point in ``X``\n   * This may be exact, but more likely is approximated via nearest neighbor\n   * descent.\n   */\n  private nearestNeighbors(X: Vectors) {\n    const { distanceFn, nNeighbors } = this;\n    const log2 = (n: number) => Math.log(n) / Math.log(2);\n    const metricNNDescent = nnDescent.makeNNDescent(distanceFn, this.random);\n\n    // Handle python3 rounding down from 0.5 discrpancy\n    const round = (n: number) => {\n      return n === 0.5 ? 0 : Math.round(n);\n    };\n\n    const nTrees = 5 + Math.floor(round(X.length ** 0.5 / 20.0));\n    const nIters = Math.max(5, Math.floor(Math.round(log2(X.length))));\n\n    this.rpForest = tree.makeForest(X, nNeighbors, nTrees, this.random);\n\n    const leafArray = tree.makeLeafArray(this.rpForest);\n    const { indices, weights } = metricNNDescent(X, leafArray, nNeighbors, nIters);\n    return { knnIndices: indices, knnDistances: weights };\n  }\n\n  /**\n   * Given a set of data X, a neighborhood size, and a measure of distance\n   * compute the fuzzy simplicial set (here represented as a fuzzy graph in\n   * the form of a sparse matrix) associated to the data. This is done by\n   * locally approximating geodesic distance at each point, creating a fuzzy\n   * simplicial set for each such point, and then combining all the local\n   * fuzzy simplicial sets into a global one via a fuzzy union.\n   */\n  private fuzzySimplicialSet(X: Vectors, nNeighbors: number, setOpMixRatio = 1.0) {\n    const { knnIndices = [], knnDistances = [], localConnectivity } = this;\n\n    const { sigmas, rhos } = this.smoothKNNDistance(knnDistances, nNeighbors, localConnectivity);\n\n    const { rows, cols, vals } = this.computeMembershipStrengths(knnIndices, knnDistances, sigmas, rhos);\n\n    const size = [X.length, X.length];\n    const sparseMatrix = new matrix.SparseMatrix(rows, cols, vals, size);\n\n    const transpose = matrix.transpose(sparseMatrix);\n    const prodMatrix = matrix.pairwiseMultiply(sparseMatrix, transpose);\n\n    const a = matrix.subtract(matrix.add(sparseMatrix, transpose), prodMatrix);\n    const b = matrix.multiplyScalar(a, setOpMixRatio);\n    const c = matrix.multiplyScalar(prodMatrix, 1.0 - setOpMixRatio);\n    const result = matrix.add(b, c);\n\n    return result;\n  }\n\n  /**\n   * Combine a fuzzy simplicial set with another fuzzy simplicial set\n   * generated from categorical data using categorical distances. The target\n   * data is assumed to be categorical label data (a vector of labels),\n   * and this will update the fuzzy simplicial set to respect that label data.\n   */\n  private categoricalSimplicialSetIntersection(simplicialSet: matrix.SparseMatrix, target: number[], farDist: number, unknownDist = 1.0) {\n    let intersection = fastIntersection(simplicialSet, target, unknownDist, farDist);\n    intersection = matrix.eliminateZeros(intersection);\n    return resetLocalConnectivity(intersection);\n  }\n\n  /**\n   * Compute a continuous version of the distance to the kth nearest\n   * neighbor. That is, this is similar to knn-distance but allows continuous\n   * k values rather than requiring an integral k. In esscence we are simply\n   * computing the distance such that the cardinality of fuzzy set we generate\n   * is k.\n   */\n  private smoothKNNDistance(distances: Vectors, k: number, localConnectivity = 1.0, nIter = 64, bandwidth = 1.0) {\n    const target = (Math.log(k) / Math.log(2)) * bandwidth;\n    const rho = utils.zeros(distances.length);\n    const result = utils.zeros(distances.length);\n\n    for (let i = 0; i < distances.length; i++) {\n      let lo = 0.0;\n      let hi = Infinity;\n      let mid = 1.0;\n\n      // TODO: This is very inefficient, but will do for now. FIXME\n      const ithDistances = distances[i];\n      const nonZeroDists = ithDistances.filter((d) => d > 0.0);\n\n      if (nonZeroDists.length >= localConnectivity) {\n        const index = Math.floor(localConnectivity);\n        const interpolation = localConnectivity - index;\n        if (index > 0) {\n          rho[i] = nonZeroDists[index - 1];\n          if (interpolation > SMOOTH_K_TOLERANCE) {\n            rho[i] += interpolation * (nonZeroDists[index] - nonZeroDists[index - 1]);\n          }\n        } else {\n          rho[i] = interpolation * nonZeroDists[0];\n        }\n      } else if (nonZeroDists.length > 0) {\n        rho[i] = utils.max(nonZeroDists);\n      }\n\n      for (let n = 0; n < nIter; n++) {\n        let psum = 0.0;\n        for (let j = 1; j < distances[i].length; j++) {\n          const d = distances[i][j] - rho[i];\n          if (d > 0) {\n            psum += Math.exp(-(d / mid));\n          } else {\n            psum += 1.0;\n          }\n        }\n\n        if (Math.abs(psum - target) < SMOOTH_K_TOLERANCE) {\n          break;\n        }\n\n        if (psum > target) {\n          hi = mid;\n          mid = (lo + hi) / 2.0;\n        } else {\n          lo = mid;\n          if (hi === Infinity) {\n            mid *= 2;\n          } else {\n            mid = (lo + hi) / 2.0;\n          }\n        }\n      }\n\n      result[i] = mid;\n\n      // TODO: This is very inefficient, but will do for now. FIXME\n      if (rho[i] > 0.0) {\n        const meanIthDistances = utils.mean(ithDistances);\n        if (result[i] < MIN_K_DIST_SCALE * meanIthDistances) {\n          result[i] = MIN_K_DIST_SCALE * meanIthDistances;\n        }\n      } else {\n        const meanDistances = utils.mean(distances.map(utils.mean));\n        if (result[i] < MIN_K_DIST_SCALE * meanDistances) {\n          result[i] = MIN_K_DIST_SCALE * meanDistances;\n        }\n      }\n    }\n\n    return { sigmas: result, rhos: rho };\n  }\n\n  /**\n   * Construct the membership strength data for the 1-skeleton of each local\n   * fuzzy simplicial set -- this is formed as a sparse matrix where each row is\n   * a local fuzzy simplicial set, with a membership strength for the\n   * 1-simplex to each other data point.\n   */\n  private computeMembershipStrengths(\n    knnIndices: Vectors,\n    knnDistances: Vectors,\n    sigmas: number[],\n    rhos: number[],\n  ): { rows: number[]; cols: number[]; vals: number[] } {\n    const nSamples = knnIndices.length;\n    const nNeighbors = knnIndices[0].length;\n\n    const rows = utils.zeros(nSamples * nNeighbors);\n    const cols = utils.zeros(nSamples * nNeighbors);\n    const vals = utils.zeros(nSamples * nNeighbors);\n\n    for (let i = 0; i < nSamples; i++) {\n      for (let j = 0; j < nNeighbors; j++) {\n        let val = 0;\n        if (knnIndices[i][j] === -1) {\n          continue; // We didn't get the full knn for i\n        }\n        if (knnIndices[i][j] === i) {\n          val = 0.0;\n        } else if (knnDistances[i][j] - rhos[i] <= 0.0) {\n          val = 1.0;\n        } else {\n          val = Math.exp(-((knnDistances[i][j] - rhos[i]) / sigmas[i]));\n        }\n\n        rows[i * nNeighbors + j] = i;\n        cols[i * nNeighbors + j] = knnIndices[i][j];\n        vals[i * nNeighbors + j] = val;\n      }\n    }\n\n    return { rows, cols, vals };\n  }\n\n  /**\n   * Initialize a fuzzy simplicial set embedding, using a specified\n   * initialisation method and then minimizing the fuzzy set cross entropy\n   * between the 1-skeletons of the high and low dimensional fuzzy simplicial\n   * sets.\n   */\n  private initializeSimplicialSetEmbedding(initialEmbedding: any) {\n    const nEpochs = this.getNEpochs();\n\n    const { nComponents } = this;\n    const graphValues = this.graph.getValues();\n    let graphMax = 0;\n    for (let i = 0; i < graphValues.length; i++) {\n      const value = graphValues[i];\n      if (graphMax < graphValues[i]) {\n        graphMax = value;\n      }\n    }\n\n    const graph = this.graph.map((value) => {\n      if (value < graphMax / nEpochs) {\n        return 0;\n      }\n      return value;\n    });\n\n    // We're not computing the spectral initialization in this implementation\n    // until we determine a better eigenvalue/eigenvector computation\n    // approach\n    if (initialEmbedding) {\n      this.embedding = initialEmbedding;\n    } else {\n      this.embedding = utils.zeros(graph.nRows).map(() => {\n        return utils.zeros(nComponents).map(() => {\n          return utils.tauRand(this.random) * 20 + -10; // Random from -10 to 10\n        });\n      });\n    }\n\n    // Get graph data in ordered way...\n    const weights: number[] = [];\n    const head: number[] = [];\n    const tail: number[] = [];\n    const rowColValues = graph.getAll();\n    for (let i = 0; i < rowColValues.length; i++) {\n      const entry = rowColValues[i];\n      if (entry.value) {\n        weights.push(entry.value);\n        tail.push(entry.row);\n        head.push(entry.col);\n      }\n    }\n    const epochsPerSample = this.makeEpochsPerSample(weights, nEpochs);\n\n    return { head, tail, epochsPerSample };\n  }\n\n  /**\n   * Given a set of weights and number of epochs generate the number of\n   * epochs per sample for each weight.\n   */\n  private makeEpochsPerSample(weights: number[], nEpochs: number) {\n    const result = utils.filled(weights.length, -1.0);\n    const max = utils.max(weights);\n    const nSamples = weights.map((w) => (w / max) * nEpochs);\n    nSamples.forEach((n, i) => {\n      if (n > 0) result[i] = nEpochs / nSamples[i];\n    });\n    return result;\n  }\n\n  /**\n   * Assigns optimization state parameters from a partial optimization state.\n   */\n  private assignOptimizationStateParameters(state: Partial<OptimizationState>) {\n    Object.assign(this.optimizationState, state);\n  }\n\n  /**\n   * Sets a few optimization state parameters that are necessary before entering\n   * the optimization step loop.\n   */\n  private prepareForOptimizationLoop() {\n    // Hyperparameters\n    const { repulsionStrength, learningRate, negativeSampleRate } = this;\n\n    const { epochsPerSample, headEmbedding, tailEmbedding } = this.optimizationState;\n\n    const dim = headEmbedding[0].length;\n    const moveOther = headEmbedding.length === tailEmbedding.length;\n\n    const epochsPerNegativeSample = epochsPerSample.map((e) => e / negativeSampleRate);\n    const epochOfNextNegativeSample = [...epochsPerNegativeSample];\n    const epochOfNextSample = [...epochsPerSample];\n\n    this.assignOptimizationStateParameters({\n      epochOfNextSample,\n      epochOfNextNegativeSample,\n      epochsPerNegativeSample,\n      moveOther,\n      initialAlpha: learningRate,\n      alpha: learningRate,\n      gamma: repulsionStrength,\n      dim,\n    });\n  }\n\n  /**\n   * Initializes optimization state for stepwise optimization.\n   */\n  private initializeOptimization() {\n    // Algorithm state\n    const headEmbedding = this.embedding;\n    const tailEmbedding = this.embedding;\n\n    // Initialized in initializeSimplicialSetEmbedding()\n    const { head, tail, epochsPerSample } = this.optimizationState;\n\n    const nEpochs = this.getNEpochs();\n    const nVertices = this.graph.nCols;\n\n    const { a, b } = findABParams(this.spread, this.minDist);\n\n    this.assignOptimizationStateParameters({\n      headEmbedding,\n      tailEmbedding,\n      head,\n      tail,\n      epochsPerSample,\n      a,\n      b,\n      nEpochs,\n      nVertices,\n    });\n  }\n\n  /**\n   * Improve an embedding using stochastic gradient descent to minimize the\n   * fuzzy set cross entropy between the 1-skeletons of the high dimensional\n   * and low dimensional fuzzy simplicial sets. In practice this is done by\n   * sampling edges based on their membership strength (with the (1-p) terms\n   * coming from negative sampling similar to word2vec).\n   */\n  private optimizeLayoutStep(n: number) {\n    const { optimizationState } = this;\n    const {\n      head,\n      tail,\n      headEmbedding,\n      tailEmbedding,\n      epochsPerSample,\n      epochOfNextSample,\n      epochOfNextNegativeSample,\n      epochsPerNegativeSample,\n      moveOther,\n      initialAlpha,\n      alpha,\n      gamma,\n      a,\n      b,\n      dim,\n      nEpochs,\n      nVertices,\n    } = optimizationState;\n\n    const clipValue = 4.0;\n\n    for (let i = 0; i < epochsPerSample.length; i++) {\n      if (epochOfNextSample[i] > n) {\n        continue;\n      }\n\n      const j = head[i];\n      const k = tail[i];\n\n      const current = headEmbedding[j];\n      const other = tailEmbedding[k];\n\n      const distSquared = rDist(current, other);\n\n      let gradCoeff = 0;\n      if (distSquared > 0) {\n        gradCoeff = -2.0 * a * b * distSquared ** (b - 1.0);\n        gradCoeff /= a * distSquared ** b + 1.0;\n      }\n\n      for (let d = 0; d < dim; d++) {\n        const gradD = clip(gradCoeff * (current[d] - other[d]), clipValue);\n        current[d] += gradD * alpha;\n        if (moveOther) {\n          other[d] += -gradD * alpha;\n        }\n      }\n\n      epochOfNextSample[i] += epochsPerSample[i];\n\n      const nNegSamples = Math.floor((n - epochOfNextNegativeSample[i]) / epochsPerNegativeSample[i]);\n\n      for (let p = 0; p < nNegSamples; p++) {\n        const k = utils.tauRandInt(nVertices, this.random);\n        const other = tailEmbedding[k];\n\n        const distSquared = rDist(current, other);\n\n        let gradCoeff = 0.0;\n        if (distSquared > 0.0) {\n          gradCoeff = 2.0 * gamma * b;\n          gradCoeff /= (0.001 + distSquared) * (a * distSquared ** b + 1);\n        } else if (j === k) {\n          continue;\n        }\n\n        for (let d = 0; d < dim; d++) {\n          let gradD = 4.0;\n          if (gradCoeff > 0.0) {\n            gradD = clip(gradCoeff * (current[d] - other[d]), clipValue);\n          }\n          current[d] += gradD * alpha;\n        }\n      }\n      epochOfNextNegativeSample[i] += nNegSamples * epochsPerNegativeSample[i];\n    }\n    optimizationState.alpha = initialAlpha * (1.0 - n / nEpochs);\n\n    optimizationState.currentEpoch += 1;\n    return headEmbedding;\n  }\n\n  /**\n   * Improve an embedding using stochastic gradient descent to minimize the\n   * fuzzy set cross entropy between the 1-skeletons of the high dimensional\n   * and low dimensional fuzzy simplicial sets. In practice this is done by\n   * sampling edges based on their membership strength (with the (1-p) terms\n   * coming from negative sampling similar to word2vec).\n   */\n  private optimizeLayoutAsync(epochCallback: (epochNumber: number) => void | boolean = () => true): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      const step = async () => {\n        try {\n          const { nEpochs, currentEpoch } = this.optimizationState;\n          this.embedding = this.optimizeLayoutStep(currentEpoch);\n          const epochCompleted = this.optimizationState.currentEpoch;\n          const shouldStop = epochCallback(epochCompleted) === false;\n          const isFinished = epochCompleted === nEpochs;\n          if (!shouldStop && !isFinished) {\n            setTimeout(() => step(), 0);\n          } else {\n            return resolve(isFinished);\n          }\n        } catch (err) {\n          reject(err);\n        }\n      };\n      setTimeout(() => step(), 0);\n    });\n  }\n\n  /**\n   * Improve an embedding using stochastic gradient descent to minimize the\n   * fuzzy set cross entropy between the 1-skeletons of the high dimensional\n   * and low dimensional fuzzy simplicial sets. In practice this is done by\n   * sampling edges based on their membership strength (with the (1-p) terms\n   * coming from negative sampling similar to word2vec).\n   */\n  private optimizeLayout(epochCallback: (epochNumber: number) => void | boolean = () => true): Vectors {\n    let isFinished = false;\n    let embedding: Vectors = [];\n    while (!isFinished) {\n      const { nEpochs, currentEpoch } = this.optimizationState;\n      embedding = this.optimizeLayoutStep(currentEpoch);\n      const epochCompleted = this.optimizationState.currentEpoch;\n      const shouldStop = epochCallback(epochCompleted) === false;\n      isFinished = epochCompleted === nEpochs || shouldStop;\n    }\n    return embedding;\n  }\n\n  /**\n   * Gets the number of epochs for optimizing the projection.\n   * NOTE: This heuristic differs from the python version\n   */\n  private getNEpochs() {\n    const { graph } = this;\n\n    if (this.nEpochs > 0) {\n      return this.nEpochs;\n    }\n\n    const length = graph.nRows;\n    if (length <= 2500) {\n      return 500;\n    }\n    if (length <= 5000) {\n      return 400;\n    }\n    if (length <= 7500) {\n      return 300;\n    }\n    return 200;\n  }\n}\n\n// https://github.com/ecto/jaccard TODO: also for tsne and other projection methods\nexport function jaccard(x: Vector, y: Vector) {\n  return jaccard_dist.index(x, y);\n}\n\nexport function euclidean(x: Vector, y: Vector) {\n  let result = 0;\n  for (let i = 0; i < x.length; i++) {\n    result += (x[i] - y[i]) ** 2;\n  }\n  return Math.sqrt(result);\n}\n\nexport function cosine(x: Vector, y: Vector) {\n  let result = 0.0;\n  let normX = 0.0;\n  let normY = 0.0;\n\n  for (let i = 0; i < x.length; i++) {\n    result += x[i] * y[i];\n    normX += x[i] ** 2;\n    normY += y[i] ** 2;\n  }\n\n  if (normX === 0 && normY === 0) {\n    return 0;\n  }\n  if (normX === 0 || normY === 0) {\n    return 1.0;\n  }\n  return 1.0 - result / Math.sqrt(normX * normY);\n}\n\n/**\n * An interface representing the optimization state tracked between steps of\n * the SGD optimization\n */\nclass OptimizationState {\n  currentEpoch = 0;\n\n  // Data tracked during optimization steps.\n  headEmbedding: number[][] = [];\n\n  tailEmbedding: number[][] = [];\n\n  head: number[] = [];\n\n  tail: number[] = [];\n\n  epochsPerSample: number[] = [];\n\n  epochOfNextSample: number[] = [];\n\n  epochOfNextNegativeSample: number[] = [];\n\n  epochsPerNegativeSample: number[] = [];\n\n  moveOther = true;\n\n  initialAlpha = 1.0;\n\n  alpha = 1.0;\n\n  gamma = 1.0;\n\n  a = 1.5769434603113077;\n\n  b = 0.8950608779109733;\n\n  dim = 2;\n\n  nEpochs = 500;\n\n  nVertices = 0;\n}\n\n/**\n * Standard clamping of a value into a fixed range\n */\nfunction clip(x: number, clipValue: number) {\n  if (x > clipValue) return clipValue;\n  if (x < -clipValue) return -clipValue;\n  return x;\n}\n\n/**\n * Reduced Euclidean distance.\n */\nfunction rDist(x: number[], y: number[]) {\n  let result = 0.0;\n  for (let i = 0; i < x.length; i++) {\n    result += (x[i] - y[i]) ** 2;\n  }\n  return result;\n}\n\n/**\n * Fit a, b params for the differentiable curve used in lower\n * dimensional fuzzy simplicial complex construction. We want the\n * smooth curve (from a pre-defined family with simple gradient) that\n * best matches an offset exponential decay.\n */\nexport function findABParams(spread: number, minDist: number) {\n  const curve =\n    ([a, b]) =>\n    (x: number) => {\n      return 1.0 / (1.0 + a * x ** (2 * b));\n    };\n\n  const xv = utils.linear(0, spread * 3, 300).map((val) => (val < minDist ? 1.0 : val));\n\n  const yv = utils.zeros(xv.length).map((val, index) => {\n    const gte = xv[index] >= minDist;\n    return gte ? Math.exp(-(xv[index] - minDist) / spread) : val;\n  });\n\n  const initialValues = [0.5, 0.5];\n  const data = { x: xv, y: yv };\n\n  // Default options for the algorithm (from github example)\n  const options = {\n    damping: 1.5,\n    initialValues,\n    gradientDifference: 10e-2,\n    maxIterations: 100,\n    errorTolerance: 10e-3,\n  };\n\n  const { parameterValues } = LM(data, curve, options);\n  const [a, b] = parameterValues as number[];\n  return { a, b };\n}\n\n/**\n * Under the assumption of categorical distance for the intersecting\n * simplicial set perform a fast intersection.\n */\nexport function fastIntersection(graph: matrix.SparseMatrix, target: number[], unknownDist = 1.0, farDist = 5.0) {\n  return graph.map((value, row, col) => {\n    if (target[row] === -1 || target[col] === -1) {\n      return value * Math.exp(-unknownDist);\n    }\n    if (target[row] !== target[col]) {\n      return value * Math.exp(-farDist);\n    }\n    return value;\n  });\n}\n\n/**\n * Reset the local connectivity requirement -- each data sample should\n * have complete confidence in at least one 1-simplex in the simplicial set.\n * We can enforce this by locally rescaling confidences, and then remerging the\n * different local simplicial sets together.\n */\nexport function resetLocalConnectivity(simplicialSet: matrix.SparseMatrix) {\n  simplicialSet = matrix.normalize(simplicialSet, matrix.NormType.max);\n  const transpose = matrix.transpose(simplicialSet);\n  const prodMatrix = matrix.pairwiseMultiply(transpose, simplicialSet);\n  simplicialSet = matrix.add(simplicialSet, matrix.subtract(transpose, prodMatrix));\n  return matrix.eliminateZeros(simplicialSet);\n}\n\n/**\n * Given indices and weights and an original embeddings\n * initialize the positions of new points relative to the\n * indices and weights (of their neighbors in the source data).\n */\nexport function initTransform(indices: number[][], weights: number[][], embedding: Vectors) {\n  const result = utils.zeros(indices.length).map((z) => utils.zeros(embedding[0].length));\n\n  for (let i = 0; i < indices.length; i++) {\n    for (let j = 0; j < indices[0].length; j++) {\n      for (let d = 0; d < embedding[0].length; d++) {\n        const a = indices[i][j];\n        result[i][d] += weights[i][j] * embedding[a][d];\n      }\n    }\n  }\n  return result;\n}\n","/**\n * @license\n *\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ==============================================================================\n */\n\nimport { RandomFn } from './umap';\n\n/**\n * Simple random integer function\n */\nexport function tauRandInt(n: number, random: RandomFn) {\n  return Math.floor(random() * n);\n}\n\n/**\n * Simple random float function\n */\nexport function tauRand(random: RandomFn) {\n  return random();\n}\n/**\n * Compute the (standard l2) norm of a vector.\n */\nexport function norm(vec: number[]) {\n  let result = 0;\n  for (const item of vec) {\n    result += item ** 2;\n  }\n  return Math.sqrt(result);\n}\n\n/**\n * Creates an empty array (filled with undefined)\n */\nexport function empty(n: number): undefined[] {\n  const output: undefined[] = [];\n  for (let i = 0; i < n; i++) {\n    output.push(undefined);\n  }\n  return output;\n}\n\n/**\n * Creates an array filled with index values\n */\nexport function range(n: number): number[] {\n  return empty(n).map((_, i) => i);\n}\n\n/**\n * Creates an array filled with a specific value\n */\nexport function filled(n: number, v: number): number[] {\n  return empty(n).map(() => v);\n}\n\n/**\n * Creates an array filled with zeros\n */\nexport function zeros(n: number): number[] {\n  return filled(n, 0);\n}\n\n/**\n * Creates an array filled with ones\n */\nexport function ones(n: number): number[] {\n  return filled(n, 1);\n}\n\n/**\n * Creates an array from a to b, of length len, inclusive\n */\nexport function linear(a: number, b: number, len: number): number[] {\n  return empty(len).map((_, i) => {\n    return a + i * ((b - a) / (len - 1));\n  });\n}\n\n/**\n * Returns the sum of an array\n */\nexport function sum(input: number[]): number {\n  return input.reduce((sum, val) => sum + val);\n}\n\n/**\n * Returns the mean of an array\n */\nexport function mean(input: number[]): number {\n  return sum(input) / input.length;\n}\n\n/**\n * Returns the maximum value of an array\n */\nexport function max(input: number[]): number {\n  let max = 0;\n  for (let i = 0; i < input.length; i++) {\n    max = input[i] > max ? input[i] : max;\n  }\n  return max;\n}\n\n/**\n * Returns the maximum value of a 2d array\n */\nexport function max2d(input: number[][]): number {\n  let max = 0;\n  for (let i = 0; i < input.length; i++) {\n    for (let j = 0; j < input[i].length; j++) {\n      max = input[i][j] > max ? input[i][j] : max;\n    }\n  }\n  return max;\n}\n\n/**\n * Generate nSamples many integers from 0 to poolSize such that no\n * integer is selected twice. The duplication constraint is achieved via\n * rejection sampling.\n */\nexport function rejectionSample(nSamples: number, poolSize: number, random: RandomFn): number[] {\n  const result = zeros(nSamples);\n  for (let i = 0; i < nSamples; i++) {\n    let rejectSample = true;\n    while (rejectSample) {\n      const j = tauRandInt(poolSize, random);\n      let broken = false;\n      for (let k = 0; k < i; k++) {\n        if (j === result[k]) {\n          broken = true;\n          break;\n        }\n      }\n      if (!broken) {\n        rejectSample = false;\n      }\n      result[i] = j;\n    }\n  }\n  return result;\n}\n\n/**\n * Reshapes a 1d array into a 2D of given dimensions.\n */\nexport function reshape2d<T>(x: T[], a: number, b: number): T[][] {\n  const rows: T[][] = [];\n  let count = 0;\n  let index = 0;\n\n  if (x.length !== a * b) {\n    throw new Error('Array dimensions must match input length.');\n  }\n\n  for (let i = 0; i < a; i++) {\n    const col: T[] = [];\n    for (let j = 0; j < b; j++) {\n      col.push(x[index]);\n      index += 1;\n    }\n    rows.push(col);\n    count += 1;\n  }\n  return rows;\n}\n","export enum DistanceMetric {\n  EUCLIDEAN = 'euclidean',\n  JACCARD = 'jaccard',\n  GOWER = 'gower',\n  COSINE = 'cosine',\n  MANHATTAN = 'manhattan',\n}\n","/**\n * The data type of a feature\n */\nexport enum FeatureType {\n  /**\n   * Means all values have no other group they belong to\n   */\n  String = 'String',\n\n  /**\n   * Means all values are real numbers e.g. 0.23, 0.13, 1, 2...\n   */\n  Quantitative = 'Quantitative',\n\n  /**\n   * Means the values represent groups\n   */\n  Categorical = 'Categorical',\n\n  /**\n   * Means all values are date timestamps\n   */\n  Date = 'Date',\n\n  /**\n   * Means there exist only 2 groups (stricter than categorical)\n   */\n  Binary = 'Binary',\n\n  Ordinal = 'Ordinal',\n\n  /**\n   * Means all values are arrays of other values.\n   */\n  Array = 'Array',\n}\n"],"names":["jaccard_dist","DistanceMetric","FeatureType","gower","featureTypes","x","y","result","i","length","Quantitative","Math","abs","Binary","Categorical","Ordinal","jaccard","distance","euclidean","sqrt","manhattan","cosine","normX","normY","get_distance_fn","distanceMetric","e","EUCLIDEAN","JACCARD","MANHATTAN","COSINE","GOWER","data","utils","makeHeap","nPoints","size","makeArrays","fillValue","empty","map","filled","heap","push","Infinity","rejectionSample","nSamples","poolSize","random","zeros","rejectSample","j","tauRandInt","broken","k","heapPush","row","weight","index","flag","floor","indices","weights","isNew","uncheckedHeapPush","iSwap","ic1","ic2","heapShape2","buildCandidates","currentGraph","nVertices","nNeighbors","maxCandidates","candidateNeighbors","idx","isn","d","tauRand","deheapSort","indHeap","distHeap","indHeapIndex","distHeapIndex","temp1","temp2","siftDown","heap1","heap2","ceiling","elt","leftChild","rightChild","swap","smallestFlagged","ind","dist","minDist","resultIndex","SparseMatrix","rows","cols","values","dims","Map","Error","nRows","nCols","col","checkDims","key","makeKey","entries","set","value","withinBounds","has","get","defaultValue","ordered","rowColValues","forEach","sort","a","b","Array","from","fn","vals","getRows","getCols","output","transpose","matrix","identity","pairwiseMultiply","elementWise","add","subtract","maximum","multiplyScalar","scalar","eliminateZeros","m","zeroIndices","Set","getValues","removeByZeroIndex","_","nextValues","filter","nextRows","nextCols","getDims","normalize","normType","normFn","normFns","colsByRow","nextMatrix","keys","norm","xs","max","sum","op","visited","operate","nextValue","valuesA","rowsA","colsA","valuesB","rowsB","colsB","getCSR","indptr","currentRow","tree","makeNNDescent","distanceFn","nNDescent","leafArray","nIters","delta","rho","rpTreeInit","n","c","p","q","cj","ck","sorted","makeInitializations","initFromRandom","queryPoints","_heap","initFromTree","_tree","searchFlatTree","makeInitializedNNSearch","nnSearchFn","graph","initialization","tried","vertex","candidates","slice","candidate","initializeSearch","forest","results","FlatTree","hyperplanes","offsets","children","makeForest","nTrees","leafSize","trees","range","makeTree","flattenTree","makeEuclideanTree","splitResults","euclideanRandomProjectionSplit","indicesLeft","indicesRight","hyperplane","offset","node","isLeaf","dim","leftIndex","rightIndex","left","right","hyperplaneOffset","hyperplaneVector","nLeft","nRight","side","margin","nNodes","numNodes","nLeaves","numLeaves","recursiveFlatten","nodeNum","leafNum","splice","oldNodeNum","res","makeLeafArray","rpForest","selectSide","point","LM","nnDescent","SMOOTH_K_TOLERANCE","MIN_K_DIST_SCALE","UMAP","params","OptimizationState","setParam","undefined","X","initialEmbedding","initializeFit","optimizeLayout","embedding","callback","optimizeLayoutAsync","Y","targetMetric","targetWeight","targetNNeighbors","knnIndices","knnDistances","isInitialized","getNEpochs","knnResults","nearestNeighbors","fuzzySimplicialSet","setOpMixRatio","makeSearchFns","searchGraph","makeSearchGraph","processGraphForSupervisedProjection","initializeSimplicialSetEmbedding","head","tail","epochsPerSample","optimizationState","initializeOptimization","prepareForOptimizationLoop","search","knn","distances","neighbor","toTransform","rawData","transformQueueSize","min","init","adjustedLocalConnectivity","localConnectivity","smoothKNNDistance","sigmas","rhos","computeMembershipStrengths","normed","csrMatrix","eIndices","reshape2d","eWeights","initTransform","nEpochs","graphMax","reduce","val","makeEpochsPerSample","assignOptimizationStateParameters","headEmbedding","tailEmbedding","currentEpoch","lt","farDist","categoricalSimplicialSetIntersection","optimizeLayoutStep","log2","log","metricNNDescent","round","sparseMatrix","prodMatrix","simplicialSet","target","unknownDist","intersection","fastIntersection","resetLocalConnectivity","nIter","bandwidth","lo","hi","mid","ithDistances","nonZeroDists","interpolation","psum","exp","meanIthDistances","mean","meanDistances","nComponents","graphValues","getAll","entry","w","state","Object","assign","repulsionStrength","learningRate","negativeSampleRate","moveOther","epochsPerNegativeSample","epochOfNextNegativeSample","epochOfNextSample","initialAlpha","alpha","gamma","findABParams","spread","clipValue","current","other","distSquared","rDist","gradCoeff","gradD","clip","nNegSamples","epochCallback","Promise","resolve","reject","step","epochCompleted","shouldStop","isFinished","setTimeout","curve","xv","linear","yv","gte","initialValues","options","damping","gradientDifference","maxIterations","errorTolerance","parameterValues","z","vec","item","v","ones","len","input","max2d","count"],"sourceRoot":""}