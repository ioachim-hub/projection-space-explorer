{"version":3,"sources":["webpack://PSE/webpack/bootstrap","webpack://PSE/./node_modules/async/dist/async.mjs","webpack://PSE/./src/components/workers/embeddings/umap.worker.ts","webpack://PSE/./node_modules/is-any-array/src/index.js","webpack://PSE/./node_modules/jaccard/jaccard.js","webpack://PSE/./node_modules/ml-array-max/lib-es6/index.js","webpack://PSE/./node_modules/ml-array-max/node_modules/is-any-array/src/index.js","webpack://PSE/./node_modules/ml-array-min/lib-es6/index.js","webpack://PSE/./node_modules/ml-array-min/node_modules/is-any-array/src/index.js","webpack://PSE/./node_modules/ml-array-rescale/lib-es6/index.js","webpack://PSE/./node_modules/ml-array-rescale/node_modules/is-any-array/src/index.js","webpack://PSE/./node_modules/ml-levenberg-marquardt/src/errorCalculation.js","webpack://PSE/./node_modules/ml-levenberg-marquardt/src/index.js","webpack://PSE/./node_modules/ml-levenberg-marquardt/src/step.js","webpack://PSE/./node_modules/ml-matrix/src/correlation.js","webpack://PSE/./node_modules/ml-matrix/src/covariance.js","webpack://PSE/./node_modules/ml-matrix/src/dc/cholesky.js","webpack://PSE/./node_modules/ml-matrix/src/dc/evd.js","webpack://PSE/./node_modules/ml-matrix/src/dc/lu.js","webpack://PSE/./node_modules/ml-matrix/src/dc/nipals.js","webpack://PSE/./node_modules/ml-matrix/src/dc/qr.js","webpack://PSE/./node_modules/ml-matrix/src/dc/svd.js","webpack://PSE/./node_modules/ml-matrix/src/dc/util.js","webpack://PSE/./node_modules/ml-matrix/src/decompositions.js","webpack://PSE/./node_modules/ml-matrix/src/determinant.js","webpack://PSE/./node_modules/ml-matrix/src/index.js","webpack://PSE/./node_modules/ml-matrix/src/inspect.js","webpack://PSE/./node_modules/ml-matrix/src/linearDependencies.js","webpack://PSE/./node_modules/ml-matrix/src/mathOperations.js","webpack://PSE/./node_modules/ml-matrix/src/matrix.js","webpack://PSE/./node_modules/ml-matrix/src/pseudoInverse.js","webpack://PSE/./node_modules/ml-matrix/src/stat.js","webpack://PSE/./node_modules/ml-matrix/src/util.js","webpack://PSE/./node_modules/ml-matrix/src/views/base.js","webpack://PSE/./node_modules/ml-matrix/src/views/column.js","webpack://PSE/./node_modules/ml-matrix/src/views/columnSelection.js","webpack://PSE/./node_modules/ml-matrix/src/views/flipColumn.js","webpack://PSE/./node_modules/ml-matrix/src/views/flipRow.js","webpack://PSE/./node_modules/ml-matrix/src/views/index.js","webpack://PSE/./node_modules/ml-matrix/src/views/row.js","webpack://PSE/./node_modules/ml-matrix/src/views/rowSelection.js","webpack://PSE/./node_modules/ml-matrix/src/views/selection.js","webpack://PSE/./node_modules/ml-matrix/src/views/sub.js","webpack://PSE/./node_modules/ml-matrix/src/views/transpose.js","webpack://PSE/./node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js","webpack://PSE/./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js","webpack://PSE/./node_modules/ml-matrix/src/wrap/wrap.js","webpack://PSE/./node_modules/regenerator-runtime/runtime.js","webpack://PSE/./src/components/Utility/UMAP/heap.ts","webpack://PSE/./src/components/Utility/UMAP/index.ts","webpack://PSE/./src/components/Utility/UMAP/matrix.ts","webpack://PSE/./src/components/Utility/UMAP/nn_descent.ts","webpack://PSE/./src/components/Utility/UMAP/tree.ts","webpack://PSE/./src/components/Utility/UMAP/umap.ts","webpack://PSE/./src/components/Utility/UMAP/utils.ts"],"names":["Object","defineProperty","exports","value","UMAP_1","require","umap_1","self","addEventListener","e","context","data","messageType","raw","umap","UMAP","nNeighbors","params","distanceFn","distanceMetric","euclidean","jaccard","initializeFit","input","seeded","seed","undefined","step","postMessage","getEmbedding","default","smallestFlagged","deheapSort","buildCandidates","uncheckedHeapPush","heapPush","rejectionSample","makeHeap","utils","nPoints","size","makeArrays","fillValue","empty","map","filled","heap","push","Infinity","nSamples","poolSize","random","result","zeros","i","rejectSample","j","tauRandInt","broken","k","row","weight","index","flag","Math","floor","indices","weights","isNew","length","iSwap","ic1","ic2","heapShape2","currentGraph","nVertices","maxCandidates","candidateNeighbors","idx","isn","d","tauRand","indHeap","distHeap","indHeapIndex","distHeapIndex","temp1","temp2","siftDown","heap1","heap2","ceiling","elt","leftChild","rightChild","swap","ind","dist","minDist","resultIndex","enumerable","get","getCSR","normalize","eliminateZeros","multiplyScalar","maximum","subtract","add","pairwiseMultiply","identity","transpose","SparseMatrix","rows","cols","values","dims","entries","Map","nRows","nCols","Error","col","checkDims","key","makeKey","set","withinBounds","has","defaultValue","ordered","rowColValues","forEach","sort","a","b","Array","from","fn","vals","getRows","getCols","output","matrix","elementWise","x","y","scalar","m","zeroIndices","Set","getValues","removeByZeroIndex","_","nextValues","filter","nextRows","nextCols","getDims","normType","normFn","normFns","colsByRow","nextMatrix","keys","norm","xs","max","sum","sqrt","op","visited","operate","nextValue","valuesA","rowsA","colsA","valuesB","rowsB","colsB","indptr","currentRow","initializeSearch","makeInitializedNNSearch","makeInitializations","makeNNDescent","tree","nNDescent","leafArray","nIters","delta","rho","rpTreeInit","n","c","p","q","cj","ck","sorted","initFromRandom","queryPoints","_heap","initFromTree","_tree","searchFlatTree","nnSearchFn","graph","initialization","tried","vertex","candidates","slice","candidate","forest","results","makeLeafArray","makeForest","FlatTree","hyperplanes","offsets","children","nTrees","leafSize","trees","range","makeTree","flattenTree","makeEuclideanTree","splitResults","euclideanRandomProjectionSplit","indicesLeft","indicesRight","hyperplane","offset","node","isLeaf","dim","leftIndex","rightIndex","left","right","hyperplaneOffset","hyperplaneVector","nLeft","nRight","side","margin","nNodes","numNodes","nLeaves","numLeaves","recursiveFlatten","nodeNum","leafNum","splice","oldNodeNum","res","rpForest","selectSide","point","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","next","rejected","done","then","apply","initTransform","resetLocalConnectivity","fastIntersection","findABParams","cosine","nnDescent","ml_levenberg_marquardt_1","SMOOTH_K_TOLERANCE","MIN_K_DIST_SCALE","learningRate","localConnectivity","nComponents","nEpochs","negativeSampleRate","repulsionStrength","setOpMixRatio","spread","transformQueueSize","targetMetric","targetWeight","targetNNeighbors","isInitialized","embedding","optimizationState","OptimizationState","setParam","X","initialEmbedding","optimizeLayout","callback","optimizeLayoutAsync","Y","knnIndices","knnDistances","getNEpochs","knnResults","nearestNeighbors","fuzzySimplicialSet","makeSearchFns","searchGraph","makeSearchGraph","processGraphForSupervisedProjection","initializeSimplicialSetEmbedding","head","tail","epochsPerSample","initializeOptimization","prepareForOptimizationLoop","search","knn","distances","neighbor","distance","toTransform","rawData","min","init","adjustedLocalConnectivity","smoothKNNDistance","sigmas","rhos","computeMembershipStrengths","normed","csrMatrix","eIndices","reshape2d","eWeights","graphMax","reduce","val","makeEpochsPerSample","assignOptimizationStateParameters","headEmbedding","tailEmbedding","currentEpoch","lt","farDist","categoricalSimplicialSetIntersection","optimizeLayoutStep","log2","log","metricNNDescent","round","sparseMatrix","prodMatrix","simplicialSet","target","unknownDist","intersection","nIter","bandwidth","lo","hi","mid","ithDistances","nonZeroDists","interpolation","psum","exp","abs","meanIthDistances","mean","meanDistances","graphValues","getAll","entry","w","state","assign","moveOther","epochsPerNegativeSample","epochOfNextNegativeSample","epochOfNextSample","initialAlpha","alpha","gamma","clipValue","current","other","distSquared","rDist","gradCoeff","pow","gradD","clip","nNegSamples","epochCallback","epochCompleted","shouldStop","isFinished","setTimeout","jaccard_dist","normX","normY","curve","xv","linear","yv","gte","initialValues","options","damping","gradientDifference","maxIterations","errorTolerance","parameterValues","z","max2d","ones","vec","item","v","len","count"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,KAAK;AAChB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,8BAA8B,oBAAoB;AAClD,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL,6BAA6B,UAAU;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,UAAU,gBAAgB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,6BAA6B;AAC7B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,eAAe;AACf;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC,wBAAwB,oBAAoB;AAC3F;AACA,WAAW,KAAK;AAChB;AACA,WAAW,SAAS;AACpB;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,WAAW,oCAAoC,wBAAwB,oBAAoB;AAC3F;AACA,WAAW,KAAK;AAChB;AACA,WAAW,SAAS;AACpB;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,IAAI,oBAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,SAAS;AACpB;AACA,gEAAgE;AAChE;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,2BAA2B,sDAAsD;AACjF,QAAQ;AACR,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,2BAA2B;AAC3B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,2BAA2B,sDAAsD;AACjF,QAAQ;AACR,IAAI;AACJ;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,2BAA2B;AAC3B;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mCAAmC,sDAAsD;AACzF,gBAAgB;AAChB,YAAY;AACZ;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA,2EAA2E;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD,8BAA8B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8BAA8B;AACtE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,WAAW,OAAO,oDAAoD,oBAAoB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,2BAA2B,8CAA8C;AACzE;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,2BAA2B,8CAA8C;AACzE,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,OAAO;AACpD;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,OAAO;AAClB,gDAAgD;AAChD;AACA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,eAAe,YAAY;AAC3B;AACA,IAAI;AACJ,eAAe,YAAY;AAC3B;AACA,IAAI;AACJ,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,OAAO;AAClB,gDAAgD;AAChD;AACA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,YAAY;AAChC;AACA,IAAI;AACJ,oBAAoB,YAAY;AAChC;AACA,IAAI;AACJ,oBAAoB,YAAY;AAChC;AACA,IAAI;AACJ,oBAAoB,YAAY;AAChC;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,EAAE;AACb,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,WAAW,iBAAiB;AAC5B,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,8BAA8B,wCAAwC;AACtE,YAAY;AACZ,8BAA8B,kDAAkD;AAChF;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,WAAW,oCAAoC;AAC/C,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,mCAAmC;AACtF,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,wCAAwC,gCAAgC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,qBAAqB,kCAAkC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,8BAA8B;AACtD;AACA,8BAA8B,8BAA8B;AAC5D;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,QAAQ;AACR,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,WAAW,oCAAoC;AAC/C,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC,SAAS;AACT,KAAK;AACL;AACA;AACA,aAAa,eAAe;;AAE5B,uBAAuB,uBAAuB;AAC9C;AACA,qBAAqB,IAAI;AACzB,qBAAqB,IAAI;;AAEzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;;AAEA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,WAAW,SAAS;AACpB;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2BAA2B;AACxD;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,qBAAqB,oBAAoB;AACzC;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA,IAAI;AACJ;AACA,gCAAgC;AAChC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA,IAAI;AACJ;AACA,gCAAgC;AAChC,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,gBAAgB;AAChB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,gBAAgB;AAChB;AACA;AACA;AACA,oBAAoB;AACpB;AACA,YAAY;AACZ;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,WAAW,oCAAoC;AAC/C,qBAAqB,oBAAoB;AACzC;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,OAAO;AACrB;AACA;AACA,cAAc,OAAO;AACrB;AACA,WAAW,+BAA+B;AAC1C,cAAc,cAAc;AAC5B;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA,cAAc,cAAc;AAC5B;AACA,cAAc,cAAc;AAC5B;AACA,cAAc,SAAS;AACvB;AACA;AACA,mBAAmB,uCAAuC;AAC1D;AACA,eAAe,eAAe,IAAI;AAClC,cAAc,SAAS;AACvB;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,WAAW,YAAY;AACvB;AACA,IAAI;AACJ;AACA,WAAW,YAAY;AACvB;AACA;AACA,YAAY,YAAY,EAAE,YAAY,EAAE,YAAY;AACpD;AACA,IAAI;AACJ;AACA;AACA,cAAc,YAAY;AAC1B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gDAAgD,QAAQ;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM,+CAA+C;AAChE;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,gCAAgC;AACtD;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,WAAW,sBAAsB;AACjC,qBAAqB,oBAAoB;AACzC,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,oCAAoC;AAC/C,WAAW,SAAS;AACpB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,oCAAoC;AAC/C,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,oCAAoC;AAC/C,WAAW,SAAS;AACpB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,WAAW,cAAc,UAAU,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,iCAAiC,+BAA+B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,WAAW,cAAc,UAAU,sBAAsB;AACzD;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,qBAAqB,oBAAoB;AACzC;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,IAAI;AACJ;AACA,gCAAgC;AAChC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,IAAI;AACJ;AACA,gCAAgC;AAChC,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,YAAY;AACZ;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA,WAAW,SAAS,4BAA4B,6BAA6B;AAC7E,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA,WAAW,SAAS,iBAAiB,6BAA6B;AAClE,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA,WAAW,SAAS,iBAAiB,6BAA6B;AAClE,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,EAAE;AACb;AACA,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,eAAe;AACf;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kCAAkC;AAClC,SAAS;AACT,KAAK;AACL;;AAEA;;AAEA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,WAAW,cAAc;AACzB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB,EAAE;AACjD;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM,uCAAuC;AACxD;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kGAAkG;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,4BAA4B;AAC5E;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,oEAAK,EAAC;AACq/D;;;;;;;;;;;;;ACzxL7/D;;AACbA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,OAAK,EAAE;AAAT,CAA7C;;AACA,IAAMC,MAAM,GAAGC,mBAAO,CAAC,kEAAD,CAAtB;;AACAA,mBAAO,CAAC,kFAAD,CAAP;;AACA,IAAMC,MAAM,GAAGD,mBAAO,CAAC,sEAAD,CAAtB;AACA;AACA;AACA;;;AACAE,IAAI,CAACC,gBAAL,CAAsB,SAAtB,EAAiC,UAAUC,CAAV,EAAa;AAC1C,MAAIC,OAAO,GAAGH,IAAd;;AACA,MAAIE,CAAC,CAACE,IAAF,CAAOC,WAAP,IAAsB,MAA1B,EAAkC;AAC9BF,WAAO,CAACG,GAAR,GAAcJ,CAAC,CAACE,IAAhB;AACAD,WAAO,CAACI,IAAR,GAAe,IAAIV,MAAM,CAACW,IAAX,CAAgB;AAC3BC,gBAAU,EAAEP,CAAC,CAACE,IAAF,CAAOM,MAAP,CAAcD,UADC;AAE3BE,gBAAU,EAAET,CAAC,CAACE,IAAF,CAAOM,MAAP,CAAcE,cAAd,IAAgC,WAAhC,GAA8Cb,MAAM,CAACc,SAArD,GAAiEd,MAAM,CAACe;AAFzD,KAAhB,CAAf;AAIAX,WAAO,CAACI,IAAR,CAAaQ,aAAb,CAA2Bb,CAAC,CAACE,IAAF,CAAOY,KAAlC,EAAyCd,CAAC,CAACE,IAAF,CAAOM,MAAP,CAAcO,MAAd,GAAuBf,CAAC,CAACE,IAAF,CAAOc,IAA9B,GAAqCC,SAA9E;AACAhB,WAAO,CAACI,IAAR,CAAaa,IAAb;AACAjB,WAAO,CAACkB,WAAR,CAAoBlB,OAAO,CAACI,IAAR,CAAae,YAAb,EAApB;AACH,GATD,MAUK;AACDnB,WAAO,CAACI,IAAR,CAAaa,IAAb;AACAjB,WAAO,CAACkB,WAAR,CAAoBlB,OAAO,CAACI,IAAR,CAAae,YAAb,EAApB;AACH;AACJ,CAhBD,EAgBG,KAhBH;AAiBA3B,OAAO,CAAC4B,OAAR,GAAkB,IAAlB,C;;;;;;;;;;;;ACzBA;AAAA;AAAA;;AAEe;AACf;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,kDAAO;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1FA;AAAA;AAAmC;;AAEnC;AACA;;AAEA,OAAO,4DAAO;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,6BAA6B,aAAa;AAC1C;AACA;;AAEA;AACA;;AAEe,kEAAG,EAAC;;;;;;;;;;;;;ACnCnB;AAAA;AAAA;;AAEe;AACf;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAmC;;AAEnC;AACA;;AAEA,OAAO,4DAAO;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,6BAA6B,aAAa;AAC1C;AACA;;AAEA;AACA;;AAEe,kEAAG,EAAC;;;;;;;;;;;;;ACnCnB;AAAA;AAAA;;AAEe;AACf;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAmC;AACJ;AACA;;AAE/B;AACA;;AAEA,OAAO,4DAAO;AACd;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,SAAS,4DAAO;AAChB;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,mBAAmB,4DAAG;AACtB,mBAAmB,4DAAG;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;;AAE8B;;;;;;;;;;;;;AClD9B;AAAA;AAAA;;AAEe;AACf;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB,YAAY;AACZ;AACe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAAmC;;AAEe;AACxB;;AAE1B;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACe;AACf;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH,KAAK,4DAAO;AACZ;AACA,KAAK,4DAAO;AACZ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,OAAO,4DAAO;AACd;AACA;;AAEA,cAAc,iEAAgB;;AAE9B;;AAEA;AACA,qBAAqB,yCAAyC;AAC9D,iBAAiB,qDAAI;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;;AAEA,YAAY,iEAAgB;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChGA;AAAA;AAAA;AAA4C;;AAE5C;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA,aAAa,gDAAM;AACnB;;AAEA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA,qBAAqB,WAAW;AAChC;AACA;;AAEA,aAAa,gDAAM;AACnB;;AAEA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAM;;AAEvB;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAO;AAC7B;AACA;;AAEA,eAAe,gDAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAA8B;;AAEvB,6DAA6D;AACpE,gBAAgB,+CAAM;AACtB;AACA;AACA;AACA,KAAK,+CAAM;AACX;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,+CAAM;AACxB;AACA;AACA;AACA;;AAEA,SAAS,8BAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,iBAAiB;AACpE;AACA;AACA,2CAA2C,iBAAiB;;AAE5D;AACA,iBAAiB,eAAe;AAChC,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAA8B;;AAEvB,4DAA4D;AACnE,gBAAgB,+CAAM;AACtB;AACA;AACA;AACA,KAAK,+CAAM;AACX;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,+CAAM;AACxB;AACA;AACA;AACA;AACA,SAAS,gBAAgB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AAAA;AAA+B;AACuB;;AAEvC;AACf;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,+CAAM;AACtB;AACA;;AAEA,eAAe,eAAe;AAC9B;AACA,iBAAiB,OAAO;AACxB;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,6DAAe;;AAE3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,eAAe;AAC9B,iBAAiB,WAAW;AAC5B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC,iBAAiB,WAAW;AAC5B,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AAA+B;AACuB;;AAElB;;AAErB;AACf,kCAAkC;AAClC,WAAW,0BAA0B;;AAErC,aAAa,6DAAe;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,+CAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,+CAAM;AACxB;AACA,iBAAiB,OAAO;AACxB,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA,iBAAiB,QAAQ;AACzB;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,eAAe;AAClC;AACA,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA,sBAAsB,QAAQ;AAC9B;AACA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA,iBAAiB,WAAW;AAC5B;AACA,sBAAsB,QAAQ;AAC9B;AACA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA,qBAAqB,WAAW;AAChC;AACA;;AAEA,iBAAiB,WAAW;AAC5B;AACA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA,gCAAgC,QAAQ;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA,kBAAkB,UAAU;AAC5B,iBAAiB,WAAW;AAC5B;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChyBA;AAAA;AAAA;AAAA;AAA+B;AACuB;;AAEvC;AACf;AACA,aAAa,6DAAe;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,UAAU;AACzB;AACA;;AAEA;;AAEA,eAAe,aAAa;AAC5B,iBAAiB,UAAU;AAC3B;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,+CAAM;;AAElB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,aAAa;AAC5B,qBAAqB,aAAa;AAClC,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC,iBAAiB,WAAW;AAC5B;AACA;AACA,iBAAiB,OAAO;AACxB,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,mBAAmB,UAAU;AAC7B,qBAAqB,aAAa;AAClC;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,mBAAmB,UAAU;AAC7B,qBAAqB,aAAa;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC1KA;AAAA;AAAA;AAAA;AAA+B;AACuB;;AAEvC;AACf,6BAA6B;AAC7B,QAAQ,6DAAe;AACvB,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,YAAY,+CAAM;AAClB,OAAO;AACP,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrFA;AAAA;AAAA;AAAA;AAAA;AAA+B;AACuB;;AAElB;;AAErB;AACf;AACA,YAAY,6DAAe;;AAE3B;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA,iBAAiB,OAAO;AACxB,cAAc,wDAAU;AACxB;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,+CAAM;;AAElB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB,iBAAiB,WAAW;AAC5B;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,iBAAiB,WAAW;AAC5B;AACA;AACA,iBAAiB,OAAO;AACxB,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB;;AAEA,yBAAyB,QAAQ;AACjC,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;;AAEA;;AAEA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpJA;AAAA;AAAA;AAAA;AAAA;AAA+B;AACuB;;AAElB;;AAErB;AACf,iCAAiC;AACjC,YAAY,6DAAe;;AAE3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,gBAAgB,+CAAM;;AAEtB;AACA;;AAEA;AACA,mBAAmB,QAAQ;;AAE3B;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA,uBAAuB,OAAO;AAC9B,iBAAiB,wDAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,OAAO;AAClC,iBAAiB,wDAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA,6BAA6B,OAAO;AACpC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,QAAQ;AAC/B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA,6BAA6B,QAAQ;AACrC;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA,SAAS;AACT,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,QAAQ;AACjC;AACA,6BAA6B,OAAO;AACpC;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAC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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AAAkD;AACpB;;AAE9B;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,gDAAgD;AACvD,SAAS,mDAAmD;AAC5D,WAAW,+CAAM;;AAEjB;AACA,oBAAoB,+CAAM;;AAE1B,iBAAiB,OAAO;AACxB,YAAY,+CAAM;AAClB;AACA,kBAAkB,+CAA0B;AAC5C;AACA,gBAAgB,+CAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;;AAE6B;AACX;AAoBzC;AASA;;AAET;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA,mBAAmB,UAAU;AAC7B,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;AACA;AACA,WAAW,4CAA4C;AACvD;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,eAAe;AACpC,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,2DAAa;AACjB;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,2DAAa;AACjB,YAAY,4DAAc;AAC1B,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA,IAAI,2DAAa;AACjB,IAAI,2DAAa;AACjB,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,8DAAgB;AACpB;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,8DAAgB;AACpB,YAAY,+DAAiB;AAC7B,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA,IAAI,8DAAgB;AACpB,IAAI,8DAAgB;AACpB,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,4DAAc;AAC3B,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,4DAAc;AAC3B,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,4DAAc;AAC3B,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,4DAAc;AAC3B,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,+DAAiB;AAC9B,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,+DAAiB;AAC9B,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,+DAAiB;AAC9B,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,+DAAiB;AAC9B,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,2DAAa;AACjB,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA,IAAI,8DAAgB;AACpB,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,2DAAa;AACjB;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,2DAAa;AACjB;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,2DAAa;AACjB;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,2DAAa;AACjB,IAAI,2DAAa;AACjB;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,2DAAa;AACjB;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,2DAAa;AACjB,IAAI,2DAAa;AACjB;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,8DAAgB;AACpB;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,8DAAgB;AACpB,IAAI,2DAAa;AACjB;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,8DAAgB;AACpB;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,8DAAgB;AACpB,IAAI,2DAAa;AACjB;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,eAAe;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL,iDAAiD,KAAK;AACtD;AACA;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA,uBAAuB,OAAO;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG,KAAK,GAAG,OAAO,GAAG,KAAK,GAAG;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA,QAAQ,gEAAO,OAAO,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA,QAAQ,gEAAO;AACf;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B,uBAAuB,OAAO;AAC9B,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA,IAAI,wDAAU;AACd;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,oBAAoB;AACvC,+BAA+B,gBAAgB;AAC/C;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,oBAAoB;AACvC,4BAA4B,aAAa;AACzC;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wDAAU;AACd,mBAAmB,iBAAiB;AACpC,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,0DAAY;AAC9B;AACA,mBAAmB,wBAAwB;AAC3C;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,iBAAiB;AACtC,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,sDAAQ;AACvB;AACA,eAAe,yDAAW;AAC1B;AACA,eAAe,oDAAM;AACrB;AACA,2CAA2C,GAAG;AAC9C;AACA;;AAEA;AACA;AACA;AACA,eAAe,0DAAY;AAC3B;AACA,eAAe,6DAAe;AAC9B;AACA,eAAe,wDAAU;AACzB;AACA,2CAA2C,GAAG;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,GAAG;AAC9C;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAW;AAC1B;AACA;AACA,2CAA2C,GAAG;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAS;AACjB;AACA;AACA;AACA,2CAA2C,GAAG;AAC9C;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAa;AAC/B,SAAS;AACT;AACA;AACA,QAAQ,wDAAU;AAClB;AACA;AACA;AACA;AACA,kBAAkB,8DAAgB;AAClC,SAAS;AACT;AACA;AACA,QAAQ,2DAAa;AACrB;AACA;AACA;AACA;AACA,kBAAkB,yDAAW;AAC7B,SAAS;AACT;AACA;AACA,QAAQ,sDAAQ;AAChB;AACA;AACA;AACA,2CAA2C,GAAG;AAC9C;AACA;;AAEA;AACA,WAAW,yEAAwB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,sDAAa;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,2DAAa;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAa;AACjB,8BAA8B,4DAAc;AAC5C;AACA;AACA;AACA;;AAEA;AACA,IAAI,8DAAgB;AACpB,mBAAmB,eAAe;AAClC;AACA,qBAAqB,WAAW;AAChC;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAgB;AACpB,YAAY,+DAAiB;AAC7B,mBAAmB,eAAe;AAClC;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6EAAqB;;;;;;;;;;;;;AC/iDrB;AAAA;AAAA;AAAA;AAA2B;AACG;;AAEvB;AACP,WAAW,+CAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAG,UAAU,sBAAsB;;AAE3D;AACA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,gBAAgB,+CAAM;AACtB;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;;AAE3B;AACP,YAAY,sDAAQ;AACpB,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEO;AACP,YAAY,sDAAQ;AACpB,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEO;AACP,YAAY,sDAAQ;AACpB,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEO;AACP,YAAY,sDAAQ;AACpB,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEO;AACP,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;AAEO;AACP,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;AAEO;AACP,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;AAEO;AACP;AACA,iBAAiB,iBAAiB;AAClC;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;AAEO;AACP;AACA,iBAAiB,oBAAoB;AACrC;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,iBAAiB,oBAAoB;AACrC,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEO;AACP,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;;;;;;;;;;;;ACnNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY;AACZ,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY;AACZ,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;;AAEO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;ACtJA;AAAA;AAAA;AAA2C;;AAE5B,uBAAuB,sDAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAA2C;;AAEb;;AAEf,+BAA+B,6CAAQ;AACtD;AACA,IAAI,8DAAgB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAA6C;;AAEf;;AAEf,wCAAwC,6CAAQ;AAC/D;AACA,oBAAoB,gEAAkB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAA8B;;AAEf,mCAAmC,6CAAQ;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAA8B;;AAEf,gCAAgC,6CAAQ;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuD;AACkB;AACV;AACN;AACR;AACkB;AACN;AACZ;AACY;;;;;;;;;;;;;ACR7D;AAAA;AAAA;AAAA;AAAwC;;AAEV;;AAEf,4BAA4B,6CAAQ;AACnD;AACA,IAAI,2DAAa;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAA0C;;AAEZ;;AAEf,qCAAqC,6CAAQ;AAC5D;AACA,iBAAiB,6DAAe;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAuC;;AAET;;AAEf,kCAAkC,6CAAQ;AACzD;AACA,kBAAkB,0DAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAqC;;AAEP;;AAEf,4BAA4B,6CAAQ;AACnD;AACA,IAAI,wDAAU;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAA8B;;AAEf,kCAAkC,6CAAQ;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAA2C;;AAE5B,8BAA8B,sDAAc;AAC3D,gCAAgC;AAChC,WAAW,WAAW;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAA2C;;AAE5B,8BAA8B,sDAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAgD;AACA;;AAEzC;AACP;AACA;AACA,iBAAiB,wDAAe;AAChC,KAAK;AACL,iBAAiB,wDAAe;AAChC;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;;AAEA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,kBAAkB;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AA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","file":"umap.worker.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js!./src/components/workers/embeddings/umap.worker.ts\");\n","/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @returns {Function} the partially-applied function\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nfunction apply(fn, ...args) {\n    return (...callArgs) => fn(...args,...callArgs);\n}\n\nfunction initialParams (fn) {\n    return function (...args/*, callback*/) {\n        var callback = args.pop();\n        return fn.call(this, args, callback);\n    };\n}\n\n/* istanbul ignore file */\n\nvar hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;\nvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return (fn, ...args) => defer(() => fn(...args));\n}\n\nvar _defer;\n\nif (hasQueueMicrotask) {\n    _defer = queueMicrotask;\n} else if (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nvar setImmediate$1 = wrap(_defer);\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    if (isAsync(func)) {\n        return function (...args/*, callback*/) {\n            const callback = args.pop();\n            const promise = func.apply(this, args);\n            return handlePromise(promise, callback)\n        }\n    }\n\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (result && typeof result.then === 'function') {\n            return handlePromise(result, callback)\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction handlePromise(promise, callback) {\n    return promise.then(value => {\n        invokeCallback(callback, null, value);\n    }, err => {\n        invokeCallback(callback, err && err.message ? err : new Error(err));\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (err) {\n        setImmediate$1(e => { throw e }, err);\n    }\n}\n\nfunction isAsync(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction isAsyncGenerator(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncGenerator';\n}\n\nfunction isAsyncIterable(obj) {\n    return typeof obj[Symbol.asyncIterator] === 'function';\n}\n\nfunction wrapAsync(asyncFn) {\n    if (typeof asyncFn !== 'function') throw new Error('expected a function')\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n}\n\n// conditionally promisify a function.\n// only return a promise if a callback is omitted\nfunction awaitify (asyncFn, arity = asyncFn.length) {\n    if (!arity) throw new Error('arity is undefined')\n    function awaitable (...args) {\n        if (typeof args[arity - 1] === 'function') {\n            return asyncFn.apply(this, args)\n        }\n\n        return new Promise((resolve, reject) => {\n            args[arity - 1] = (err, ...cbArgs) => {\n                if (err) return reject(err)\n                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n            };\n            asyncFn.apply(this, args);\n        })\n    }\n\n    return awaitable\n}\n\nfunction applyEach (eachfn) {\n    return function applyEach(fns, ...callArgs) {\n        const go = awaitify(function (callback) {\n            var that = this;\n            return eachfn(fns, (fn, cb) => {\n                wrapAsync(fn).apply(that, callArgs.concat(cb));\n            }, callback);\n        });\n        return go;\n    };\n}\n\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync(iteratee);\n\n    return eachfn(arr, (value, _, iterCb) => {\n        var index = counter++;\n        _iteratee(value, (err, v) => {\n            results[index] = v;\n            iterCb(err);\n        });\n    }, err => {\n        callback(err, results);\n    });\n}\n\nfunction isArrayLike(value) {\n    return value &&\n        typeof value.length === 'number' &&\n        value.length >= 0 &&\n        value.length % 1 === 0;\n}\n\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nconst breakLoop = {};\n\nfunction once(fn) {\n    function wrapper (...args) {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    }\n    Object.assign(wrapper, fn);\n    return wrapper\n}\n\nfunction getIterator (coll) {\n    return coll[Symbol.iterator] && coll[Symbol.iterator]();\n}\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? {value: coll[i], key: i} : null;\n    }\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done)\n            return null;\n        i++;\n        return {value: item.value, key: i};\n    }\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = obj ? Object.keys(obj) : [];\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        return i < len ? {value: obj[key], key} : null;\n    };\n}\n\nfunction createIterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\n\nfunction onlyOnce(fn) {\n    return function (...args) {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    };\n}\n\n// for async generators\nfunction asyncEachOfLimit(generator, limit, iteratee, callback) {\n    let done = false;\n    let canceled = false;\n    let awaiting = false;\n    let running = 0;\n    let idx = 0;\n\n    function replenish() {\n        //console.log('replenish')\n        if (running >= limit || awaiting || done) return\n        //console.log('replenish awaiting')\n        awaiting = true;\n        generator.next().then(({value, done: iterDone}) => {\n            //console.log('got value', value)\n            if (canceled || done) return\n            awaiting = false;\n            if (iterDone) {\n                done = true;\n                if (running <= 0) {\n                    //console.log('done nextCb')\n                    callback(null);\n                }\n                return;\n            }\n            running++;\n            iteratee(value, idx, iterateeCallback);\n            idx++;\n            replenish();\n        }).catch(handleError);\n    }\n\n    function iterateeCallback(err, result) {\n        //console.log('iterateeCallback')\n        running -= 1;\n        if (canceled) return\n        if (err) return handleError(err)\n\n        if (err === false) {\n            done = true;\n            canceled = true;\n            return\n        }\n\n        if (result === breakLoop || (done && running <= 0)) {\n            done = true;\n            //console.log('done iterCb')\n            return callback(null);\n        }\n        replenish();\n    }\n\n    function handleError(err) {\n        if (canceled) return\n        awaiting = false;\n        done = true;\n        callback(err);\n    }\n\n    replenish();\n}\n\nvar eachOfLimit = (limit) => {\n    return (obj, iteratee, callback) => {\n        callback = once(callback);\n        if (limit <= 0) {\n            throw new RangeError('concurrency limit cannot be less than 1')\n        }\n        if (!obj) {\n            return callback(null);\n        }\n        if (isAsyncGenerator(obj)) {\n            return asyncEachOfLimit(obj, limit, iteratee, callback)\n        }\n        if (isAsyncIterable(obj)) {\n            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback)\n        }\n        var nextElem = createIterator(obj);\n        var done = false;\n        var canceled = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            if (canceled) return\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            }\n            else if (err === false) {\n                done = true;\n                canceled = true;\n            }\n            else if (value === breakLoop || (done && running <= 0)) {\n                done = true;\n                return callback(null);\n            }\n            else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish () {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n};\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachOfLimit$1(coll, limit, iteratee, callback) {\n    return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);\n}\n\nvar eachOfLimit$2 = awaitify(eachOfLimit$1, 4);\n\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback);\n    var index = 0,\n        completed = 0,\n        {length} = coll,\n        canceled = false;\n    if (length === 0) {\n        callback(null);\n    }\n\n    function iteratorCallback(err, value) {\n        if (err === false) {\n            canceled = true;\n        }\n        if (canceled === true) return\n        if (err) {\n            callback(err);\n        } else if ((++completed === length) || value === breakLoop) {\n            callback(null);\n        }\n    }\n\n    for (; index < length; index++) {\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n\n// a generic version of eachOf which can handle array, object, and iterator cases.\nfunction eachOfGeneric (coll, iteratee, callback) {\n    return eachOfLimit$2(coll, Infinity, iteratee, callback);\n}\n\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each\n * item in `coll`.\n * The `key` is the item's key, or index in the case of an array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * // dev.json is a file containing a valid json object config for dev environment\n * // dev.json is a file containing a valid json object config for test environment\n * // prod.json is a file containing a valid json object config for prod environment\n * // invalid.json is a file with a malformed json object\n *\n * let configs = {}; //global variable\n * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};\n * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};\n *\n * // asynchronous function that reads a json file and parses the contents as json object\n * function parseFile(file, key, callback) {\n *     fs.readFile(file, \"utf8\", function(err, data) {\n *         if (err) return calback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }\n *\n * // Using callbacks\n * async.forEachOf(validConfigFileMap, parseFile, function (err) {\n *     if (err) {\n *         console.error(err);\n *     } else {\n *         console.log(configs);\n *         // configs is now a map of JSON data, e.g.\n *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n *     }\n * });\n *\n * //Error handing\n * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {\n *     if (err) {\n *         console.error(err);\n *         // JSON parse error exception\n *     } else {\n *         console.log(configs);\n *     }\n * });\n *\n * // Using Promises\n * async.forEachOf(validConfigFileMap, parseFile)\n * .then( () => {\n *     console.log(configs);\n *     // configs is now a map of JSON data, e.g.\n *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n * }).catch( err => {\n *     console.error(err);\n * });\n *\n * //Error handing\n * async.forEachOf(invalidConfigFileMap, parseFile)\n * .then( () => {\n *     console.log(configs);\n * }).catch( err => {\n *     console.error(err);\n *     // JSON parse error exception\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.forEachOf(validConfigFileMap, parseFile);\n *         console.log(configs);\n *         // configs is now a map of JSON data, e.g.\n *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * //Error handing\n * async () => {\n *     try {\n *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);\n *         console.log(configs);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // JSON parse error exception\n *     }\n * }\n *\n */\nfunction eachOf(coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    return eachOfImplementation(coll, wrapAsync(iteratee), callback);\n}\n\nvar eachOf$1 = awaitify(eachOf, 3);\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callback\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines).\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n * // file4.txt does not exist\n *\n * const fileList = ['file1.txt','file2.txt','file3.txt'];\n * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n *\n * // asynchronous function that returns the file size in bytes\n * function getFileSizeInBytes(file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.map(fileList, getFileSizeInBytes, function(err, results) {\n *     if (err) {\n *         console.log(err);\n *     } else {\n *         console.log(results);\n *         // results is now an array of the file size in bytes for each file, e.g.\n *         // [ 1000, 2000, 3000]\n *     }\n * });\n *\n * // Error Handling\n * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {\n *     if (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     } else {\n *         console.log(results);\n *     }\n * });\n *\n * // Using Promises\n * async.map(fileList, getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n *     // results is now an array of the file size in bytes for each file, e.g.\n *     // [ 1000, 2000, 3000]\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.map(withMissingFileList, getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.map(fileList, getFileSizeInBytes);\n *         console.log(results);\n *         // results is now an array of the file size in bytes for each file, e.g.\n *         // [ 1000, 2000, 3000]\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let results = await async.map(withMissingFileList, getFileSizeInBytes);\n *         console.log(results);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */\nfunction map (coll, iteratee, callback) {\n    return _asyncMap(eachOf$1, coll, iteratee, callback)\n}\nvar map$1 = awaitify(map, 3);\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional. The results\n * for each of the applied async functions are passed to the final callback\n * as an array.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {AsyncFunction} - Returns a function that takes no args other than\n * an optional callback, that is the result of applying the `args` to each\n * of the functions.\n * @example\n *\n * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')\n *\n * appliedFn((err, results) => {\n *     // results[0] is the results for `enableSearch`\n *     // results[1] is the results for `updateSchema`\n * });\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),\n *     callback\n * );\n */\nvar applyEach$1 = applyEach(map$1);\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachOfSeries(coll, iteratee, callback) {\n    return eachOfLimit$2(coll, 1, iteratee, callback)\n}\nvar eachOfSeries$1 = awaitify(eachOfSeries, 3);\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction mapSeries (coll, iteratee, callback) {\n    return _asyncMap(eachOfSeries$1, coll, iteratee, callback)\n}\nvar mapSeries$1 = awaitify(mapSeries, 3);\n\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {AsyncFunction} - A function, that when called, is the result of\n * appling the `args` to the list of functions.  It takes no args, other than\n * a callback.\n */\nvar applyEachSeries = applyEach(mapSeries$1);\n\nconst PROMISE_SYMBOL = Symbol('promiseCallback');\n\nfunction promiseCallback () {\n    let resolve, reject;\n    function callback (err, ...args) {\n        if (err) return reject(err)\n        resolve(args.length > 1 ? args : args[0]);\n    }\n\n    callback[PROMISE_SYMBOL] = new Promise((res, rej) => {\n        resolve = res,\n        reject = rej;\n    });\n\n    return callback\n}\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n * @example\n *\n * //Using Callbacks\n * async.auto({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     if (err) {\n *         console.log('err = ', err);\n *     }\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * });\n *\n * //Using Promises\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }).then(results => {\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * }).catch(err => {\n *     console.log('err = ', err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.auto({\n *             get_data: function(callback) {\n *                 // async code to get some data\n *                 callback(null, 'data', 'converted to array');\n *             },\n *             make_folder: function(callback) {\n *                 // async code to create a directory to store a file in\n *                 // this is run at the same time as getting the data\n *                 callback(null, 'folder');\n *             },\n *             write_file: ['get_data', 'make_folder', function(results, callback) {\n *                 // once there is some data and the directory exists,\n *                 // write the data to a file in the directory\n *                 callback(null, 'filename');\n *             }],\n *             email_link: ['write_file', function(results, callback) {\n *                 // once the file is written let's email a link to it...\n *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *             }]\n *         });\n *         console.log('results = ', results);\n *         // results = {\n *         //     get_data: ['data', 'converted to array']\n *         //     make_folder; 'folder',\n *         //     write_file: 'filename'\n *         //     email_link: { file: 'filename', email: 'user@example.com' }\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction auto(tasks, concurrency, callback) {\n    if (typeof concurrency !== 'number') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || promiseCallback());\n    var numTasks = Object.keys(tasks).length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var canceled = false;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    Object.keys(tasks).forEach(key => {\n        var task = tasks[key];\n        if (!Array.isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        dependencies.forEach(dependencyName => {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key +\n                    '` has a non-existent dependency `' +\n                    dependencyName + '` in ' +\n                    dependencies.join(', '));\n            }\n            addListener(dependencyName, () => {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(() => runTask(key, task));\n    }\n\n    function processQueue() {\n        if (canceled) return\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while(readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        taskListeners.forEach(fn => fn());\n        processQueue();\n    }\n\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce((err, ...result) => {\n            runningTasks--;\n            if (err === false) {\n                canceled = true;\n                return\n            }\n            if (result.length < 2) {\n                [result] = result;\n            }\n            if (err) {\n                var safeResults = {};\n                Object.keys(results).forEach(rkey => {\n                    safeResults[rkey] = results[rkey];\n                });\n                safeResults[key] = result;\n                hasError = true;\n                listeners = Object.create(null);\n                if (canceled) return\n                callback(err, safeResults);\n            } else {\n                results[key] = result;\n                taskComplete(key);\n            }\n        });\n\n        runningTasks++;\n        var taskFn = wrapAsync(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            getDependents(currentTask).forEach(dependent => {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error(\n                'async.auto cannot execute tasks due to a recursive dependency'\n            );\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        Object.keys(tasks).forEach(key => {\n            const task = tasks[key];\n            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n\n    return callback[PROMISE_SYMBOL]\n}\n\nvar FN_ARGS = /^(?:async\\s+)?(?:function)?\\s*\\w*\\s*\\(\\s*([^)]+)\\s*\\)(?:\\s*{)/;\nvar ARROW_FN_ARGS = /^(?:async\\s+)?\\(?\\s*([^)=]+)\\s*\\)?(?:\\s*=>)/;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction parseParams(func) {\n    const src = func.toString().replace(STRIP_COMMENTS, '');\n    let match = src.match(FN_ARGS);\n    if (!match) {\n        match = src.match(ARROW_FN_ARGS);\n    }\n    if (!match) throw new Error('could not parse args in autoInject\\nSource:\\n' + src)\n    let [, args] = match;\n    return args\n        .replace(/\\s/g, '')\n        .split(FN_ARG_SPLIT)\n        .map((arg) => arg.replace(FN_ARG, '').trim());\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    Object.keys(tasks).forEach(key => {\n        var taskFn = tasks[key];\n        var params;\n        var fnIsAsync = isAsync(taskFn);\n        var hasNoDeps =\n            (!fnIsAsync && taskFn.length === 1) ||\n            (fnIsAsync && taskFn.length === 0);\n\n        if (Array.isArray(taskFn)) {\n            params = [...taskFn];\n            taskFn = params.pop();\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if ((taskFn.length === 0 && !fnIsAsync) && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = params.map(name => results[name]);\n            newArgs.push(taskCb);\n            wrapAsync(taskFn)(...newArgs);\n        }\n    });\n\n    return auto(newTasks, callback);\n}\n\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nclass DLL {\n    constructor() {\n        this.head = this.tail = null;\n        this.length = 0;\n    }\n\n    removeLink(node) {\n        if (node.prev) node.prev.next = node.next;\n        else this.head = node.next;\n        if (node.next) node.next.prev = node.prev;\n        else this.tail = node.prev;\n\n        node.prev = node.next = null;\n        this.length -= 1;\n        return node;\n    }\n\n    empty () {\n        while(this.head) this.shift();\n        return this;\n    }\n\n    insertAfter(node, newNode) {\n        newNode.prev = node;\n        newNode.next = node.next;\n        if (node.next) node.next.prev = newNode;\n        else this.tail = newNode;\n        node.next = newNode;\n        this.length += 1;\n    }\n\n    insertBefore(node, newNode) {\n        newNode.prev = node.prev;\n        newNode.next = node;\n        if (node.prev) node.prev.next = newNode;\n        else this.head = newNode;\n        node.prev = newNode;\n        this.length += 1;\n    }\n\n    unshift(node) {\n        if (this.head) this.insertBefore(this.head, node);\n        else setInitial(this, node);\n    }\n\n    push(node) {\n        if (this.tail) this.insertAfter(this.tail, node);\n        else setInitial(this, node);\n    }\n\n    shift() {\n        return this.head && this.removeLink(this.head);\n    }\n\n    pop() {\n        return this.tail && this.removeLink(this.tail);\n    }\n\n    toArray() {\n        return [...this]\n    }\n\n    *[Symbol.iterator] () {\n        var cur = this.head;\n        while (cur) {\n            yield cur.data;\n            cur = cur.next;\n        }\n    }\n\n    remove (testFn) {\n        var curr = this.head;\n        while(curr) {\n            var {next} = curr;\n            if (testFn(curr)) {\n                this.removeLink(curr);\n            }\n            curr = next;\n        }\n        return this;\n    }\n}\n\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\n\nfunction queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    }\n    else if(concurrency === 0) {\n        throw new RangeError('Concurrency must not be zero');\n    }\n\n    var _worker = wrapAsync(worker);\n    var numRunning = 0;\n    var workersList = [];\n    const events = {\n        error: [],\n        drain: [],\n        saturated: [],\n        unsaturated: [],\n        empty: []\n    };\n\n    function on (event, handler) {\n        events[event].push(handler);\n    }\n\n    function once (event, handler) {\n        const handleAndRemove = (...args) => {\n            off(event, handleAndRemove);\n            handler(...args);\n        };\n        events[event].push(handleAndRemove);\n    }\n\n    function off (event, handler) {\n        if (!event) return Object.keys(events).forEach(ev => events[ev] = [])\n        if (!handler) return events[event] = []\n        events[event] = events[event].filter(ev => ev !== handler);\n    }\n\n    function trigger (event, ...args) {\n        events[event].forEach(handler => handler(...args));\n    }\n\n    var processingScheduled = false;\n    function _insert(data, insertAtFront, rejectOnError, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n\n        var res, rej;\n        function promiseCallback (err, ...args) {\n            // we don't care about the error, let the global error handler\n            // deal with it\n            if (err) return rejectOnError ? rej(err) : res()\n            if (args.length <= 1) return res(args[0])\n            res(args);\n        }\n\n        var item = {\n            data,\n            callback: rejectOnError ?\n                promiseCallback :\n                (callback || promiseCallback)\n        };\n\n        if (insertAtFront) {\n            q._tasks.unshift(item);\n        } else {\n            q._tasks.push(item);\n        }\n\n        if (!processingScheduled) {\n            processingScheduled = true;\n            setImmediate$1(() => {\n                processingScheduled = false;\n                q.process();\n            });\n        }\n\n        if (rejectOnError || !callback) {\n            return new Promise((resolve, reject) => {\n                res = resolve;\n                rej = reject;\n            })\n        }\n    }\n\n    function _createCB(tasks) {\n        return function (err, ...args) {\n            numRunning -= 1;\n\n            for (var i = 0, l = tasks.length; i < l; i++) {\n                var task = tasks[i];\n\n                var index = workersList.indexOf(task);\n                if (index === 0) {\n                    workersList.shift();\n                } else if (index > 0) {\n                    workersList.splice(index, 1);\n                }\n\n                task.callback(err, ...args);\n\n                if (err != null) {\n                    trigger('error', err, task.data);\n                }\n            }\n\n            if (numRunning <= (q.concurrency - q.buffer) ) {\n                trigger('unsaturated');\n            }\n\n            if (q.idle()) {\n                trigger('drain');\n            }\n            q.process();\n        };\n    }\n\n    function _maybeDrain(data) {\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            setImmediate$1(() => trigger('drain'));\n            return true\n        }\n        return false\n    }\n\n    const eventMethod = (name) => (handler) => {\n        if (!handler) {\n            return new Promise((resolve, reject) => {\n                once(name, (err, data) => {\n                    if (err) return reject(err)\n                    resolve(data);\n                });\n            })\n        }\n        off(name);\n        on(name, handler);\n\n    };\n\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        *[Symbol.iterator] () {\n            yield* q._tasks[Symbol.iterator]();\n        },\n        concurrency,\n        payload,\n        buffer: concurrency / 4,\n        started: false,\n        paused: false,\n        push (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return\n                return data.map(datum => _insert(datum, false, false, callback))\n            }\n            return _insert(data, false, false, callback);\n        },\n        pushAsync (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return\n                return data.map(datum => _insert(datum, false, true, callback))\n            }\n            return _insert(data, false, true, callback);\n        },\n        kill () {\n            off();\n            q._tasks.empty();\n        },\n        unshift (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return\n                return data.map(datum => _insert(datum, true, false, callback))\n            }\n            return _insert(data, true, false, callback);\n        },\n        unshiftAsync (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return\n                return data.map(datum => _insert(datum, true, true, callback))\n            }\n            return _insert(data, true, true, callback);\n        },\n        remove (testFn) {\n            q._tasks.remove(testFn);\n        },\n        process () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while(!q.paused && numRunning < q.concurrency && q._tasks.length){\n                var tasks = [], data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for (var i = 0; i < l; i++) {\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    workersList.push(node);\n                    data.push(node.data);\n                }\n\n                numRunning += 1;\n\n                if (q._tasks.length === 0) {\n                    trigger('empty');\n                }\n\n                if (numRunning === q.concurrency) {\n                    trigger('saturated');\n                }\n\n                var cb = onlyOnce(_createCB(tasks));\n                _worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length () {\n            return q._tasks.length;\n        },\n        running () {\n            return numRunning;\n        },\n        workersList () {\n            return workersList;\n        },\n        idle() {\n            return q._tasks.length + numRunning === 0;\n        },\n        pause () {\n            q.paused = true;\n        },\n        resume () {\n            if (q.paused === false) { return; }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    // define these as fixed properties, so people get useful errors when updating\n    Object.defineProperties(q, {\n        saturated: {\n            writable: false,\n            value: eventMethod('saturated')\n        },\n        unsaturated: {\n            writable: false,\n            value: eventMethod('unsaturated')\n        },\n        empty: {\n            writable: false,\n            value: eventMethod('empty')\n        },\n        drain: {\n            writable: false,\n            value: eventMethod('drain')\n        },\n        error: {\n            writable: false,\n            value: eventMethod('error')\n        },\n    });\n    return q;\n}\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * await cargo.push({name: 'baz'});\n * console.log('finished processing baz');\n */\nfunction cargo(worker, payload) {\n    return queue(worker, 1, payload);\n}\n\n/**\n * Creates a `cargoQueue` object with the specified payload. Tasks added to the\n * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.\n * If the all `workers` are in progress, the task is queued until one becomes available. Once\n * a `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,\n * the cargoQueue passes an array of tasks to multiple parallel workers.\n *\n * @name cargoQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @see [async.cargo]{@link module:ControlFLow.cargo}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargoQueue and inner queue.\n * @example\n *\n * // create a cargoQueue object with payload 2 and concurrency 2\n * var cargoQueue = async.cargoQueue(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2, 2);\n *\n * // add some items\n * cargoQueue.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargoQueue.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargoQueue.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n * cargoQueue.push({name: 'boo'}, function(err) {\n *     console.log('finished processing boo');\n * });\n */\nfunction cargo$1(worker, concurrency, payload) {\n    return queue(worker, concurrency, payload);\n}\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee completes with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n * // file4.txt does not exist\n *\n * const fileList = ['file1.txt','file2.txt','file3.txt'];\n * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];\n *\n * // asynchronous function that computes the file size in bytes\n * // file size is added to the memoized value, then returned\n * function getFileSizeInBytes(memo, file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, memo + stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // 6000\n *         // which is the sum of the file sizes of the three files\n *     }\n * });\n *\n * // Error Handling\n * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     } else {\n *         console.log(result);\n *     }\n * });\n *\n * // Using Promises\n * async.reduce(fileList, 0, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n *     // 6000\n *     // which is the sum of the file sizes of the three files\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.reduce(withMissingFileList, 0, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.reduce(fileList, 0, getFileSizeInBytes);\n *         console.log(result);\n *         // 6000\n *         // which is the sum of the file sizes of the three files\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);\n *         console.log(result);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */\nfunction reduce(coll, memo, iteratee, callback) {\n    callback = once(callback);\n    var _iteratee = wrapAsync(iteratee);\n    return eachOfSeries$1(coll, (x, i, iterCb) => {\n        _iteratee(memo, x, (err, v) => {\n            memo = v;\n            iterCb(err);\n        });\n    }, err => callback(err, memo));\n}\nvar reduce$1 = awaitify(reduce, 4);\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nfunction seq(...functions) {\n    var _functions = functions.map(wrapAsync);\n    return function (...args) {\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = promiseCallback();\n        }\n\n        reduce$1(_functions, args, (newargs, fn, iterCb) => {\n            fn.apply(that, newargs.concat((err, ...nextargs) => {\n                iterCb(err, nextargs);\n            }));\n        },\n        (err, results) => cb(err, ...results));\n\n        return cb[PROMISE_SYMBOL]\n    };\n}\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * If the last argument to the composed function is not a function, a promise\n * is returned when you call it.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nfunction compose(...args) {\n    return seq(...args.reverse());\n}\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction mapLimit (coll, limit, iteratee, callback) {\n    return _asyncMap(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar mapLimit$1 = awaitify(mapLimit, 4);\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n *\n * @name concatLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @alias flatMapLimit\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed\n */\nfunction concatLimit(coll, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(coll, limit, (val, iterCb) => {\n        _iteratee(val, (err, ...args) => {\n            if (err) return iterCb(err);\n            return iterCb(err, args);\n        });\n    }, (err, mapResults) => {\n        var result = [];\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                result = result.concat(...mapResults[i]);\n            }\n        }\n\n        return callback(err, result);\n    });\n}\nvar concatLimit$1 = awaitify(concatLimit, 4);\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. The results array will be returned in\n * the original order of `coll` passed to the `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @alias flatMap\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * let directoryList = ['dir1','dir2','dir3'];\n * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];\n *\n * // Using callbacks\n * async.concat(directoryList, fs.readdir, function(err, results) {\n *    if (err) {\n *        console.log(err);\n *    } else {\n *        console.log(results);\n *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n *    }\n * });\n *\n * // Error Handling\n * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {\n *    if (err) {\n *        console.log(err);\n *        // [ Error: ENOENT: no such file or directory ]\n *        // since dir4 does not exist\n *    } else {\n *        console.log(results);\n *    }\n * });\n *\n * // Using Promises\n * async.concat(directoryList, fs.readdir)\n * .then(results => {\n *     console.log(results);\n *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n * }).catch(err => {\n *      console.log(err);\n * });\n *\n * // Error Handling\n * async.concat(withMissingDirectoryList, fs.readdir)\n * .then(results => {\n *     console.log(results);\n * }).catch(err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n *     // since dir4 does not exist\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.concat(directoryList, fs.readdir);\n *         console.log(results);\n *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n *     } catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let results = await async.concat(withMissingDirectoryList, fs.readdir);\n *         console.log(results);\n *     } catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *         // since dir4 does not exist\n *     }\n * }\n *\n */\nfunction concat(coll, iteratee, callback) {\n    return concatLimit$1(coll, Infinity, iteratee, callback)\n}\nvar concat$1 = awaitify(concat, 3);\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @alias flatMapSeries\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed\n */\nfunction concatSeries(coll, iteratee, callback) {\n    return concatLimit$1(coll, 1, iteratee, callback)\n}\nvar concatSeries$1 = awaitify(concatSeries, 3);\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {AsyncFunction} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nfunction constant(...args) {\n    return function (...ignoredArgs/*, callback*/) {\n        var callback = ignoredArgs.pop();\n        return callback(null, ...args);\n    };\n}\n\nfunction _createTester(check, getResult) {\n    return (eachfn, arr, _iteratee, cb) => {\n        var testPassed = false;\n        var testResult;\n        const iteratee = wrapAsync(_iteratee);\n        eachfn(arr, (value, _, callback) => {\n            iteratee(value, (err, result) => {\n                if (err || err === false) return callback(err);\n\n                if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    return callback(null, breakLoop);\n                }\n                callback();\n            });\n        }, err => {\n            if (err) return cb(err);\n            cb(null, testPassed ? testResult : getResult(false));\n        });\n    };\n}\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @returns A Promise, if no callback is passed\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,\n *    function(err, result) {\n *        console.log(result);\n *        // dir1/file1.txt\n *        // result now equals the first file in the list that exists\n *    }\n *);\n *\n * // Using Promises\n * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)\n * .then(result => {\n *     console.log(result);\n *     // dir1/file1.txt\n *     // result now equals the first file in the list that exists\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);\n *         console.log(result);\n *         // dir1/file1.txt\n *         // result now equals the file in the list that exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction detect(coll, iteratee, callback) {\n    return _createTester(bool => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback)\n}\nvar detect$1 = awaitify(detect, 3);\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @returns a Promise if no callback is passed\n */\nfunction detectLimit(coll, limit, iteratee, callback) {\n    return _createTester(bool => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar detectLimit$1 = awaitify(detectLimit, 4);\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @returns a Promise if no callback is passed\n */\nfunction detectSeries(coll, iteratee, callback) {\n    return _createTester(bool => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback)\n}\n\nvar detectSeries$1 = awaitify(detectSeries, 3);\n\nfunction consoleFunc(name) {\n    return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {\n        /* istanbul ignore else */\n        if (typeof console === 'object') {\n            /* istanbul ignore else */\n            if (err) {\n                /* istanbul ignore else */\n                if (console.error) {\n                    console.error(err);\n                }\n            } else if (console[name]) { /* istanbul ignore else */\n                resultArgs.forEach(x => console[name](x));\n            }\n        }\n    })\n}\n\n/**\n * Logs the result of an [`async` function]{@link AsyncFunction} to the\n * `console` using `console.dir` to display the properties of the resulting object.\n * Only works in Node.js or in browsers that support `console.dir` and\n * `console.error` (such as FF and Chrome).\n * If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nvar dir = consoleFunc('dir');\n\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - A function which is called each time `test`\n * passes. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform after each\n * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback);\n    var _fn = wrapAsync(iteratee);\n    var _test = wrapAsync(test);\n    var results;\n\n    function next(err, ...args) {\n        if (err) return callback(err);\n        if (err === false) return;\n        results = args;\n        _test(...args, check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (err === false) return;\n        if (!truth) return callback(null, ...results);\n        _fn(next);\n    }\n\n    return check(null, true);\n}\n\nvar doWhilst$1 = awaitify(doWhilst, 3);\n\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform after each\n * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `iteratee`\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction doUntil(iteratee, test, callback) {\n    const _test = wrapAsync(test);\n    return doWhilst$1(iteratee, (...args) => {\n        const cb = args.pop();\n        _test(...args, (err, truth) => cb (err, !truth));\n    }, callback);\n}\n\nfunction _withoutIndex(iteratee) {\n    return (value, index, callback) => iteratee(value, callback);\n}\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to\n * each item in `coll`. Invoked with (item, callback).\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];\n * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];\n *\n * // asynchronous function that deletes a file\n * const deleteFile = function(file, callback) {\n *     fs.unlink(file, callback);\n * };\n *\n * // Using callbacks\n * async.each(fileList, deleteFile, function(err) {\n *     if( err ) {\n *         console.log(err);\n *     } else {\n *         console.log('All files have been deleted successfully');\n *     }\n * });\n *\n * // Error Handling\n * async.each(withMissingFileList, deleteFile, function(err){\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n *     // since dir4/file2.txt does not exist\n *     // dir1/file1.txt could have been deleted\n * });\n *\n * // Using Promises\n * async.each(fileList, deleteFile)\n * .then( () => {\n *     console.log('All files have been deleted successfully');\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.each(fileList, deleteFile)\n * .then( () => {\n *     console.log('All files have been deleted successfully');\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n *     // since dir4/file2.txt does not exist\n *     // dir1/file1.txt could have been deleted\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         await async.each(files, deleteFile);\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         await async.each(withMissingFileList, deleteFile);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *         // since dir4/file2.txt does not exist\n *         // dir1/file1.txt could have been deleted\n *     }\n * }\n *\n */\nfunction eachLimit(coll, iteratee, callback) {\n    return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\nvar each = awaitify(eachLimit, 3);\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachLimit$1(coll, limit, iteratee, callback) {\n    return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\nvar eachLimit$2 = awaitify(eachLimit$1, 4);\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item\n * in series and therefore the iteratee functions will complete in order.\n\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachSeries(coll, iteratee, callback) {\n    return eachLimit$2(coll, 1, iteratee, callback)\n}\nvar eachSeries$1 = awaitify(eachSeries, 3);\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return function (...args/*, callback*/) {\n        var callback = args.pop();\n        var sync = true;\n        args.push((...innerArgs) => {\n            if (sync) {\n                setImmediate$1(() => callback(...innerArgs));\n            } else {\n                callback(...innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    };\n}\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];\n * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.every(fileList, fileExists, function(err, result) {\n *     console.log(result);\n *     // true\n *     // result is true since every file exists\n * });\n *\n * async.every(withMissingFileList, fileExists, function(err, result) {\n *     console.log(result);\n *     // false\n *     // result is false since NOT every file exists\n * });\n *\n * // Using Promises\n * async.every(fileList, fileExists)\n * .then( result => {\n *     console.log(result);\n *     // true\n *     // result is true since every file exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * async.every(withMissingFileList, fileExists)\n * .then( result => {\n *     console.log(result);\n *     // false\n *     // result is false since NOT every file exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.every(fileList, fileExists);\n *         console.log(result);\n *         // true\n *         // result is true since every file exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * async () => {\n *     try {\n *         let result = await async.every(withMissingFileList, fileExists);\n *         console.log(result);\n *         // false\n *         // result is false since NOT every file exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction every(coll, iteratee, callback) {\n    return _createTester(bool => !bool, res => !res)(eachOf$1, coll, iteratee, callback)\n}\nvar every$1 = awaitify(every, 3);\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */\nfunction everyLimit(coll, limit, iteratee, callback) {\n    return _createTester(bool => !bool, res => !res)(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar everyLimit$1 = awaitify(everyLimit, 4);\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in series.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */\nfunction everySeries(coll, iteratee, callback) {\n    return _createTester(bool => !bool, res => !res)(eachOfSeries$1, coll, iteratee, callback)\n}\nvar everySeries$1 = awaitify(everySeries, 3);\n\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, (x, index, iterCb) => {\n        iteratee(x, (err, v) => {\n            truthValues[index] = !!v;\n            iterCb(err);\n        });\n    }, err => {\n        if (err) return callback(err);\n        var results = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\n\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, (x, index, iterCb) => {\n        iteratee(x, (err, v) => {\n            if (err) return iterCb(err);\n            if (v) {\n                results.push({index, value: x});\n            }\n            iterCb(err);\n        });\n    }, err => {\n        if (err) return callback(err);\n        callback(null, results\n            .sort((a, b) => a.index - b.index)\n            .map(v => v.value));\n    });\n}\n\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    return filter(eachfn, coll, wrapAsync(iteratee), callback);\n}\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n *\n * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.filter(files, fileExists, function(err, results) {\n *    if(err) {\n *        console.log(err);\n *    } else {\n *        console.log(results);\n *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n *        // results is now an array of the existing files\n *    }\n * });\n *\n * // Using Promises\n * async.filter(files, fileExists)\n * .then(results => {\n *     console.log(results);\n *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n *     // results is now an array of the existing files\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.filter(files, fileExists);\n *         console.log(results);\n *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n *         // results is now an array of the existing files\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction filter (coll, iteratee, callback) {\n    return _filter(eachOf$1, coll, iteratee, callback)\n}\nvar filter$1 = awaitify(filter, 3);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback provided\n */\nfunction filterLimit (coll, limit, iteratee, callback) {\n    return _filter(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar filterLimit$1 = awaitify(filterLimit, 4);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n * @returns {Promise} a promise, if no callback provided\n */\nfunction filterSeries (coll, iteratee, callback) {\n    return _filter(eachOfSeries$1, coll, iteratee, callback)\n}\nvar filterSeries$1 = awaitify(filterSeries, 3);\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the callback then `errback` is called with the\n * error, and execution stops, otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} fn - an async function to call repeatedly.\n * Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @returns {Promise} a promise that rejects if an error occurs and an errback\n * is not passed\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nfunction forever(fn, errback) {\n    var done = onlyOnce(errback);\n    var task = wrapAsync(ensureAsync(fn));\n\n    function next(err) {\n        if (err) return done(err);\n        if (err === false) return;\n        task(next);\n    }\n    return next();\n}\nvar forever$1 = awaitify(forever, 2);\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n *\n * @name groupByLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction groupByLimit(coll, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(coll, limit, (val, iterCb) => {\n        _iteratee(val, (err, key) => {\n            if (err) return iterCb(err);\n            return iterCb(err, {key, val});\n        });\n    }, (err, mapResults) => {\n        var result = {};\n        // from MDN, handle object having an `hasOwnProperty` prop\n        var {hasOwnProperty} = Object.prototype;\n\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                var {key} = mapResults[i];\n                var {val} = mapResults[i];\n\n                if (hasOwnProperty.call(result, key)) {\n                    result[key].push(val);\n                } else {\n                    result[key] = [val];\n                }\n            }\n        }\n\n        return callback(err, result);\n    });\n}\n\nvar groupByLimit$1 = awaitify(groupByLimit, 4);\n\n/**\n * Returns a new object, where each value corresponds to an array of items, from\n * `coll`, that returned the corresponding key. That is, the keys of the object\n * correspond to the values passed to the `iteratee` callback.\n *\n * Note: Since this function applies the `iteratee` to each item in parallel,\n * there is no guarantee that the `iteratee` functions will complete in order.\n * However, the values for each key in the `result` will be in the same order as\n * the original `coll`. For Objects, the values will roughly be in the order of\n * the original Objects' keys (but this can vary across JavaScript engines).\n *\n * @name groupBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * const files = ['dir1/file1.txt','dir2','dir4']\n *\n * // asynchronous function that detects file type as none, file, or directory\n * function detectFile(file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(null, 'none');\n *         }\n *         callback(null, stat.isDirectory() ? 'directory' : 'file');\n *     });\n * }\n *\n * //Using callbacks\n * async.groupBy(files, detectFile, function(err, result) {\n *     if(err) {\n *         console.log(err);\n *     } else {\n *\t       console.log(result);\n *         // {\n *         //     file: [ 'dir1/file1.txt' ],\n *         //     none: [ 'dir4' ],\n *         //     directory: [ 'dir2']\n *         // }\n *         // result is object containing the files grouped by type\n *     }\n * });\n *\n * // Using Promises\n * async.groupBy(files, detectFile)\n * .then( result => {\n *     console.log(result);\n *     // {\n *     //     file: [ 'dir1/file1.txt' ],\n *     //     none: [ 'dir4' ],\n *     //     directory: [ 'dir2']\n *     // }\n *     // result is object containing the files grouped by type\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.groupBy(files, detectFile);\n *         console.log(result);\n *         // {\n *         //     file: [ 'dir1/file1.txt' ],\n *         //     none: [ 'dir4' ],\n *         //     directory: [ 'dir2']\n *         // }\n *         // result is object containing the files grouped by type\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction groupBy (coll, iteratee, callback) {\n    return groupByLimit$1(coll, Infinity, iteratee, callback)\n}\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n *\n * @name groupBySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whose\n * properties are arrays of values which returned the corresponding key.\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction groupBySeries (coll, iteratee, callback) {\n    return groupByLimit$1(coll, 1, iteratee, callback)\n}\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nvar log = consoleFunc('log');\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback);\n    var newObj = {};\n    var _iteratee = wrapAsync(iteratee);\n    return eachOfLimit(limit)(obj, (val, key, next) => {\n        _iteratee(val, key, (err, result) => {\n            if (err) return next(err);\n            newObj[key] = result;\n            next(err);\n        });\n    }, err => callback(err, newObj));\n}\n\nvar mapValuesLimit$1 = awaitify(mapValuesLimit, 4);\n\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n * // file4.txt does not exist\n *\n * const fileMap = {\n *     f1: 'file1.txt',\n *     f2: 'file2.txt',\n *     f3: 'file3.txt'\n * };\n *\n * const withMissingFileMap = {\n *     f1: 'file1.txt',\n *     f2: 'file2.txt',\n *     f3: 'file4.txt'\n * };\n *\n * // asynchronous function that returns the file size in bytes\n * function getFileSizeInBytes(file, key, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // result is now a map of file size in bytes for each file, e.g.\n *         // {\n *         //     f1: 1000,\n *         //     f2: 2000,\n *         //     f3: 3000\n *         // }\n *     }\n * });\n *\n * // Error handling\n * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     } else {\n *         console.log(result);\n *     }\n * });\n *\n * // Using Promises\n * async.mapValues(fileMap, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n *     // result is now a map of file size in bytes for each file, e.g.\n *     // {\n *     //     f1: 1000,\n *     //     f2: 2000,\n *     //     f3: 3000\n *     // }\n * }).catch (err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.mapValues(withMissingFileMap, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n * }).catch (err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.mapValues(fileMap, getFileSizeInBytes);\n *         console.log(result);\n *         // result is now a map of file size in bytes for each file, e.g.\n *         // {\n *         //     f1: 1000,\n *         //     f2: 2000,\n *         //     f3: 3000\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);\n *         console.log(result);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */\nfunction mapValues(obj, iteratee, callback) {\n    return mapValuesLimit$1(obj, Infinity, iteratee, callback)\n}\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction mapValuesSeries(obj, iteratee, callback) {\n    return mapValuesLimit$1(obj, 1, iteratee, callback)\n}\n\n/**\n * Caches the results of an async function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * **Note: if the async function errs, the result will not be cached and\n * subsequent calls will call the wrapped function.**\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {AsyncFunction} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nfunction memoize(fn, hasher = v => v) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    var _fn = wrapAsync(fn);\n    var memoized = initialParams((args, callback) => {\n        var key = hasher(...args);\n        if (key in memo) {\n            setImmediate$1(() => callback(null, ...memo[key]));\n        } else if (key in queues) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            _fn(...args, (err, ...resultArgs) => {\n                // #1465 don't memoize if an error occurred\n                if (!err) {\n                    memo[key] = resultArgs;\n                }\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i](err, ...resultArgs);\n                }\n            });\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `process.nextTick`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.setImmediate]{@link module:Utils.setImmediate}\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer$1;\n\nif (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else {\n    _defer$1 = fallback;\n}\n\nvar nextTick = wrap(_defer$1);\n\nvar _parallel = awaitify((eachfn, tasks, callback) => {\n    var results = isArrayLike(tasks) ? [] : {};\n\n    eachfn(tasks, (task, key, taskCb) => {\n        wrapAsync(task)((err, ...result) => {\n            if (result.length < 2) {\n                [result] = result;\n            }\n            results[key] = result;\n            taskCb(err);\n        });\n    }, err => callback(err, results));\n}, 3);\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n * execution of other tasks when a task fails.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n *\n * @example\n *\n * //Using Callbacks\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ], function(err, results) {\n *     console.log(results);\n *     // results is equal to ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * });\n *\n * //Using Promises\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ]).then(results => {\n *     console.log(results);\n *     // results is equal to ['one','two'] even though\n *     // the second function had a shorter timeout.\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }).then(results => {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.parallel([\n *             function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 'one');\n *                 }, 200);\n *             },\n *             function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 'two');\n *                 }, 100);\n *             }\n *         ]);\n *         console.log(results);\n *         // results is equal to ['one','two'] even though\n *         // the second function had a shorter timeout.\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // an example using an object instead of an array\n * async () => {\n *     try {\n *         let results = await async.parallel({\n *             one: function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 1);\n *                 }, 200);\n *             },\n *            two: function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 2);\n *                 }, 100);\n *            }\n *         });\n *         console.log(results);\n *         // results is equal to: { one: 1, two: 2 }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction parallel(tasks, callback) {\n    return _parallel(eachOf$1, tasks, callback);\n}\n\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n */\nfunction parallelLimit(tasks, limit, callback) {\n    return _parallel(eachOfLimit(limit), tasks, callback);\n}\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Iterable} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {number} payload - an integer that specifies how many items are\n * passed to the worker function at a time. only applies if this is a\n * [cargo]{@link module:ControlFlow.cargo} object\n * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns\n * a promise that rejects if an error occurs.\n * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns\n * a promise that rejects if an error occurs.\n * @property {Function} remove - remove items from the queue that match a test\n * function.  The test function will be passed an object with a `data` property,\n * and a `priority` property, if this is a\n * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n * `function ({data, priority}) {}` and returns a Boolean.\n * @property {Function} saturated - a function that sets a callback that is\n * called when the number of running workers hits the `concurrency` limit, and\n * further tasks will be queued.  If the callback is omitted, `q.saturated()`\n * returns a promise for the next occurrence.\n * @property {Function} unsaturated - a function that sets a callback that is\n * called when the number of running workers is less than the `concurrency` &\n * `buffer` limits, and further tasks will not be queued. If the callback is\n * omitted, `q.unsaturated()` returns a promise for the next occurrence.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a function that sets a callback that is called\n * when the last item from the `queue` is given to a `worker`. If the callback\n * is omitted, `q.empty()` returns a promise for the next occurrence.\n * @property {Function} drain - a function that sets a callback that is called\n * when the last item from the `queue` has returned from the `worker`. If the\n * callback is omitted, `q.drain()` returns a promise for the next occurrence.\n * @property {Function} error - a function that sets a callback that is called\n * when a task errors. Has the signature `function(error, task)`. If the\n * callback is omitted, `error()` returns a promise that rejects on the next\n * error.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. No more tasks\n * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.\n *\n * @example\n * const q = async.queue(worker, 2)\n * q.push(item1)\n * q.push(item2)\n * q.push(item3)\n * // queues are iterable, spread into an array to inspect\n * const items = [...q] // [item1, item2, item3]\n * // or use for of\n * for (let item of q) {\n *     console.log(item)\n * }\n *\n * q.drain(() => {\n *     console.log('all done')\n * })\n * // or\n * await q.drain()\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`. Invoked with (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain(function() {\n *     console.log('all items have been processed');\n * });\n * // or await the end\n * await q.drain()\n *\n * // assign an error callback\n * q.error(function(err, task) {\n *     console.error('task experienced an error');\n * });\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * // callback is optional\n * q.push({name: 'bar'});\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nfunction queue$1 (worker, concurrency) {\n    var _worker = wrapAsync(worker);\n    return queue((items, cb) => {\n        _worker(items[0], cb);\n    }, concurrency, 1);\n}\n\n// Binary min-heap implementation used for priority queue.\n// Implementation is stable, i.e. push time is considered for equal priorities\nclass Heap {\n    constructor() {\n        this.heap = [];\n        this.pushCount = Number.MIN_SAFE_INTEGER;\n    }\n\n    get length() {\n        return this.heap.length;\n    }\n\n    empty () {\n        this.heap = [];\n        return this;\n    }\n\n    percUp(index) {\n        let p;\n\n        while (index > 0 && smaller(this.heap[index], this.heap[p=parent(index)])) {\n            let t = this.heap[index];\n            this.heap[index] = this.heap[p];\n            this.heap[p] = t;\n\n            index = p;\n        }\n    }\n\n    percDown(index) {\n        let l;\n\n        while ((l=leftChi(index)) < this.heap.length) {\n            if (l+1 < this.heap.length && smaller(this.heap[l+1], this.heap[l])) {\n                l = l+1;\n            }\n\n            if (smaller(this.heap[index], this.heap[l])) {\n                break;\n            }\n\n            let t = this.heap[index];\n            this.heap[index] = this.heap[l];\n            this.heap[l] = t;\n\n            index = l;\n        }\n    }\n\n    push(node) {\n        node.pushCount = ++this.pushCount;\n        this.heap.push(node);\n        this.percUp(this.heap.length-1);\n    }\n\n    unshift(node) {\n        return this.heap.push(node);\n    }\n\n    shift() {\n        let [top] = this.heap;\n\n        this.heap[0] = this.heap[this.heap.length-1];\n        this.heap.pop();\n        this.percDown(0);\n\n        return top;\n    }\n\n    toArray() {\n        return [...this];\n    }\n\n    *[Symbol.iterator] () {\n        for (let i = 0; i < this.heap.length; i++) {\n            yield this.heap[i].data;\n        }\n    }\n\n    remove (testFn) {\n        let j = 0;\n        for (let i = 0; i < this.heap.length; i++) {\n            if (!testFn(this.heap[i])) {\n                this.heap[j] = this.heap[i];\n                j++;\n            }\n        }\n\n        this.heap.splice(j);\n\n        for (let i = parent(this.heap.length-1); i >= 0; i--) {\n            this.percDown(i);\n        }\n\n        return this;\n    }\n}\n\nfunction leftChi(i) {\n    return (i<<1)+1;\n}\n\nfunction parent(i) {\n    return ((i+1)>>1)-1;\n}\n\nfunction smaller(x, y) {\n    if (x.priority !== y.priority) {\n        return x.priority < y.priority;\n    }\n    else {\n        return x.pushCount < y.pushCount;\n    }\n}\n\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`.\n * Invoked with (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * The `unshift` method was removed.\n */\nfunction priorityQueue(worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n    var processingScheduled = false;\n\n    q._tasks = new Heap();\n\n    // Override push to accept second parameter representing priority\n    q.push = function(data, priority = 0, callback = () => {}) {\n        if (typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!Array.isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(() => q.drain());\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                priority,\n                callback\n            };\n\n            q._tasks.push(item);\n        }\n\n        if (!processingScheduled) {\n            processingScheduled = true;\n            setImmediate$1(() => {\n                processingScheduled = false;\n                q.process();\n            });\n        }\n    };\n\n    // Remove unshift function\n    delete q.unshift;\n\n    return q;\n}\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n * to run. Each function can complete with an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns undefined\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nfunction race(tasks, callback) {\n    callback = once(callback);\n    if (!Array.isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n        wrapAsync(tasks[i])(callback);\n    }\n}\n\nvar race$1 = awaitify(race, 2);\n\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee completes with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction reduceRight (array, memo, iteratee, callback) {\n    var reversed = [...array].reverse();\n    return reduce$1(reversed, memo, iteratee, callback);\n}\n\n/**\n * Wraps the async function in another function that always completes with a\n * result object, even when it errors.\n *\n * The result object has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nfunction reflect(fn) {\n    var _fn = wrapAsync(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push((error, ...cbArgs) => {\n            let retVal = {};\n            if (error) {\n                retVal.error = error;\n            }\n            if (cbArgs.length > 0){\n                var value = cbArgs;\n                if (cbArgs.length <= 1) {\n                    [value] = cbArgs;\n                }\n                retVal.value = value;\n            }\n            reflectCallback(null, retVal);\n        });\n\n        return _fn.apply(this, args);\n    });\n}\n\n/**\n * A helper function that wraps an array or an object of functions with `reflect`.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array|Object|Iterable} tasks - The collection of\n * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n * @returns {Array} Returns an array of async functions, each wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */\nfunction reflectAll(tasks) {\n    var results;\n    if (Array.isArray(tasks)) {\n        results = tasks.map(reflect);\n    } else {\n        results = {};\n        Object.keys(tasks).forEach(key => {\n            results[key] = reflect.call(this, tasks[key]);\n        });\n    }\n    return results;\n}\n\nfunction reject(eachfn, arr, _iteratee, callback) {\n    const iteratee = wrapAsync(_iteratee);\n    return _filter(eachfn, arr, (value, cb) => {\n        iteratee(value, (err, v) => {\n            cb(err, !v);\n        });\n    }, callback);\n}\n\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n *\n * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.reject(fileList, fileExists, function(err, results) {\n *    // [ 'dir3/file6.txt' ]\n *    // results now equals an array of the non-existing files\n * });\n *\n * // Using Promises\n * async.reject(fileList, fileExists)\n * .then( results => {\n *     console.log(results);\n *     // [ 'dir3/file6.txt' ]\n *     // results now equals an array of the non-existing files\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.reject(fileList, fileExists);\n *         console.log(results);\n *         // [ 'dir3/file6.txt' ]\n *         // results now equals an array of the non-existing files\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction reject$1 (coll, iteratee, callback) {\n    return reject(eachOf$1, coll, iteratee, callback)\n}\nvar reject$2 = awaitify(reject$1, 3);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction rejectLimit (coll, limit, iteratee, callback) {\n    return reject(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar rejectLimit$1 = awaitify(rejectLimit, 4);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction rejectSeries (coll, iteratee, callback) {\n    return reject(eachOfSeries$1, coll, iteratee, callback)\n}\nvar rejectSeries$1 = awaitify(rejectSeries, 3);\n\nfunction constant$1(value) {\n    return function () {\n        return value;\n    }\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @returns {Promise} a promise if no callback provided\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nconst DEFAULT_TIMES = 5;\nconst DEFAULT_INTERVAL = 0;\n\nfunction retry(opts, task, callback) {\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || promiseCallback();\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || promiseCallback();\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = wrapAsync(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task((err, ...args) => {\n            if (err === false) return\n            if (err && attempt++ < options.times &&\n                (typeof options.errorFilter != 'function' ||\n                    options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt - 1));\n            } else {\n                callback(err, ...args);\n            }\n        });\n    }\n\n    retryAttempt();\n    return callback[PROMISE_SYMBOL]\n}\n\nfunction parseTimes(acc, t) {\n    if (typeof t === 'object') {\n        acc.times = +t.times || DEFAULT_TIMES;\n\n        acc.intervalFunc = typeof t.interval === 'function' ?\n            t.interval :\n            constant$1(+t.interval || DEFAULT_INTERVAL);\n\n        acc.errorFilter = t.errorFilter;\n    } else if (typeof t === 'number' || typeof t === 'string') {\n        acc.times = +t || DEFAULT_TIMES;\n    } else {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n}\n\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n * wraps a task and makes it retryable, rather than immediately calling it\n * with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`, except for a `opts.arity` that\n * is the arity of the `task` function, defaulting to `task.length`\n * @param {AsyncFunction} task - the asynchronous function to wrap.\n * This function will be passed any arguments passed to the returned wrapper.\n * Invoked with (...args, callback).\n * @returns {AsyncFunction} The wrapped function, which when invoked, will\n * retry on an error, based on the parameters specified in `opts`.\n * This function will accept the same parameters as `task`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nfunction retryable (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    let arity = (opts && opts.arity) || task.length;\n    if (isAsync(task)) {\n        arity += 1;\n    }\n    var _task = wrapAsync(task);\n    return initialParams((args, callback) => {\n        if (args.length < arity - 1 || callback == null) {\n            args.push(callback);\n            callback = promiseCallback();\n        }\n        function taskFn(cb) {\n            _task(...args, cb);\n        }\n\n        if (opts) retry(opts, taskFn, callback);\n        else retry(taskFn, callback);\n\n        return callback[PROMISE_SYMBOL]\n    });\n}\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing\n * [async functions]{@link AsyncFunction} to run in series.\n * Each function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @return {Promise} a promise, if no callback is passed\n * @example\n *\n * //Using Callbacks\n * async.series([\n *     function(callback) {\n *         setTimeout(function() {\n *             // do some async task\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             // then do another async task\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ], function(err, results) {\n *     console.log(results);\n *     // results is equal to ['one','two']\n * });\n *\n * // an example using objects instead of arrays\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             // do some async task\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             // then do another async task\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * });\n *\n * //Using Promises\n * async.series([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ]).then(results => {\n *     console.log(results);\n *     // results is equal to ['one','two']\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // an example using an object instead of an array\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             // do some async task\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             // then do another async task\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }).then(results => {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.series([\n *             function(callback) {\n *                 setTimeout(function() {\n *                     // do some async task\n *                     callback(null, 'one');\n *                 }, 200);\n *             },\n *             function(callback) {\n *                 setTimeout(function() {\n *                     // then do another async task\n *                     callback(null, 'two');\n *                 }, 100);\n *             }\n *         ]);\n *         console.log(results);\n *         // results is equal to ['one','two']\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // an example using an object instead of an array\n * async () => {\n *     try {\n *         let results = await async.parallel({\n *             one: function(callback) {\n *                 setTimeout(function() {\n *                     // do some async task\n *                     callback(null, 1);\n *                 }, 200);\n *             },\n *            two: function(callback) {\n *                 setTimeout(function() {\n *                     // then do another async task\n *                     callback(null, 2);\n *                 }, 100);\n *            }\n *         });\n *         console.log(results);\n *         // results is equal to: { one: 1, two: 2 }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction series(tasks, callback) {\n    return _parallel(eachOfSeries$1, tasks, callback);\n}\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,\n *    function(err, result) {\n *        console.log(result);\n *        // true\n *        // result is true since some file in the list exists\n *    }\n *);\n *\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,\n *    function(err, result) {\n *        console.log(result);\n *        // false\n *        // result is false since none of the files exists\n *    }\n *);\n *\n * // Using Promises\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)\n * .then( result => {\n *     console.log(result);\n *     // true\n *     // result is true since some file in the list exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)\n * .then( result => {\n *     console.log(result);\n *     // false\n *     // result is false since none of the files exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);\n *         console.log(result);\n *         // true\n *         // result is true since some file in the list exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * async () => {\n *     try {\n *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);\n *         console.log(result);\n *         // false\n *         // result is false since none of the files exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction some(coll, iteratee, callback) {\n    return _createTester(Boolean, res => res)(eachOf$1, coll, iteratee, callback)\n}\nvar some$1 = awaitify(some, 3);\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */\nfunction someLimit(coll, limit, iteratee, callback) {\n    return _createTester(Boolean, res => res)(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar someLimit$1 = awaitify(someLimit, 4);\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in series.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */\nfunction someSeries(coll, iteratee, callback) {\n    return _createTester(Boolean, res => res)(eachOfSeries$1, coll, iteratee, callback)\n}\nvar someSeries$1 = awaitify(someSeries, 3);\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a value to use as the sort criteria as\n * its `result`.\n * Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback passed\n * @example\n *\n * // bigfile.txt is a file that is 251100 bytes in size\n * // mediumfile.txt is a file that is 11000 bytes in size\n * // smallfile.txt is a file that is 121 bytes in size\n *\n * // asynchronous function that returns the file size in bytes\n * function getFileSizeInBytes(file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,\n *     function(err, results) {\n *         if (err) {\n *             console.log(err);\n *         } else {\n *             console.log(results);\n *             // results is now the original array of files sorted by\n *             // file size (ascending by default), e.g.\n *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n *         }\n *     }\n * );\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {\n *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n *         if (getFileSizeErr) return callback(getFileSizeErr);\n *         callback(null, fileSize);\n *     });\n * }, function(err, results) {\n *         if (err) {\n *             console.log(err);\n *         } else {\n *             console.log(results);\n *             // results is now the original array of files sorted by\n *             // file size (ascending by default), e.g.\n *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n *         }\n *     }\n * );\n *\n * // descending order\n * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {\n *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n *         if (getFileSizeErr) {\n *             return callback(getFileSizeErr);\n *         }\n *         callback(null, fileSize * -1);\n *     });\n * }, function(err, results) {\n *         if (err) {\n *             console.log(err);\n *         } else {\n *             console.log(results);\n *             // results is now the original array of files sorted by\n *             // file size (ascending by default), e.g.\n *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']\n *         }\n *     }\n * );\n *\n * // Error handling\n * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,\n *     function(err, results) {\n *         if (err) {\n *             console.log(err);\n *             // [ Error: ENOENT: no such file or directory ]\n *         } else {\n *             console.log(results);\n *         }\n *     }\n * );\n *\n * // Using Promises\n * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n *     // results is now the original array of files sorted by\n *     // file size (ascending by default), e.g.\n *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error handling\n * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * (async () => {\n *     try {\n *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n *         console.log(results);\n *         // results is now the original array of files sorted by\n *         // file size (ascending by default), e.g.\n *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * })();\n *\n * // Error handling\n * async () => {\n *     try {\n *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n *         console.log(results);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */\nfunction sortBy (coll, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return map$1(coll, (x, iterCb) => {\n        _iteratee(x, (err, criteria) => {\n            if (err) return iterCb(err);\n            iterCb(err, {value: x, criteria});\n        });\n    }, (err, results) => {\n        if (err) return callback(err);\n        callback(null, results.sort(comparator).map(v => v.value));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria, b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\nvar sortBy$1 = awaitify(sortBy, 3);\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} asyncFn - The async function to limit in time.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n * of the control flow functions.\n * Invoke this function with the same parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var fn = wrapAsync(asyncFn);\n\n    return initialParams((args, callback) => {\n        var timedOut = false;\n        var timer;\n\n        function timeoutCallback() {\n            var name = asyncFn.name || 'anonymous';\n            var error  = new Error('Callback function \"' + name + '\" timed out.');\n            error.code = 'ETIMEDOUT';\n            if (info) {\n                error.info = info;\n            }\n            timedOut = true;\n            callback(error);\n        }\n\n        args.push((...cbArgs) => {\n            if (!timedOut) {\n                callback(...cbArgs);\n                clearTimeout(timer);\n            }\n        });\n\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        fn(...args);\n    });\n}\n\nfunction range(size) {\n    var result = Array(size);\n    while (size--) {\n        result[size] = size;\n    }\n    return result;\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n * @returns {Promise} a promise, if no callback is provided\n */\nfunction timesLimit(count, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(range(count), limit, _iteratee, callback);\n}\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @returns {Promise} a promise, if no callback is provided\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nfunction times (n, iteratee, callback) {\n    return timesLimit(n, Infinity, iteratee, callback)\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @returns {Promise} a promise, if no callback is provided\n */\nfunction timesSeries (n, iteratee, callback) {\n    return timesLimit(n, 1, iteratee, callback)\n}\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in parallel, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n *\n * // helper function that returns human-readable size format from bytes\n * function formatBytes(bytes, decimals = 2) {\n *   // implementation not included for brevity\n *   return humanReadbleFilesize;\n * }\n *\n * const fileList = ['file1.txt','file2.txt','file3.txt'];\n *\n * // asynchronous function that returns the file size, transformed to human-readable format\n * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n * function transformFileSize(acc, value, key, callback) {\n *     fs.stat(value, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         acc[key] = formatBytes(stat.size);\n *         callback(null);\n *     });\n * }\n *\n * // Using callbacks\n * async.transform(fileList, transformFileSize, function(err, result) {\n *     if(err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n *     }\n * });\n *\n * // Using Promises\n * async.transform(fileList, transformFileSize)\n * .then(result => {\n *     console.log(result);\n *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * (async () => {\n *     try {\n *         let result = await async.transform(fileList, transformFileSize);\n *         console.log(result);\n *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * })();\n *\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n *\n * // helper function that returns human-readable size format from bytes\n * function formatBytes(bytes, decimals = 2) {\n *   // implementation not included for brevity\n *   return humanReadbleFilesize;\n * }\n *\n * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };\n *\n * // asynchronous function that returns the file size, transformed to human-readable format\n * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n * function transformFileSize(acc, value, key, callback) {\n *     fs.stat(value, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         acc[key] = formatBytes(stat.size);\n *         callback(null);\n *     });\n * }\n *\n * // Using callbacks\n * async.transform(fileMap, transformFileSize, function(err, result) {\n *     if(err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n *     }\n * });\n *\n * // Using Promises\n * async.transform(fileMap, transformFileSize)\n * .then(result => {\n *     console.log(result);\n *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.transform(fileMap, transformFileSize);\n *         console.log(result);\n *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction transform (coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3 && typeof accumulator === 'function') {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = Array.isArray(coll) ? [] : {};\n    }\n    callback = once(callback || promiseCallback());\n    var _iteratee = wrapAsync(iteratee);\n\n    eachOf$1(coll, (v, k, cb) => {\n        _iteratee(accumulator, v, k, cb);\n    }, err => callback(err, accumulator));\n    return callback[PROMISE_SYMBOL]\n}\n\n/**\n * It runs each task in series but stops whenever any of the functions were\n * successful. If one of the tasks were successful, the `callback` will be\n * passed the result of the successful task. If all tasks fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name tryEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to\n * run, each function is passed a `callback(err, result)` it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {Function} [callback] - An optional callback which is called when one\n * of the tasks has succeeded, or all have failed. It receives the `err` and\n * `result` arguments of the last attempt at completing the `task`. Invoked with\n * (err, results).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n * async.tryEach([\n *     function getDataFromFirstWebsite(callback) {\n *         // Try getting the data from the first website\n *         callback(err, data);\n *     },\n *     function getDataFromSecondWebsite(callback) {\n *         // First website failed,\n *         // Try getting the data from the backup website\n *         callback(err, data);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     Now do something with the data.\n * });\n *\n */\nfunction tryEach(tasks, callback) {\n    var error = null;\n    var result;\n    return eachSeries$1(tasks, (task, taskCb) => {\n        wrapAsync(task)((err, ...args) => {\n            if (err === false) return taskCb(err);\n\n            if (args.length < 2) {\n                [result] = args;\n            } else {\n                result = args;\n            }\n            error = err;\n            taskCb(err ? null : {});\n        });\n    }, () => callback(error, result));\n}\n\nvar tryEach$1 = awaitify(tryEach);\n\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {AsyncFunction} fn - the memoized function\n * @returns {AsyncFunction} a function that calls the original unmemoized function\n */\nfunction unmemoize(fn) {\n    return (...args) => {\n        return (fn.unmemoized || fn)(...args);\n    };\n}\n\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function test(cb) { cb(null, count < 5); },\n *     function iter(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nfunction whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback);\n    var _fn = wrapAsync(iteratee);\n    var _test = wrapAsync(test);\n    var results = [];\n\n    function next(err, ...rest) {\n        if (err) return callback(err);\n        results = rest;\n        if (err === false) return;\n        _test(check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (err === false) return;\n        if (!truth) return callback(null, ...results);\n        _fn(next);\n    }\n\n    return _test(check);\n}\nvar whilst$1 = awaitify(whilst, 3);\n\n/**\n * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `iteratee`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `iteratee`. Invoked with (callback).\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if a callback is not passed\n *\n * @example\n * const results = []\n * let finished = false\n * async.until(function test(cb) {\n *     cb(null, finished)\n * }, function iter(next) {\n *     fetchPage(url, (err, body) => {\n *         if (err) return next(err)\n *         results = results.concat(body.objects)\n *         finished = !!body.next\n *         next(err)\n *     })\n * }, function done (err) {\n *     // all pages have been fetched\n * })\n */\nfunction until(test, iteratee, callback) {\n    const _test = wrapAsync(test);\n    return whilst$1((cb) => _test((err, truth) => cb (err, !truth)), iteratee, callback);\n}\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nfunction waterfall (tasks, callback) {\n    callback = once(callback);\n    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = wrapAsync(tasks[taskIndex++]);\n        task(...args, onlyOnce(next));\n    }\n\n    function next(err, ...args) {\n        if (err === false) return\n        if (err || taskIndex === tasks.length) {\n            return callback(err, ...args);\n        }\n        nextTask(args);\n    }\n\n    nextTask([]);\n}\n\nvar waterfall$1 = awaitify(waterfall);\n\n/**\n * An \"async function\" in the context of Async is an asynchronous function with\n * a variable number of parameters, with the final parameter being a callback.\n * (`function (arg1, arg2, ..., callback) {}`)\n * The final callback is of the form `callback(err, results...)`, which must be\n * called once the function is completed.  The callback should be called with a\n * Error as its first argument to signal that an error occurred.\n * Otherwise, if no error occurred, it should be called with `null` as the first\n * argument, and any additional `result` arguments that may apply, to signal\n * successful completion.\n * The callback must be called exactly once, ideally on a later tick of the\n * JavaScript event loop.\n *\n * This type of function is also referred to as a \"Node-style async function\",\n * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n * library are themselves CPS/Node-style async functions, or functions that\n * return CPS/Node-style async functions.\n *\n * Wherever we accept a Node-style async function, we also directly accept an\n * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n * In this case, the `async` function will not be passed a final callback\n * argument, and any thrown error will be used as the `err` argument of the\n * implicit callback, and the return value will be used as the `result` value.\n * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n * argument, and a `resolved` value becomes the `result`.)\n *\n * Note, due to JavaScript limitations, we can only detect native `async`\n * functions and not transpilied implementations.\n * Your environment must have `async`/`await` support for this to work.\n * (e.g. Node > v7.6, or a recent version of a modern browser).\n * If you are using `async` functions through a transpiler (e.g. Babel), you\n * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n * because the `async function` will be compiled to an ordinary function that\n * returns a promise.\n *\n * @typedef {Function} AsyncFunction\n * @static\n */\n\nvar index = {\n    apply,\n    applyEach: applyEach$1,\n    applyEachSeries,\n    asyncify,\n    auto,\n    autoInject,\n    cargo,\n    cargoQueue: cargo$1,\n    compose,\n    concat: concat$1,\n    concatLimit: concatLimit$1,\n    concatSeries: concatSeries$1,\n    constant,\n    detect: detect$1,\n    detectLimit: detectLimit$1,\n    detectSeries: detectSeries$1,\n    dir,\n    doUntil,\n    doWhilst: doWhilst$1,\n    each,\n    eachLimit: eachLimit$2,\n    eachOf: eachOf$1,\n    eachOfLimit: eachOfLimit$2,\n    eachOfSeries: eachOfSeries$1,\n    eachSeries: eachSeries$1,\n    ensureAsync,\n    every: every$1,\n    everyLimit: everyLimit$1,\n    everySeries: everySeries$1,\n    filter: filter$1,\n    filterLimit: filterLimit$1,\n    filterSeries: filterSeries$1,\n    forever: forever$1,\n    groupBy,\n    groupByLimit: groupByLimit$1,\n    groupBySeries,\n    log,\n    map: map$1,\n    mapLimit: mapLimit$1,\n    mapSeries: mapSeries$1,\n    mapValues,\n    mapValuesLimit: mapValuesLimit$1,\n    mapValuesSeries,\n    memoize,\n    nextTick,\n    parallel,\n    parallelLimit,\n    priorityQueue,\n    queue: queue$1,\n    race: race$1,\n    reduce: reduce$1,\n    reduceRight,\n    reflect,\n    reflectAll,\n    reject: reject$2,\n    rejectLimit: rejectLimit$1,\n    rejectSeries: rejectSeries$1,\n    retry,\n    retryable,\n    seq,\n    series,\n    setImmediate: setImmediate$1,\n    some: some$1,\n    someLimit: someLimit$1,\n    someSeries: someSeries$1,\n    sortBy: sortBy$1,\n    timeout,\n    times,\n    timesLimit,\n    timesSeries,\n    transform,\n    tryEach: tryEach$1,\n    unmemoize,\n    until,\n    waterfall: waterfall$1,\n    whilst: whilst$1,\n\n    // aliases\n    all: every$1,\n    allLimit: everyLimit$1,\n    allSeries: everySeries$1,\n    any: some$1,\n    anyLimit: someLimit$1,\n    anySeries: someSeries$1,\n    find: detect$1,\n    findLimit: detectLimit$1,\n    findSeries: detectSeries$1,\n    flatMap: concat$1,\n    flatMapLimit: concatLimit$1,\n    flatMapSeries: concatSeries$1,\n    forEach: each,\n    forEachSeries: eachSeries$1,\n    forEachLimit: eachLimit$2,\n    forEachOf: eachOf$1,\n    forEachOfSeries: eachOfSeries$1,\n    forEachOfLimit: eachOfLimit$2,\n    inject: reduce$1,\n    foldl: reduce$1,\n    foldr: reduceRight,\n    select: filter$1,\n    selectLimit: filterLimit$1,\n    selectSeries: filterSeries$1,\n    wrapSync: asyncify,\n    during: whilst$1,\n    doDuring: doWhilst$1\n};\n\nexport default index;\nexport { apply, applyEach$1 as applyEach, applyEachSeries, asyncify, auto, autoInject, cargo, cargo$1 as cargoQueue, compose, concat$1 as concat, concatLimit$1 as concatLimit, concatSeries$1 as concatSeries, constant, detect$1 as detect, detectLimit$1 as detectLimit, detectSeries$1 as detectSeries, dir, doUntil, doWhilst$1 as doWhilst, each, eachLimit$2 as eachLimit, eachOf$1 as eachOf, eachOfLimit$2 as eachOfLimit, eachOfSeries$1 as eachOfSeries, eachSeries$1 as eachSeries, ensureAsync, every$1 as every, everyLimit$1 as everyLimit, everySeries$1 as everySeries, filter$1 as filter, filterLimit$1 as filterLimit, filterSeries$1 as filterSeries, forever$1 as forever, groupBy, groupByLimit$1 as groupByLimit, groupBySeries, log, map$1 as map, mapLimit$1 as mapLimit, mapSeries$1 as mapSeries, mapValues, mapValuesLimit$1 as mapValuesLimit, mapValuesSeries, memoize, nextTick, parallel, parallelLimit, priorityQueue, queue$1 as queue, race$1 as race, reduce$1 as reduce, reduceRight, reflect, reflectAll, reject$2 as reject, rejectLimit$1 as rejectLimit, rejectSeries$1 as rejectSeries, retry, retryable, seq, series, setImmediate$1 as setImmediate, some$1 as some, someLimit$1 as someLimit, someSeries$1 as someSeries, sortBy$1 as sortBy, timeout, times, timesLimit, timesSeries, transform, tryEach$1 as tryEach, unmemoize, until, waterfall$1 as waterfall, whilst$1 as whilst, every$1 as all, everyLimit$1 as allLimit, everySeries$1 as allSeries, some$1 as any, someLimit$1 as anyLimit, someSeries$1 as anySeries, detect$1 as find, detectLimit$1 as findLimit, detectSeries$1 as findSeries, concat$1 as flatMap, concatLimit$1 as flatMapLimit, concatSeries$1 as flatMapSeries, each as forEach, eachSeries$1 as forEachSeries, eachLimit$2 as forEachLimit, eachOf$1 as forEachOf, eachOfSeries$1 as forEachOfSeries, eachOfLimit$2 as forEachOfLimit, reduce$1 as inject, reduce$1 as foldl, reduceRight as foldr, filter$1 as select, filterLimit$1 as selectLimit, filterSeries$1 as selectSeries, asyncify as wrapSync, whilst$1 as during, doWhilst$1 as doDuring };\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst UMAP_1 = require(\"../../Utility/UMAP\");\r\nrequire(\"regenerator-runtime/runtime\");\r\nconst umap_1 = require(\"../../Utility/UMAP/umap\");\r\n/**\r\n * Worker thread that computes a stepwise projection\r\n */\r\nself.addEventListener('message', function (e) {\r\n    let context = self;\r\n    if (e.data.messageType == 'init') {\r\n        context.raw = e.data;\r\n        context.umap = new UMAP_1.UMAP({\r\n            nNeighbors: e.data.params.nNeighbors,\r\n            distanceFn: e.data.params.distanceMetric == 'euclidean' ? umap_1.euclidean : umap_1.jaccard\r\n        });\r\n        context.umap.initializeFit(e.data.input, e.data.params.seeded ? e.data.seed : undefined);\r\n        context.umap.step();\r\n        context.postMessage(context.umap.getEmbedding());\r\n    }\r\n    else {\r\n        context.umap.step();\r\n        context.postMessage(context.umap.getEmbedding());\r\n    }\r\n}, false);\r\nexports.default = null;\r\n","const toString = Object.prototype.toString;\n\nexport default function isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n","/*\n * jaccard\n * <cam@campedersen.com>\n */\n\nvar async = require('async');\n\n/*\n * Return mutual elements in the input sets\n */\nvar intersection = function (a, b, c) {\n  var x = [];\n  var check = function (e, cb) {\n    if (~b.indexOf(e)) x.push(e);\n    if (cb && typeof cb == 'function') cb(null);\n  };\n\n  if (c) {\n    async.forEach(a, check, function () {\n      c(null, x);\n    });\n  } else {\n    a.forEach(check);\n    return x;\n  }\n}\n\n/*\n * Return distinct elements from both input sets\n */\nvar union = function (a, b, c) {\n  var x = [];\n  var check = function (e, cb) {\n    if (!~x.indexOf(e)) x.push(e);\n    if (cb && typeof cb == 'function') cb(null);\n  }\n\n  if (c) {\n    var waiting = 2;\n    var asyncCheck = function () {\n      if (--waiting == 0) {\n        c(null, x);\n      }\n    }\n    async.forEach(a, check, asyncCheck);\n    async.forEach(b, check, asyncCheck);\n  } else {\n    a.forEach(check);\n    b.forEach(check);\n    return x;\n  }\n}\n\n/*\n * Similarity\n */\nvar index = function (a, b, c) {\n  if (c) {\n    async.parallel({\n      intersection: function (cb) {\n        intersection(a, b, cb);\n      },\n      union: function (cb) {\n        union(a, b, cb);\n      }\n    }, function (err, results) {\n      c(results.intersection.length / results.union.length);\n    });\n  } else {\n    return intersection(a, b).length / union(a, b).length;\n  }\n}\n\n/*\n * Dissimilarity\n */\nvar distance = function (a, b, c) {\n  if (c) {\n    c(1 - index(a, b));\n  } else {\n    return 1 - index(a, b);\n  }\n}\n\n/*\n * Say cheese\n */\nmodule.exports = {\n  index: index,\n  distance: distance\n}\n","import isArray from 'is-any-array';\n\nfunction max(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var _options$fromIndex = options.fromIndex,\n      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,\n      _options$toIndex = options.toIndex,\n      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;\n\n  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {\n    throw new Error('fromIndex must be a positive integer smaller than length');\n  }\n\n  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {\n    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');\n  }\n\n  var maxValue = input[fromIndex];\n\n  for (var i = fromIndex + 1; i < toIndex; i++) {\n    if (input[i] > maxValue) maxValue = input[i];\n  }\n\n  return maxValue;\n}\n\nexport default max;\n","const toString = Object.prototype.toString;\n\nexport default function isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n","import isArray from 'is-any-array';\n\nfunction min(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var _options$fromIndex = options.fromIndex,\n      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,\n      _options$toIndex = options.toIndex,\n      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;\n\n  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {\n    throw new Error('fromIndex must be a positive integer smaller than length');\n  }\n\n  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {\n    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');\n  }\n\n  var minValue = input[fromIndex];\n\n  for (var i = fromIndex + 1; i < toIndex; i++) {\n    if (input[i] < minValue) minValue = input[i];\n  }\n\n  return minValue;\n}\n\nexport default min;\n","const toString = Object.prototype.toString;\n\nexport default function isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n","import isArray from 'is-any-array';\nimport max from 'ml-array-max';\nimport min from 'ml-array-min';\n\nfunction rescale(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  } else if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var output;\n\n  if (options.output !== undefined) {\n    if (!isArray(options.output)) {\n      throw new TypeError('output option must be an array if specified');\n    }\n\n    output = options.output;\n  } else {\n    output = new Array(input.length);\n  }\n\n  var currentMin = min(input);\n  var currentMax = max(input);\n\n  if (currentMin === currentMax) {\n    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');\n  }\n\n  var _options$min = options.min,\n      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,\n      _options$max = options.max,\n      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;\n\n  if (minValue >= maxValue) {\n    throw new RangeError('min option must be smaller than max option');\n  }\n\n  var factor = (maxValue - minValue) / (currentMax - currentMin);\n\n  for (var i = 0; i < input.length; i++) {\n    output[i] = (input[i] - currentMin) * factor + minValue;\n  }\n\n  return output;\n}\n\nexport { rescale as default };\n","const toString = Object.prototype.toString;\n\nexport default function isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n","/**\n * Calculate current error\n * @ignore\n * @param {{x:Array<number>, y:Array<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]\n * @param {Array<number>} parameters - Array of current parameter values\n * @param {function} parameterizedFunction - The parameters and returns a function with the independent variable as a parameter\n * @return {number}\n */\nexport default function errorCalculation(\n  data,\n  parameters,\n  parameterizedFunction,\n) {\n  let error = 0;\n  const func = parameterizedFunction(parameters);\n\n  for (let i = 0; i < data.x.length; i++) {\n    error += Math.abs(data.y[i] - func(data.x[i]));\n  }\n\n  return error;\n}\n","import isArray from 'is-any-array';\n\nimport errorCalculation from './errorCalculation';\nimport step from './step';\n\n/**\n * Curve fitting algorithm\n * @param {{x:Array<number>, y:Array<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]\n * @param {function} parameterizedFunction - The parameters and returns a function with the independent variable as a parameter\n * @param {object} [options] - Options object\n * @param {number} [options.damping] - Levenberg-Marquardt parameter\n * @param {number} [options.gradientDifference = 10e-2] - Adjustment for decrease the damping parameter\n * @param {Array<number>} [options.minValues] - Minimum allowed values for parameters\n * @param {Array<number>} [options.maxValues] - Maximum allowed values for parameters\n * @param {Array<number>} [options.initialValues] - Array of initial parameter values\n * @param {number} [options.maxIterations = 100] - Maximum of allowed iterations\n * @param {number} [options.errorTolerance = 10e-3] - Minimum uncertainty allowed for each point\n * @return {{parameterValues: Array<number>, parameterError: number, iterations: number}}\n */\nexport default function levenbergMarquardt(\n  data,\n  parameterizedFunction,\n  options = {},\n) {\n  let {\n    maxIterations = 100,\n    gradientDifference = 10e-2,\n    damping = 0,\n    errorTolerance = 10e-3,\n    minValues,\n    maxValues,\n    initialValues,\n  } = options;\n\n  if (damping <= 0) {\n    throw new Error('The damping option must be a positive number');\n  } else if (!data.x || !data.y) {\n    throw new Error('The data parameter must have x and y elements');\n  } else if (\n    !isArray(data.x) ||\n    data.x.length < 2 ||\n    !isArray(data.y) ||\n    data.y.length < 2\n  ) {\n    throw new Error(\n      'The data parameter elements must be an array with more than 2 points',\n    );\n  } else if (data.x.length !== data.y.length) {\n    throw new Error('The data parameter elements must have the same size');\n  }\n\n  let parameters =\n    initialValues || new Array(parameterizedFunction.length).fill(1);\n  let parLen = parameters.length;\n  maxValues = maxValues || new Array(parLen).fill(Number.MAX_SAFE_INTEGER);\n  minValues = minValues || new Array(parLen).fill(Number.MIN_SAFE_INTEGER);\n\n  if (maxValues.length !== minValues.length) {\n    throw new Error('minValues and maxValues must be the same size');\n  }\n\n  if (!isArray(parameters)) {\n    throw new Error('initialValues must be an array');\n  }\n\n  let error = errorCalculation(data, parameters, parameterizedFunction);\n\n  let converged = error <= errorTolerance;\n\n  let iteration;\n  for (iteration = 0; iteration < maxIterations && !converged; iteration++) {\n    parameters = step(\n      data,\n      parameters,\n      damping,\n      gradientDifference,\n      parameterizedFunction,\n    );\n\n    for (let k = 0; k < parLen; k++) {\n      parameters[k] = Math.min(\n        Math.max(minValues[k], parameters[k]),\n        maxValues[k],\n      );\n    }\n\n    error = errorCalculation(data, parameters, parameterizedFunction);\n    if (isNaN(error)) break;\n    converged = error <= errorTolerance;\n  }\n\n  return {\n    parameterValues: parameters,\n    parameterError: error,\n    iterations: iteration,\n  };\n}\n","import { inverse, Matrix } from 'ml-matrix';\n\n/**\n * Difference of the matrix function over the parameters\n * @ignore\n * @param {{x:Array<number>, y:Array<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]\n * @param {Array<number>} evaluatedData - Array of previous evaluated function values\n * @param {Array<number>} params - Array of previous parameter values\n * @param {number} gradientDifference - Adjustment for decrease the damping parameter\n * @param {function} paramFunction - The parameters and returns a function with the independent variable as a parameter\n * @return {Matrix}\n */\nfunction gradientFunction(\n  data,\n  evaluatedData,\n  params,\n  gradientDifference,\n  paramFunction,\n) {\n  const n = params.length;\n  const m = data.x.length;\n\n  let ans = new Array(n);\n\n  for (let param = 0; param < n; param++) {\n    ans[param] = new Array(m);\n    let auxParams = params.slice();\n    auxParams[param] += gradientDifference;\n    let funcParam = paramFunction(auxParams);\n\n    for (let point = 0; point < m; point++) {\n      ans[param][point] = evaluatedData[point] - funcParam(data.x[point]);\n    }\n  }\n  return new Matrix(ans);\n}\n\n/**\n * Matrix function over the samples\n * @ignore\n * @param {{x:Array<number>, y:Array<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]\n * @param {Array<number>} evaluatedData - Array of previous evaluated function values\n * @return {Matrix}\n */\nfunction matrixFunction(data, evaluatedData) {\n  const m = data.x.length;\n\n  let ans = new Array(m);\n\n  for (let point = 0; point < m; point++) {\n    ans[point] = [data.y[point] - evaluatedData[point]];\n  }\n\n  return new Matrix(ans);\n}\n\n/**\n * Iteration for Levenberg-Marquardt\n * @ignore\n * @param {{x:Array<number>, y:Array<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]\n * @param {Array<number>} params - Array of previous parameter values\n * @param {number} damping - Levenberg-Marquardt parameter\n * @param {number} gradientDifference - Adjustment for decrease the damping parameter\n * @param {function} parameterizedFunction - The parameters and returns a function with the independent variable as a parameter\n * @return {Array<number>}\n */\nexport default function step(\n  data,\n  params,\n  damping,\n  gradientDifference,\n  parameterizedFunction,\n) {\n  let value = damping * gradientDifference * gradientDifference;\n  let identity = Matrix.eye(params.length, params.length, value);\n\n  const func = parameterizedFunction(params);\n\n  let evaluatedData = new Float64Array(data.x.length);\n  for (let i = 0; i < data.x.length; i++) {\n    evaluatedData[i] = func(data.x[i]);\n  }\n\n  let gradientFunc = gradientFunction(\n    data,\n    evaluatedData,\n    params,\n    gradientDifference,\n    parameterizedFunction,\n  );\n  let matrixFunc = matrixFunction(data, evaluatedData);\n  let inverseMatrix = inverse(\n    identity.add(gradientFunc.mmul(gradientFunc.transpose())),\n  );\n\n  params = new Matrix([params]);\n  params = params.sub(\n    inverseMatrix\n      .mmul(gradientFunc)\n      .mmul(matrixFunc)\n      .mul(gradientDifference)\n      .transpose(),\n  );\n\n  return params.to1DArray();\n}\n","import Matrix from './matrix';\n\nexport function correlation(xMatrix, yMatrix = xMatrix, options = {}) {\n  xMatrix = new Matrix(xMatrix);\n  let yIsSame = false;\n  if (\n    typeof yMatrix === 'object' &&\n    !Matrix.isMatrix(yMatrix) &&\n    !Array.isArray(yMatrix)\n  ) {\n    options = yMatrix;\n    yMatrix = xMatrix;\n    yIsSame = true;\n  } else {\n    yMatrix = new Matrix(yMatrix);\n  }\n  if (xMatrix.rows !== yMatrix.rows) {\n    throw new TypeError('Both matrices must have the same number of rows');\n  }\n\n  const { center = true, scale = true } = options;\n  if (center) {\n    xMatrix.center('column');\n    if (!yIsSame) {\n      yMatrix.center('column');\n    }\n  }\n  if (scale) {\n    xMatrix.scale('column');\n    if (!yIsSame) {\n      yMatrix.scale('column');\n    }\n  }\n\n  const sdx = xMatrix.standardDeviation('column', { unbiased: true });\n  const sdy = yIsSame\n    ? sdx\n    : yMatrix.standardDeviation('column', { unbiased: true });\n\n  const corr = xMatrix.transpose().mmul(yMatrix);\n  for (let i = 0; i < corr.rows; i++) {\n    for (let j = 0; j < corr.columns; j++) {\n      corr.set(\n        i,\n        j,\n        corr.get(i, j) * (1 / (sdx[i] * sdy[j])) * (1 / (xMatrix.rows - 1)),\n      );\n    }\n  }\n  return corr;\n}\n","import Matrix from './matrix';\n\nexport function covariance(xMatrix, yMatrix = xMatrix, options = {}) {\n  xMatrix = new Matrix(xMatrix);\n  let yIsSame = false;\n  if (\n    typeof yMatrix === 'object' &&\n    !Matrix.isMatrix(yMatrix) &&\n    !Array.isArray(yMatrix)\n  ) {\n    options = yMatrix;\n    yMatrix = xMatrix;\n    yIsSame = true;\n  } else {\n    yMatrix = new Matrix(yMatrix);\n  }\n  if (xMatrix.rows !== yMatrix.rows) {\n    throw new TypeError('Both matrices must have the same number of rows');\n  }\n  const { center = true } = options;\n  if (center) {\n    xMatrix = xMatrix.center('column');\n    if (!yIsSame) {\n      yMatrix = yMatrix.center('column');\n    }\n  }\n  const cov = xMatrix.transpose().mmul(yMatrix);\n  for (let i = 0; i < cov.rows; i++) {\n    for (let j = 0; j < cov.columns; j++) {\n      cov.set(i, j, cov.get(i, j) * (1 / (xMatrix.rows - 1)));\n    }\n  }\n  return cov;\n}\n","import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nexport default class CholeskyDecomposition {\n  constructor(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n    if (!value.isSymmetric()) {\n      throw new Error('Matrix is not symmetric');\n    }\n\n    let a = value;\n    let dimension = a.rows;\n    let l = new Matrix(dimension, dimension);\n    let positiveDefinite = true;\n    let i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n      let d = 0;\n      for (k = 0; k < j; k++) {\n        let s = 0;\n        for (i = 0; i < k; i++) {\n          s += l.get(k, i) * l.get(j, i);\n        }\n        s = (a.get(j, k) - s) / l.get(k, k);\n        l.set(j, k, s);\n        d = d + s * s;\n      }\n\n      d = a.get(j, j) - d;\n\n      positiveDefinite &= d > 0;\n      l.set(j, j, Math.sqrt(Math.max(d, 0)));\n      for (k = j + 1; k < dimension; k++) {\n        l.set(j, k, 0);\n      }\n    }\n\n    this.L = l;\n    this.positiveDefinite = Boolean(positiveDefinite);\n  }\n\n  isPositiveDefinite() {\n    return this.positiveDefinite;\n  }\n\n  solve(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    let l = this.L;\n    let dimension = l.rows;\n\n    if (value.rows !== dimension) {\n      throw new Error('Matrix dimensions do not match');\n    }\n    if (this.isPositiveDefinite() === false) {\n      throw new Error('Matrix is not positive definite');\n    }\n\n    let count = value.columns;\n    let B = value.clone();\n    let i, j, k;\n\n    for (k = 0; k < dimension; k++) {\n      for (j = 0; j < count; j++) {\n        for (i = 0; i < k; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    for (k = dimension - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        for (i = k + 1; i < dimension; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    return B;\n  }\n\n  get lowerTriangularMatrix() {\n    return this.L;\n  }\n}\n","import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nimport { hypotenuse } from './util';\n\nexport default class EigenvalueDecomposition {\n  constructor(matrix, options = {}) {\n    const { assumeSymmetric = false } = options;\n\n    matrix = WrapperMatrix2D.checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n      throw new Error('Matrix is not a square matrix');\n    }\n\n    if (matrix.isEmpty()) {\n      throw new Error('Matrix must be non-empty');\n    }\n\n    let n = matrix.columns;\n    let V = new Matrix(n, n);\n    let d = new Float64Array(n);\n    let e = new Float64Array(n);\n    let value = matrix;\n    let i, j;\n\n    let isSymmetric = false;\n    if (assumeSymmetric) {\n      isSymmetric = true;\n    } else {\n      isSymmetric = matrix.isSymmetric();\n    }\n\n    if (isSymmetric) {\n      for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          V.set(i, j, value.get(i, j));\n        }\n      }\n      tred2(n, e, d, V);\n      tql2(n, e, d, V);\n    } else {\n      let H = new Matrix(n, n);\n      let ort = new Float64Array(n);\n      for (j = 0; j < n; j++) {\n        for (i = 0; i < n; i++) {\n          H.set(i, j, value.get(i, j));\n        }\n      }\n      orthes(n, H, ort, V);\n      hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n  }\n\n  get realEigenvalues() {\n    return Array.from(this.d);\n  }\n\n  get imaginaryEigenvalues() {\n    return Array.from(this.e);\n  }\n\n  get eigenvectorMatrix() {\n    return this.V;\n  }\n\n  get diagonalMatrix() {\n    let n = this.n;\n    let e = this.e;\n    let d = this.d;\n    let X = new Matrix(n, n);\n    let i, j;\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        X.set(i, j, 0);\n      }\n      X.set(i, i, d[i]);\n      if (e[i] > 0) {\n        X.set(i, i + 1, e[i]);\n      } else if (e[i] < 0) {\n        X.set(i, i - 1, e[i]);\n      }\n    }\n    return X;\n  }\n}\n\nfunction tred2(n, e, d, V) {\n  let f, g, h, i, j, k, hh, scale;\n\n  for (j = 0; j < n; j++) {\n    d[j] = V.get(n - 1, j);\n  }\n\n  for (i = n - 1; i > 0; i--) {\n    scale = 0;\n    h = 0;\n    for (k = 0; k < i; k++) {\n      scale = scale + Math.abs(d[k]);\n    }\n\n    if (scale === 0) {\n      e[i] = d[i - 1];\n      for (j = 0; j < i; j++) {\n        d[j] = V.get(i - 1, j);\n        V.set(i, j, 0);\n        V.set(j, i, 0);\n      }\n    } else {\n      for (k = 0; k < i; k++) {\n        d[k] /= scale;\n        h += d[k] * d[k];\n      }\n\n      f = d[i - 1];\n      g = Math.sqrt(h);\n      if (f > 0) {\n        g = -g;\n      }\n\n      e[i] = scale * g;\n      h = h - f * g;\n      d[i - 1] = f - g;\n      for (j = 0; j < i; j++) {\n        e[j] = 0;\n      }\n\n      for (j = 0; j < i; j++) {\n        f = d[j];\n        V.set(j, i, f);\n        g = e[j] + V.get(j, j) * f;\n        for (k = j + 1; k <= i - 1; k++) {\n          g += V.get(k, j) * d[k];\n          e[k] += V.get(k, j) * f;\n        }\n        e[j] = g;\n      }\n\n      f = 0;\n      for (j = 0; j < i; j++) {\n        e[j] /= h;\n        f += e[j] * d[j];\n      }\n\n      hh = f / (h + h);\n      for (j = 0; j < i; j++) {\n        e[j] -= hh * d[j];\n      }\n\n      for (j = 0; j < i; j++) {\n        f = d[j];\n        g = e[j];\n        for (k = j; k <= i - 1; k++) {\n          V.set(k, j, V.get(k, j) - (f * e[k] + g * d[k]));\n        }\n        d[j] = V.get(i - 1, j);\n        V.set(i, j, 0);\n      }\n    }\n    d[i] = h;\n  }\n\n  for (i = 0; i < n - 1; i++) {\n    V.set(n - 1, i, V.get(i, i));\n    V.set(i, i, 1);\n    h = d[i + 1];\n    if (h !== 0) {\n      for (k = 0; k <= i; k++) {\n        d[k] = V.get(k, i + 1) / h;\n      }\n\n      for (j = 0; j <= i; j++) {\n        g = 0;\n        for (k = 0; k <= i; k++) {\n          g += V.get(k, i + 1) * V.get(k, j);\n        }\n        for (k = 0; k <= i; k++) {\n          V.set(k, j, V.get(k, j) - g * d[k]);\n        }\n      }\n    }\n\n    for (k = 0; k <= i; k++) {\n      V.set(k, i + 1, 0);\n    }\n  }\n\n  for (j = 0; j < n; j++) {\n    d[j] = V.get(n - 1, j);\n    V.set(n - 1, j, 0);\n  }\n\n  V.set(n - 1, n - 1, 1);\n  e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n  let g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2, iter;\n\n  for (i = 1; i < n; i++) {\n    e[i - 1] = e[i];\n  }\n\n  e[n - 1] = 0;\n\n  let f = 0;\n  let tst1 = 0;\n  let eps = Number.EPSILON;\n\n  for (l = 0; l < n; l++) {\n    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n    m = l;\n    while (m < n) {\n      if (Math.abs(e[m]) <= eps * tst1) {\n        break;\n      }\n      m++;\n    }\n\n    if (m > l) {\n      iter = 0;\n      do {\n        iter = iter + 1;\n\n        g = d[l];\n        p = (d[l + 1] - g) / (2 * e[l]);\n        r = hypotenuse(p, 1);\n        if (p < 0) {\n          r = -r;\n        }\n\n        d[l] = e[l] / (p + r);\n        d[l + 1] = e[l] * (p + r);\n        dl1 = d[l + 1];\n        h = g - d[l];\n        for (i = l + 2; i < n; i++) {\n          d[i] -= h;\n        }\n\n        f = f + h;\n\n        p = d[m];\n        c = 1;\n        c2 = c;\n        c3 = c;\n        el1 = e[l + 1];\n        s = 0;\n        s2 = 0;\n        for (i = m - 1; i >= l; i--) {\n          c3 = c2;\n          c2 = c;\n          s2 = s;\n          g = c * e[i];\n          h = c * p;\n          r = hypotenuse(p, e[i]);\n          e[i + 1] = s * r;\n          s = e[i] / r;\n          c = p / r;\n          p = c * d[i] - s * g;\n          d[i + 1] = h + s * (c * g + s * d[i]);\n\n          for (k = 0; k < n; k++) {\n            h = V.get(k, i + 1);\n            V.set(k, i + 1, s * V.get(k, i) + c * h);\n            V.set(k, i, c * V.get(k, i) - s * h);\n          }\n        }\n\n        p = (-s * s2 * c3 * el1 * e[l]) / dl1;\n        e[l] = s * p;\n        d[l] = c * p;\n      } while (Math.abs(e[l]) > eps * tst1);\n    }\n    d[l] = d[l] + f;\n    e[l] = 0;\n  }\n\n  for (i = 0; i < n - 1; i++) {\n    k = i;\n    p = d[i];\n    for (j = i + 1; j < n; j++) {\n      if (d[j] < p) {\n        k = j;\n        p = d[j];\n      }\n    }\n\n    if (k !== i) {\n      d[k] = d[i];\n      d[i] = p;\n      for (j = 0; j < n; j++) {\n        p = V.get(j, i);\n        V.set(j, i, V.get(j, k));\n        V.set(j, k, p);\n      }\n    }\n  }\n}\n\nfunction orthes(n, H, ort, V) {\n  let low = 0;\n  let high = n - 1;\n  let f, g, h, i, j, m;\n  let scale;\n\n  for (m = low + 1; m <= high - 1; m++) {\n    scale = 0;\n    for (i = m; i <= high; i++) {\n      scale = scale + Math.abs(H.get(i, m - 1));\n    }\n\n    if (scale !== 0) {\n      h = 0;\n      for (i = high; i >= m; i--) {\n        ort[i] = H.get(i, m - 1) / scale;\n        h += ort[i] * ort[i];\n      }\n\n      g = Math.sqrt(h);\n      if (ort[m] > 0) {\n        g = -g;\n      }\n\n      h = h - ort[m] * g;\n      ort[m] = ort[m] - g;\n\n      for (j = m; j < n; j++) {\n        f = 0;\n        for (i = high; i >= m; i--) {\n          f += ort[i] * H.get(i, j);\n        }\n\n        f = f / h;\n        for (i = m; i <= high; i++) {\n          H.set(i, j, H.get(i, j) - f * ort[i]);\n        }\n      }\n\n      for (i = 0; i <= high; i++) {\n        f = 0;\n        for (j = high; j >= m; j--) {\n          f += ort[j] * H.get(i, j);\n        }\n\n        f = f / h;\n        for (j = m; j <= high; j++) {\n          H.set(i, j, H.get(i, j) - f * ort[j]);\n        }\n      }\n\n      ort[m] = scale * ort[m];\n      H.set(m, m - 1, scale * g);\n    }\n  }\n\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      V.set(i, j, i === j ? 1 : 0);\n    }\n  }\n\n  for (m = high - 1; m >= low + 1; m--) {\n    if (H.get(m, m - 1) !== 0) {\n      for (i = m + 1; i <= high; i++) {\n        ort[i] = H.get(i, m - 1);\n      }\n\n      for (j = m; j <= high; j++) {\n        g = 0;\n        for (i = m; i <= high; i++) {\n          g += ort[i] * V.get(i, j);\n        }\n\n        g = g / ort[m] / H.get(m, m - 1);\n        for (i = m; i <= high; i++) {\n          V.set(i, j, V.get(i, j) + g * ort[i]);\n        }\n      }\n    }\n  }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n  let n = nn - 1;\n  let low = 0;\n  let high = nn - 1;\n  let eps = Number.EPSILON;\n  let exshift = 0;\n  let norm = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let z = 0;\n  let iter = 0;\n  let i, j, k, l, m, t, w, x, y;\n  let ra, sa, vr, vi;\n  let notlast, cdivres;\n\n  for (i = 0; i < nn; i++) {\n    if (i < low || i > high) {\n      d[i] = H.get(i, i);\n      e[i] = 0;\n    }\n\n    for (j = Math.max(i - 1, 0); j < nn; j++) {\n      norm = norm + Math.abs(H.get(i, j));\n    }\n  }\n\n  while (n >= low) {\n    l = n;\n    while (l > low) {\n      s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));\n      if (s === 0) {\n        s = norm;\n      }\n      if (Math.abs(H.get(l, l - 1)) < eps * s) {\n        break;\n      }\n      l--;\n    }\n\n    if (l === n) {\n      H.set(n, n, H.get(n, n) + exshift);\n      d[n] = H.get(n, n);\n      e[n] = 0;\n      n--;\n      iter = 0;\n    } else if (l === n - 1) {\n      w = H.get(n, n - 1) * H.get(n - 1, n);\n      p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;\n      q = p * p + w;\n      z = Math.sqrt(Math.abs(q));\n      H.set(n, n, H.get(n, n) + exshift);\n      H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);\n      x = H.get(n, n);\n\n      if (q >= 0) {\n        z = p >= 0 ? p + z : p - z;\n        d[n - 1] = x + z;\n        d[n] = d[n - 1];\n        if (z !== 0) {\n          d[n] = x - w / z;\n        }\n        e[n - 1] = 0;\n        e[n] = 0;\n        x = H.get(n, n - 1);\n        s = Math.abs(x) + Math.abs(z);\n        p = x / s;\n        q = z / s;\n        r = Math.sqrt(p * p + q * q);\n        p = p / r;\n        q = q / r;\n\n        for (j = n - 1; j < nn; j++) {\n          z = H.get(n - 1, j);\n          H.set(n - 1, j, q * z + p * H.get(n, j));\n          H.set(n, j, q * H.get(n, j) - p * z);\n        }\n\n        for (i = 0; i <= n; i++) {\n          z = H.get(i, n - 1);\n          H.set(i, n - 1, q * z + p * H.get(i, n));\n          H.set(i, n, q * H.get(i, n) - p * z);\n        }\n\n        for (i = low; i <= high; i++) {\n          z = V.get(i, n - 1);\n          V.set(i, n - 1, q * z + p * V.get(i, n));\n          V.set(i, n, q * V.get(i, n) - p * z);\n        }\n      } else {\n        d[n - 1] = x + p;\n        d[n] = x + p;\n        e[n - 1] = z;\n        e[n] = -z;\n      }\n\n      n = n - 2;\n      iter = 0;\n    } else {\n      x = H.get(n, n);\n      y = 0;\n      w = 0;\n      if (l < n) {\n        y = H.get(n - 1, n - 1);\n        w = H.get(n, n - 1) * H.get(n - 1, n);\n      }\n\n      if (iter === 10) {\n        exshift += x;\n        for (i = low; i <= n; i++) {\n          H.set(i, i, H.get(i, i) - x);\n        }\n        s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));\n        x = y = 0.75 * s;\n        w = -0.4375 * s * s;\n      }\n\n      if (iter === 30) {\n        s = (y - x) / 2;\n        s = s * s + w;\n        if (s > 0) {\n          s = Math.sqrt(s);\n          if (y < x) {\n            s = -s;\n          }\n          s = x - w / ((y - x) / 2 + s);\n          for (i = low; i <= n; i++) {\n            H.set(i, i, H.get(i, i) - s);\n          }\n          exshift += s;\n          x = y = w = 0.964;\n        }\n      }\n\n      iter = iter + 1;\n\n      m = n - 2;\n      while (m >= l) {\n        z = H.get(m, m);\n        r = x - z;\n        s = y - z;\n        p = (r * s - w) / H.get(m + 1, m) + H.get(m, m + 1);\n        q = H.get(m + 1, m + 1) - z - r - s;\n        r = H.get(m + 2, m + 1);\n        s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n        p = p / s;\n        q = q / s;\n        r = r / s;\n        if (m === l) {\n          break;\n        }\n        if (\n          Math.abs(H.get(m, m - 1)) * (Math.abs(q) + Math.abs(r)) <\n          eps *\n            (Math.abs(p) *\n              (Math.abs(H.get(m - 1, m - 1)) +\n                Math.abs(z) +\n                Math.abs(H.get(m + 1, m + 1))))\n        ) {\n          break;\n        }\n        m--;\n      }\n\n      for (i = m + 2; i <= n; i++) {\n        H.set(i, i - 2, 0);\n        if (i > m + 2) {\n          H.set(i, i - 3, 0);\n        }\n      }\n\n      for (k = m; k <= n - 1; k++) {\n        notlast = k !== n - 1;\n        if (k !== m) {\n          p = H.get(k, k - 1);\n          q = H.get(k + 1, k - 1);\n          r = notlast ? H.get(k + 2, k - 1) : 0;\n          x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n          if (x !== 0) {\n            p = p / x;\n            q = q / x;\n            r = r / x;\n          }\n        }\n\n        if (x === 0) {\n          break;\n        }\n\n        s = Math.sqrt(p * p + q * q + r * r);\n        if (p < 0) {\n          s = -s;\n        }\n\n        if (s !== 0) {\n          if (k !== m) {\n            H.set(k, k - 1, -s * x);\n          } else if (l !== m) {\n            H.set(k, k - 1, -H.get(k, k - 1));\n          }\n\n          p = p + s;\n          x = p / s;\n          y = q / s;\n          z = r / s;\n          q = q / p;\n          r = r / p;\n\n          for (j = k; j < nn; j++) {\n            p = H.get(k, j) + q * H.get(k + 1, j);\n            if (notlast) {\n              p = p + r * H.get(k + 2, j);\n              H.set(k + 2, j, H.get(k + 2, j) - p * z);\n            }\n\n            H.set(k, j, H.get(k, j) - p * x);\n            H.set(k + 1, j, H.get(k + 1, j) - p * y);\n          }\n\n          for (i = 0; i <= Math.min(n, k + 3); i++) {\n            p = x * H.get(i, k) + y * H.get(i, k + 1);\n            if (notlast) {\n              p = p + z * H.get(i, k + 2);\n              H.set(i, k + 2, H.get(i, k + 2) - p * r);\n            }\n\n            H.set(i, k, H.get(i, k) - p);\n            H.set(i, k + 1, H.get(i, k + 1) - p * q);\n          }\n\n          for (i = low; i <= high; i++) {\n            p = x * V.get(i, k) + y * V.get(i, k + 1);\n            if (notlast) {\n              p = p + z * V.get(i, k + 2);\n              V.set(i, k + 2, V.get(i, k + 2) - p * r);\n            }\n\n            V.set(i, k, V.get(i, k) - p);\n            V.set(i, k + 1, V.get(i, k + 1) - p * q);\n          }\n        }\n      }\n    }\n  }\n\n  if (norm === 0) {\n    return;\n  }\n\n  for (n = nn - 1; n >= 0; n--) {\n    p = d[n];\n    q = e[n];\n\n    if (q === 0) {\n      l = n;\n      H.set(n, n, 1);\n      for (i = n - 1; i >= 0; i--) {\n        w = H.get(i, i) - p;\n        r = 0;\n        for (j = l; j <= n; j++) {\n          r = r + H.get(i, j) * H.get(j, n);\n        }\n\n        if (e[i] < 0) {\n          z = w;\n          s = r;\n        } else {\n          l = i;\n          if (e[i] === 0) {\n            H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));\n          } else {\n            x = H.get(i, i + 1);\n            y = H.get(i + 1, i);\n            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n            t = (x * s - z * r) / q;\n            H.set(i, n, t);\n            H.set(\n              i + 1,\n              n,\n              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z,\n            );\n          }\n\n          t = Math.abs(H.get(i, n));\n          if (eps * t * t > 1) {\n            for (j = i; j <= n; j++) {\n              H.set(j, n, H.get(j, n) / t);\n            }\n          }\n        }\n      }\n    } else if (q < 0) {\n      l = n - 1;\n\n      if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {\n        H.set(n - 1, n - 1, q / H.get(n, n - 1));\n        H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));\n      } else {\n        cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);\n        H.set(n - 1, n - 1, cdivres[0]);\n        H.set(n - 1, n, cdivres[1]);\n      }\n\n      H.set(n, n - 1, 0);\n      H.set(n, n, 1);\n      for (i = n - 2; i >= 0; i--) {\n        ra = 0;\n        sa = 0;\n        for (j = l; j <= n; j++) {\n          ra = ra + H.get(i, j) * H.get(j, n - 1);\n          sa = sa + H.get(i, j) * H.get(j, n);\n        }\n\n        w = H.get(i, i) - p;\n\n        if (e[i] < 0) {\n          z = w;\n          r = ra;\n          s = sa;\n        } else {\n          l = i;\n          if (e[i] === 0) {\n            cdivres = cdiv(-ra, -sa, w, q);\n            H.set(i, n - 1, cdivres[0]);\n            H.set(i, n, cdivres[1]);\n          } else {\n            x = H.get(i, i + 1);\n            y = H.get(i + 1, i);\n            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n            vi = (d[i] - p) * 2 * q;\n            if (vr === 0 && vi === 0) {\n              vr =\n                eps *\n                norm *\n                (Math.abs(w) +\n                  Math.abs(q) +\n                  Math.abs(x) +\n                  Math.abs(y) +\n                  Math.abs(z));\n            }\n            cdivres = cdiv(\n              x * r - z * ra + q * sa,\n              x * s - z * sa - q * ra,\n              vr,\n              vi,\n            );\n            H.set(i, n - 1, cdivres[0]);\n            H.set(i, n, cdivres[1]);\n            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {\n              H.set(\n                i + 1,\n                n - 1,\n                (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x,\n              );\n              H.set(\n                i + 1,\n                n,\n                (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x,\n              );\n            } else {\n              cdivres = cdiv(\n                -r - y * H.get(i, n - 1),\n                -s - y * H.get(i, n),\n                z,\n                q,\n              );\n              H.set(i + 1, n - 1, cdivres[0]);\n              H.set(i + 1, n, cdivres[1]);\n            }\n          }\n\n          t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));\n          if (eps * t * t > 1) {\n            for (j = i; j <= n; j++) {\n              H.set(j, n - 1, H.get(j, n - 1) / t);\n              H.set(j, n, H.get(j, n) / t);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < nn; i++) {\n    if (i < low || i > high) {\n      for (j = i; j < nn; j++) {\n        V.set(i, j, H.get(i, j));\n      }\n    }\n  }\n\n  for (j = nn - 1; j >= low; j--) {\n    for (i = low; i <= high; i++) {\n      z = 0;\n      for (k = low; k <= Math.min(j, high); k++) {\n        z = z + V.get(i, k) * H.get(k, j);\n      }\n      V.set(i, j, z);\n    }\n  }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n  let r, d;\n  if (Math.abs(yr) > Math.abs(yi)) {\n    r = yi / yr;\n    d = yr + r * yi;\n    return [(xr + r * xi) / d, (xi - r * xr) / d];\n  } else {\n    r = yr / yi;\n    d = yi + r * yr;\n    return [(r * xr + xi) / d, (r * xi - xr) / d];\n  }\n}\n","import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nexport default class LuDecomposition {\n  constructor(matrix) {\n    matrix = WrapperMatrix2D.checkMatrix(matrix);\n\n    let lu = matrix.clone();\n    let rows = lu.rows;\n    let columns = lu.columns;\n    let pivotVector = new Float64Array(rows);\n    let pivotSign = 1;\n    let i, j, k, p, s, t, v;\n    let LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n      pivotVector[i] = i;\n    }\n\n    LUcolj = new Float64Array(rows);\n\n    for (j = 0; j < columns; j++) {\n      for (i = 0; i < rows; i++) {\n        LUcolj[i] = lu.get(i, j);\n      }\n\n      for (i = 0; i < rows; i++) {\n        kmax = Math.min(i, j);\n        s = 0;\n        for (k = 0; k < kmax; k++) {\n          s += lu.get(i, k) * LUcolj[k];\n        }\n        LUcolj[i] -= s;\n        lu.set(i, j, LUcolj[i]);\n      }\n\n      p = j;\n      for (i = j + 1; i < rows; i++) {\n        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n          p = i;\n        }\n      }\n\n      if (p !== j) {\n        for (k = 0; k < columns; k++) {\n          t = lu.get(p, k);\n          lu.set(p, k, lu.get(j, k));\n          lu.set(j, k, t);\n        }\n\n        v = pivotVector[p];\n        pivotVector[p] = pivotVector[j];\n        pivotVector[j] = v;\n\n        pivotSign = -pivotSign;\n      }\n\n      if (j < rows && lu.get(j, j) !== 0) {\n        for (i = j + 1; i < rows; i++) {\n          lu.set(i, j, lu.get(i, j) / lu.get(j, j));\n        }\n      }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n  }\n\n  isSingular() {\n    let data = this.LU;\n    let col = data.columns;\n    for (let j = 0; j < col; j++) {\n      if (data.get(j, j) === 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  solve(value) {\n    value = Matrix.checkMatrix(value);\n\n    let lu = this.LU;\n    let rows = lu.rows;\n\n    if (rows !== value.rows) {\n      throw new Error('Invalid matrix dimensions');\n    }\n    if (this.isSingular()) {\n      throw new Error('LU matrix is singular');\n    }\n\n    let count = value.columns;\n    let X = value.subMatrixRow(this.pivotVector, 0, count - 1);\n    let columns = lu.columns;\n    let i, j, k;\n\n    for (k = 0; k < columns; k++) {\n      for (i = k + 1; i < columns; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\n        }\n      }\n    }\n    for (k = columns - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        X.set(k, j, X.get(k, j) / lu.get(k, k));\n      }\n      for (i = 0; i < k; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\n        }\n      }\n    }\n    return X;\n  }\n\n  get determinant() {\n    let data = this.LU;\n    if (!data.isSquare()) {\n      throw new Error('Matrix must be square');\n    }\n    let determinant = this.pivotSign;\n    let col = data.columns;\n    for (let j = 0; j < col; j++) {\n      determinant *= data.get(j, j);\n    }\n    return determinant;\n  }\n\n  get lowerTriangularMatrix() {\n    let data = this.LU;\n    let rows = data.rows;\n    let columns = data.columns;\n    let X = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        if (i > j) {\n          X.set(i, j, data.get(i, j));\n        } else if (i === j) {\n          X.set(i, j, 1);\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get upperTriangularMatrix() {\n    let data = this.LU;\n    let rows = data.rows;\n    let columns = data.columns;\n    let X = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        if (i <= j) {\n          X.set(i, j, data.get(i, j));\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get pivotPermutationVector() {\n    return Array.from(this.pivotVector);\n  }\n}\n","import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nexport default class nipals {\n  constructor(X, options = {}) {\n    X = WrapperMatrix2D.checkMatrix(X);\n    let { Y } = options;\n    const {\n      scaleScores = false,\n      maxIterations = 1000,\n      terminationCriteria = 1e-10,\n    } = options;\n\n    let u;\n    if (Y) {\n      if (Array.isArray(Y) && typeof Y[0] === 'number') {\n        Y = Matrix.columnVector(Y);\n      } else {\n        Y = WrapperMatrix2D.checkMatrix(Y);\n      }\n      if (Y.rows !== X.rows) {\n        throw new Error('Y should have the same number of rows as X');\n      }\n      u = Y.getColumnVector(0);\n    } else {\n      u = X.getColumnVector(0);\n    }\n\n    let diff = 1;\n    let t, q, w, tOld;\n\n    for (\n      let counter = 0;\n      counter < maxIterations && diff > terminationCriteria;\n      counter++\n    ) {\n      w = X.transpose().mmul(u).div(u.transpose().mmul(u).get(0, 0));\n      w = w.div(w.norm());\n\n      t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));\n\n      if (counter > 0) {\n        diff = t.clone().sub(tOld).pow(2).sum();\n      }\n      tOld = t.clone();\n\n      if (Y) {\n        q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n        q = q.div(q.norm());\n\n        u = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));\n      } else {\n        u = t;\n      }\n    }\n\n    if (Y) {\n      let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n      p = p.div(p.norm());\n      let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));\n      let residual = u.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n      let yResidual = Y.clone().sub(\n        t.clone().mulS(residual.get(0, 0)).mmul(q.transpose()),\n      );\n\n      this.t = t;\n      this.p = p.transpose();\n      this.w = w.transpose();\n      this.q = q;\n      this.u = u;\n      this.s = t.transpose().mmul(t);\n      this.xResidual = xResidual;\n      this.yResidual = yResidual;\n      this.betas = residual;\n    } else {\n      this.w = w.transpose();\n      this.s = t.transpose().mmul(t).sqrt();\n      if (scaleScores) {\n        this.t = t.clone().div(this.s.get(0, 0));\n      } else {\n        this.t = t;\n      }\n      this.xResidual = X.sub(t.mmul(w.transpose()));\n    }\n  }\n}\n","import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nimport { hypotenuse } from './util';\n\nexport default class QrDecomposition {\n  constructor(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    let qr = value.clone();\n    let m = value.rows;\n    let n = value.columns;\n    let rdiag = new Float64Array(n);\n    let i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n      let nrm = 0;\n      for (i = k; i < m; i++) {\n        nrm = hypotenuse(nrm, qr.get(i, k));\n      }\n      if (nrm !== 0) {\n        if (qr.get(k, k) < 0) {\n          nrm = -nrm;\n        }\n        for (i = k; i < m; i++) {\n          qr.set(i, k, qr.get(i, k) / nrm);\n        }\n        qr.set(k, k, qr.get(k, k) + 1);\n        for (j = k + 1; j < n; j++) {\n          s = 0;\n          for (i = k; i < m; i++) {\n            s += qr.get(i, k) * qr.get(i, j);\n          }\n          s = -s / qr.get(k, k);\n          for (i = k; i < m; i++) {\n            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));\n          }\n        }\n      }\n      rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n  }\n\n  solve(value) {\n    value = Matrix.checkMatrix(value);\n\n    let qr = this.QR;\n    let m = qr.rows;\n\n    if (value.rows !== m) {\n      throw new Error('Matrix row dimensions must agree');\n    }\n    if (!this.isFullRank()) {\n      throw new Error('Matrix is rank deficient');\n    }\n\n    let count = value.columns;\n    let X = value.clone();\n    let n = qr.columns;\n    let i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n      for (j = 0; j < count; j++) {\n        s = 0;\n        for (i = k; i < m; i++) {\n          s += qr.get(i, k) * X.get(i, j);\n        }\n        s = -s / qr.get(k, k);\n        for (i = k; i < m; i++) {\n          X.set(i, j, X.get(i, j) + s * qr.get(i, k));\n        }\n      }\n    }\n    for (k = n - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        X.set(k, j, X.get(k, j) / this.Rdiag[k]);\n      }\n      for (i = 0; i < k; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));\n        }\n      }\n    }\n\n    return X.subMatrix(0, n - 1, 0, count - 1);\n  }\n\n  isFullRank() {\n    let columns = this.QR.columns;\n    for (let i = 0; i < columns; i++) {\n      if (this.Rdiag[i] === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  get upperTriangularMatrix() {\n    let qr = this.QR;\n    let n = qr.columns;\n    let X = new Matrix(n, n);\n    let i, j;\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        if (i < j) {\n          X.set(i, j, qr.get(i, j));\n        } else if (i === j) {\n          X.set(i, j, this.Rdiag[i]);\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get orthogonalMatrix() {\n    let qr = this.QR;\n    let rows = qr.rows;\n    let columns = qr.columns;\n    let X = new Matrix(rows, columns);\n    let i, j, k, s;\n\n    for (k = columns - 1; k >= 0; k--) {\n      for (i = 0; i < rows; i++) {\n        X.set(i, k, 0);\n      }\n      X.set(k, k, 1);\n      for (j = k; j < columns; j++) {\n        if (qr.get(k, k) !== 0) {\n          s = 0;\n          for (i = k; i < rows; i++) {\n            s += qr.get(i, k) * X.get(i, j);\n          }\n\n          s = -s / qr.get(k, k);\n\n          for (i = k; i < rows; i++) {\n            X.set(i, j, X.get(i, j) + s * qr.get(i, k));\n          }\n        }\n      }\n    }\n    return X;\n  }\n}\n","import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nimport { hypotenuse } from './util';\n\nexport default class SingularValueDecomposition {\n  constructor(value, options = {}) {\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    if (value.isEmpty()) {\n      throw new Error('Matrix must be non-empty');\n    }\n\n    let m = value.rows;\n    let n = value.columns;\n\n    const {\n      computeLeftSingularVectors = true,\n      computeRightSingularVectors = true,\n      autoTranspose = false,\n    } = options;\n\n    let wantu = Boolean(computeLeftSingularVectors);\n    let wantv = Boolean(computeRightSingularVectors);\n\n    let swapped = false;\n    let a;\n    if (m < n) {\n      if (!autoTranspose) {\n        a = value.clone();\n        // eslint-disable-next-line no-console\n        console.warn(\n          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose',\n        );\n      } else {\n        a = value.transpose();\n        m = a.rows;\n        n = a.columns;\n        swapped = true;\n        let aux = wantu;\n        wantu = wantv;\n        wantv = aux;\n      }\n    } else {\n      a = value.clone();\n    }\n\n    let nu = Math.min(m, n);\n    let ni = Math.min(m + 1, n);\n    let s = new Float64Array(ni);\n    let U = new Matrix(m, nu);\n    let V = new Matrix(n, n);\n\n    let e = new Float64Array(n);\n    let work = new Float64Array(m);\n\n    let si = new Float64Array(ni);\n    for (let i = 0; i < ni; i++) si[i] = i;\n\n    let nct = Math.min(m - 1, n);\n    let nrt = Math.max(0, Math.min(n - 2, m));\n    let mrc = Math.max(nct, nrt);\n\n    for (let k = 0; k < mrc; k++) {\n      if (k < nct) {\n        s[k] = 0;\n        for (let i = k; i < m; i++) {\n          s[k] = hypotenuse(s[k], a.get(i, k));\n        }\n        if (s[k] !== 0) {\n          if (a.get(k, k) < 0) {\n            s[k] = -s[k];\n          }\n          for (let i = k; i < m; i++) {\n            a.set(i, k, a.get(i, k) / s[k]);\n          }\n          a.set(k, k, a.get(k, k) + 1);\n        }\n        s[k] = -s[k];\n      }\n\n      for (let j = k + 1; j < n; j++) {\n        if (k < nct && s[k] !== 0) {\n          let t = 0;\n          for (let i = k; i < m; i++) {\n            t += a.get(i, k) * a.get(i, j);\n          }\n          t = -t / a.get(k, k);\n          for (let i = k; i < m; i++) {\n            a.set(i, j, a.get(i, j) + t * a.get(i, k));\n          }\n        }\n        e[j] = a.get(k, j);\n      }\n\n      if (wantu && k < nct) {\n        for (let i = k; i < m; i++) {\n          U.set(i, k, a.get(i, k));\n        }\n      }\n\n      if (k < nrt) {\n        e[k] = 0;\n        for (let i = k + 1; i < n; i++) {\n          e[k] = hypotenuse(e[k], e[i]);\n        }\n        if (e[k] !== 0) {\n          if (e[k + 1] < 0) {\n            e[k] = 0 - e[k];\n          }\n          for (let i = k + 1; i < n; i++) {\n            e[i] /= e[k];\n          }\n          e[k + 1] += 1;\n        }\n        e[k] = -e[k];\n        if (k + 1 < m && e[k] !== 0) {\n          for (let i = k + 1; i < m; i++) {\n            work[i] = 0;\n          }\n          for (let i = k + 1; i < m; i++) {\n            for (let j = k + 1; j < n; j++) {\n              work[i] += e[j] * a.get(i, j);\n            }\n          }\n          for (let j = k + 1; j < n; j++) {\n            let t = -e[j] / e[k + 1];\n            for (let i = k + 1; i < m; i++) {\n              a.set(i, j, a.get(i, j) + t * work[i]);\n            }\n          }\n        }\n        if (wantv) {\n          for (let i = k + 1; i < n; i++) {\n            V.set(i, k, e[i]);\n          }\n        }\n      }\n    }\n\n    let p = Math.min(n, m + 1);\n    if (nct < n) {\n      s[nct] = a.get(nct, nct);\n    }\n    if (m < p) {\n      s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n      e[nrt] = a.get(nrt, p - 1);\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n      for (let j = nct; j < nu; j++) {\n        for (let i = 0; i < m; i++) {\n          U.set(i, j, 0);\n        }\n        U.set(j, j, 1);\n      }\n      for (let k = nct - 1; k >= 0; k--) {\n        if (s[k] !== 0) {\n          for (let j = k + 1; j < nu; j++) {\n            let t = 0;\n            for (let i = k; i < m; i++) {\n              t += U.get(i, k) * U.get(i, j);\n            }\n            t = -t / U.get(k, k);\n            for (let i = k; i < m; i++) {\n              U.set(i, j, U.get(i, j) + t * U.get(i, k));\n            }\n          }\n          for (let i = k; i < m; i++) {\n            U.set(i, k, -U.get(i, k));\n          }\n          U.set(k, k, 1 + U.get(k, k));\n          for (let i = 0; i < k - 1; i++) {\n            U.set(i, k, 0);\n          }\n        } else {\n          for (let i = 0; i < m; i++) {\n            U.set(i, k, 0);\n          }\n          U.set(k, k, 1);\n        }\n      }\n    }\n\n    if (wantv) {\n      for (let k = n - 1; k >= 0; k--) {\n        if (k < nrt && e[k] !== 0) {\n          for (let j = k + 1; j < n; j++) {\n            let t = 0;\n            for (let i = k + 1; i < n; i++) {\n              t += V.get(i, k) * V.get(i, j);\n            }\n            t = -t / V.get(k + 1, k);\n            for (let i = k + 1; i < n; i++) {\n              V.set(i, j, V.get(i, j) + t * V.get(i, k));\n            }\n          }\n        }\n        for (let i = 0; i < n; i++) {\n          V.set(i, k, 0);\n        }\n        V.set(k, k, 1);\n      }\n    }\n\n    let pp = p - 1;\n    let iter = 0;\n    let eps = Number.EPSILON;\n    while (p > 0) {\n      let k, kase;\n      for (k = p - 2; k >= -1; k--) {\n        if (k === -1) {\n          break;\n        }\n        const alpha =\n          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));\n        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {\n          e[k] = 0;\n          break;\n        }\n      }\n      if (k === p - 2) {\n        kase = 4;\n      } else {\n        let ks;\n        for (ks = p - 1; ks >= k; ks--) {\n          if (ks === k) {\n            break;\n          }\n          let t =\n            (ks !== p ? Math.abs(e[ks]) : 0) +\n            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n          if (Math.abs(s[ks]) <= eps * t) {\n            s[ks] = 0;\n            break;\n          }\n        }\n        if (ks === k) {\n          kase = 3;\n        } else if (ks === p - 1) {\n          kase = 1;\n        } else {\n          kase = 2;\n          k = ks;\n        }\n      }\n\n      k++;\n\n      switch (kase) {\n        case 1: {\n          let f = e[p - 2];\n          e[p - 2] = 0;\n          for (let j = p - 2; j >= k; j--) {\n            let t = hypotenuse(s[j], f);\n            let cs = s[j] / t;\n            let sn = f / t;\n            s[j] = t;\n            if (j !== k) {\n              f = -sn * e[j - 1];\n              e[j - 1] = cs * e[j - 1];\n            }\n            if (wantv) {\n              for (let i = 0; i < n; i++) {\n                t = cs * V.get(i, j) + sn * V.get(i, p - 1);\n                V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));\n                V.set(i, j, t);\n              }\n            }\n          }\n          break;\n        }\n        case 2: {\n          let f = e[k - 1];\n          e[k - 1] = 0;\n          for (let j = k; j < p; j++) {\n            let t = hypotenuse(s[j], f);\n            let cs = s[j] / t;\n            let sn = f / t;\n            s[j] = t;\n            f = -sn * e[j];\n            e[j] = cs * e[j];\n            if (wantu) {\n              for (let i = 0; i < m; i++) {\n                t = cs * U.get(i, j) + sn * U.get(i, k - 1);\n                U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));\n                U.set(i, j, t);\n              }\n            }\n          }\n          break;\n        }\n        case 3: {\n          const scale = Math.max(\n            Math.abs(s[p - 1]),\n            Math.abs(s[p - 2]),\n            Math.abs(e[p - 2]),\n            Math.abs(s[k]),\n            Math.abs(e[k]),\n          );\n          const sp = s[p - 1] / scale;\n          const spm1 = s[p - 2] / scale;\n          const epm1 = e[p - 2] / scale;\n          const sk = s[k] / scale;\n          const ek = e[k] / scale;\n          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n          const c = sp * epm1 * (sp * epm1);\n          let shift = 0;\n          if (b !== 0 || c !== 0) {\n            if (b < 0) {\n              shift = 0 - Math.sqrt(b * b + c);\n            } else {\n              shift = Math.sqrt(b * b + c);\n            }\n            shift = c / (b + shift);\n          }\n          let f = (sk + sp) * (sk - sp) + shift;\n          let g = sk * ek;\n          for (let j = k; j < p - 1; j++) {\n            let t = hypotenuse(f, g);\n            if (t === 0) t = Number.MIN_VALUE;\n            let cs = f / t;\n            let sn = g / t;\n            if (j !== k) {\n              e[j - 1] = t;\n            }\n            f = cs * s[j] + sn * e[j];\n            e[j] = cs * e[j] - sn * s[j];\n            g = sn * s[j + 1];\n            s[j + 1] = cs * s[j + 1];\n            if (wantv) {\n              for (let i = 0; i < n; i++) {\n                t = cs * V.get(i, j) + sn * V.get(i, j + 1);\n                V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));\n                V.set(i, j, t);\n              }\n            }\n            t = hypotenuse(f, g);\n            if (t === 0) t = Number.MIN_VALUE;\n            cs = f / t;\n            sn = g / t;\n            s[j] = t;\n            f = cs * e[j] + sn * s[j + 1];\n            s[j + 1] = -sn * e[j] + cs * s[j + 1];\n            g = sn * e[j + 1];\n            e[j + 1] = cs * e[j + 1];\n            if (wantu && j < m - 1) {\n              for (let i = 0; i < m; i++) {\n                t = cs * U.get(i, j) + sn * U.get(i, j + 1);\n                U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));\n                U.set(i, j, t);\n              }\n            }\n          }\n          e[p - 2] = f;\n          iter = iter + 1;\n          break;\n        }\n        case 4: {\n          if (s[k] <= 0) {\n            s[k] = s[k] < 0 ? -s[k] : 0;\n            if (wantv) {\n              for (let i = 0; i <= pp; i++) {\n                V.set(i, k, -V.get(i, k));\n              }\n            }\n          }\n          while (k < pp) {\n            if (s[k] >= s[k + 1]) {\n              break;\n            }\n            let t = s[k];\n            s[k] = s[k + 1];\n            s[k + 1] = t;\n            if (wantv && k < n - 1) {\n              for (let i = 0; i < n; i++) {\n                t = V.get(i, k + 1);\n                V.set(i, k + 1, V.get(i, k));\n                V.set(i, k, t);\n              }\n            }\n            if (wantu && k < m - 1) {\n              for (let i = 0; i < m; i++) {\n                t = U.get(i, k + 1);\n                U.set(i, k + 1, U.get(i, k));\n                U.set(i, k, t);\n              }\n            }\n            k++;\n          }\n          iter = 0;\n          p--;\n          break;\n        }\n        // no default\n      }\n    }\n\n    if (swapped) {\n      let tmp = V;\n      V = U;\n      U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n  }\n\n  solve(value) {\n    let Y = value;\n    let e = this.threshold;\n    let scols = this.s.length;\n    let Ls = Matrix.zeros(scols, scols);\n\n    for (let i = 0; i < scols; i++) {\n      if (Math.abs(this.s[i]) <= e) {\n        Ls.set(i, i, 0);\n      } else {\n        Ls.set(i, i, 1 / this.s[i]);\n      }\n    }\n\n    let U = this.U;\n    let V = this.rightSingularVectors;\n\n    let VL = V.mmul(Ls);\n    let vrows = V.rows;\n    let urows = U.rows;\n    let VLU = Matrix.zeros(vrows, urows);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < urows; j++) {\n        let sum = 0;\n        for (let k = 0; k < scols; k++) {\n          sum += VL.get(i, k) * U.get(j, k);\n        }\n        VLU.set(i, j, sum);\n      }\n    }\n\n    return VLU.mmul(Y);\n  }\n\n  solveForDiagonal(value) {\n    return this.solve(Matrix.diag(value));\n  }\n\n  inverse() {\n    let V = this.V;\n    let e = this.threshold;\n    let vrows = V.rows;\n    let vcols = V.columns;\n    let X = new Matrix(vrows, this.s.length);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < vcols; j++) {\n        if (Math.abs(this.s[j]) > e) {\n          X.set(i, j, V.get(i, j) / this.s[j]);\n        }\n      }\n    }\n\n    let U = this.U;\n\n    let urows = U.rows;\n    let ucols = U.columns;\n    let Y = new Matrix(vrows, urows);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < urows; j++) {\n        let sum = 0;\n        for (let k = 0; k < ucols; k++) {\n          sum += X.get(i, k) * U.get(j, k);\n        }\n        Y.set(i, j, sum);\n      }\n    }\n\n    return Y;\n  }\n\n  get condition() {\n    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n  }\n\n  get norm2() {\n    return this.s[0];\n  }\n\n  get rank() {\n    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;\n    let r = 0;\n    let s = this.s;\n    for (let i = 0, ii = s.length; i < ii; i++) {\n      if (s[i] > tol) {\n        r++;\n      }\n    }\n    return r;\n  }\n\n  get diagonal() {\n    return Array.from(this.s);\n  }\n\n  get threshold() {\n    return (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0];\n  }\n\n  get leftSingularVectors() {\n    return this.U;\n  }\n\n  get rightSingularVectors() {\n    return this.V;\n  }\n\n  get diagonalMatrix() {\n    return Matrix.diag(this.s);\n  }\n}\n","export function hypotenuse(a, b) {\n  let r = 0;\n  if (Math.abs(a) > Math.abs(b)) {\n    r = b / a;\n    return Math.abs(a) * Math.sqrt(1 + r * r);\n  }\n  if (b !== 0) {\n    r = a / b;\n    return Math.abs(b) * Math.sqrt(1 + r * r);\n  }\n  return 0;\n}\n","import LuDecomposition from './dc/lu';\nimport QrDecomposition from './dc/qr';\nimport SingularValueDecomposition from './dc/svd';\nimport Matrix from './matrix';\nimport WrapperMatrix2D from './wrap/WrapperMatrix2D';\n\nexport function inverse(matrix, useSVD = false) {\n  matrix = WrapperMatrix2D.checkMatrix(matrix);\n  if (useSVD) {\n    return new SingularValueDecomposition(matrix).inverse();\n  } else {\n    return solve(matrix, Matrix.eye(matrix.rows));\n  }\n}\n\nexport function solve(leftHandSide, rightHandSide, useSVD = false) {\n  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);\n  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);\n  if (useSVD) {\n    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);\n  } else {\n    return leftHandSide.isSquare()\n      ? new LuDecomposition(leftHandSide).solve(rightHandSide)\n      : new QrDecomposition(leftHandSide).solve(rightHandSide);\n  }\n}\n","import LuDecomposition from './dc/lu';\nimport Matrix from './matrix';\nimport MatrixSelectionView from './views/selection';\n\nexport function determinant(matrix) {\n  matrix = Matrix.checkMatrix(matrix);\n  if (matrix.isSquare()) {\n    if (matrix.columns === 0) {\n      return 1;\n    }\n\n    let a, b, c, d;\n    if (matrix.columns === 2) {\n      // 2 x 2 matrix\n      a = matrix.get(0, 0);\n      b = matrix.get(0, 1);\n      c = matrix.get(1, 0);\n      d = matrix.get(1, 1);\n\n      return a * d - b * c;\n    } else if (matrix.columns === 3) {\n      // 3 x 3 matrix\n      let subMatrix0, subMatrix1, subMatrix2;\n      subMatrix0 = new MatrixSelectionView(matrix, [1, 2], [1, 2]);\n      subMatrix1 = new MatrixSelectionView(matrix, [1, 2], [0, 2]);\n      subMatrix2 = new MatrixSelectionView(matrix, [1, 2], [0, 1]);\n      a = matrix.get(0, 0);\n      b = matrix.get(0, 1);\n      c = matrix.get(0, 2);\n\n      return (\n        a * determinant(subMatrix0) -\n        b * determinant(subMatrix1) +\n        c * determinant(subMatrix2)\n      );\n    } else {\n      // general purpose determinant using the LU decomposition\n      return new LuDecomposition(matrix).determinant;\n    }\n  } else {\n    throw Error('determinant can only be calculated for a square matrix');\n  }\n}\n","export { AbstractMatrix, default, default as Matrix } from './matrix';\nexport * from './views/index';\n\nexport { wrap } from './wrap/wrap';\nexport { default as WrapperMatrix1D } from './wrap/WrapperMatrix1D';\nexport { default as WrapperMatrix2D } from './wrap/WrapperMatrix2D';\n\nexport { solve, inverse } from './decompositions';\nexport { determinant } from './determinant';\nexport { linearDependencies } from './linearDependencies';\nexport { pseudoInverse } from './pseudoInverse';\nexport { covariance } from './covariance';\nexport { correlation } from './correlation';\n\nexport {\n  default as SingularValueDecomposition,\n  default as SVD,\n} from './dc/svd.js';\nexport {\n  default as EigenvalueDecomposition,\n  default as EVD,\n} from './dc/evd.js';\nexport {\n  default as CholeskyDecomposition,\n  default as CHO,\n} from './dc/cholesky.js';\nexport { default as LuDecomposition, default as LU } from './dc/lu.js';\nexport { default as QrDecomposition, default as QR } from './dc/qr.js';\nexport { default as Nipals, default as NIPALS } from './dc/nipals.js';\n","const indent = ' '.repeat(2);\nconst indentData = ' '.repeat(4);\n\nexport function inspectMatrix() {\n  return inspectMatrixWithOptions(this);\n}\n\nexport function inspectMatrixWithOptions(matrix, options = {}) {\n  const { maxRows = 15, maxColumns = 10, maxNumSize = 8 } = options;\n  return `${matrix.constructor.name} {\n${indent}[\n${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize)}\n${indent}]\n${indent}rows: ${matrix.rows}\n${indent}columns: ${matrix.columns}\n}`;\n}\n\nfunction inspectData(matrix, maxRows, maxColumns, maxNumSize) {\n  const { rows, columns } = matrix;\n  const maxI = Math.min(rows, maxRows);\n  const maxJ = Math.min(columns, maxColumns);\n  const result = [];\n  for (let i = 0; i < maxI; i++) {\n    let line = [];\n    for (let j = 0; j < maxJ; j++) {\n      line.push(formatNumber(matrix.get(i, j), maxNumSize));\n    }\n    result.push(`${line.join(' ')}`);\n  }\n  if (maxJ !== columns) {\n    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;\n  }\n  if (maxI !== rows) {\n    result.push(`... ${rows - maxRows} more rows`);\n  }\n  return result.join(`\\n${indentData}`);\n}\n\nfunction formatNumber(num, maxNumSize) {\n  const numStr = String(num);\n  if (numStr.length <= maxNumSize) {\n    return numStr.padEnd(maxNumSize, ' ');\n  }\n  const precise = num.toPrecision(maxNumSize - 2);\n  if (precise.length <= maxNumSize) {\n    return precise;\n  }\n  const exponential = num.toExponential(maxNumSize - 2);\n  const eIndex = exponential.indexOf('e');\n  const e = exponential.slice(eIndex);\n  return exponential.slice(0, maxNumSize - e.length) + e;\n}\n","import SingularValueDecomposition from './dc/svd';\nimport Matrix from './matrix';\n\nfunction xrange(n, exception) {\n  let range = [];\n  for (let i = 0; i < n; i++) {\n    if (i !== exception) {\n      range.push(i);\n    }\n  }\n  return range;\n}\n\nfunction dependenciesOneRow(\n  error,\n  matrix,\n  index,\n  thresholdValue = 10e-10,\n  thresholdError = 10e-10,\n) {\n  if (error > thresholdError) {\n    return new Array(matrix.rows + 1).fill(0);\n  } else {\n    let returnArray = matrix.addRow(index, [0]);\n    for (let i = 0; i < returnArray.rows; i++) {\n      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {\n        returnArray.set(i, 0, 0);\n      }\n    }\n    return returnArray.to1DArray();\n  }\n}\n\nexport function linearDependencies(matrix, options = {}) {\n  const { thresholdValue = 10e-10, thresholdError = 10e-10 } = options;\n  matrix = Matrix.checkMatrix(matrix);\n\n  let n = matrix.rows;\n  let results = new Matrix(n, n);\n\n  for (let i = 0; i < n; i++) {\n    let b = Matrix.columnVector(matrix.getRow(i));\n    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();\n    let svd = new SingularValueDecomposition(Abis);\n    let x = svd.solve(b);\n    let error = Matrix.sub(b, Abis.mmul(x)).abs().max();\n    results.setRow(\n      i,\n      dependenciesOneRow(error, x, i, thresholdValue, thresholdError),\n    );\n  }\n  return results;\n}\n","export function installMathOperations(AbstractMatrix, Matrix) {\n  AbstractMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number') return this.addS(value);\n    return this.addM(value);\n  };\n\n  AbstractMatrix.prototype.addS = function addS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.addM = function addM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.add = function add(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.add(value);\n  };\n\n  AbstractMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number') return this.subS(value);\n    return this.subM(value);\n  };\n\n  AbstractMatrix.prototype.subS = function subS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.subM = function subM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sub = function sub(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sub(value);\n  };\n  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;\n  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;\n  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;\n  AbstractMatrix.subtract = AbstractMatrix.sub;\n\n  AbstractMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number') return this.mulS(value);\n    return this.mulM(value);\n  };\n\n  AbstractMatrix.prototype.mulS = function mulS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.mulM = function mulM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mul = function mul(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mul(value);\n  };\n  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;\n  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;\n  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;\n  AbstractMatrix.multiply = AbstractMatrix.mul;\n\n  AbstractMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number') return this.divS(value);\n    return this.divM(value);\n  };\n\n  AbstractMatrix.prototype.divS = function divS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.divM = function divM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.div = function div(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.div(value);\n  };\n  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;\n  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;\n  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;\n  AbstractMatrix.divide = AbstractMatrix.div;\n\n  AbstractMatrix.prototype.mod = function mod(value) {\n    if (typeof value === 'number') return this.modS(value);\n    return this.modM(value);\n  };\n\n  AbstractMatrix.prototype.modS = function modS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.modM = function modM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mod = function mod(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mod(value);\n  };\n  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;\n  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;\n  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;\n  AbstractMatrix.modulus = AbstractMatrix.mod;\n\n  AbstractMatrix.prototype.and = function and(value) {\n    if (typeof value === 'number') return this.andS(value);\n    return this.andM(value);\n  };\n\n  AbstractMatrix.prototype.andS = function andS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.andM = function andM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.and = function and(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.and(value);\n  };\n\n  AbstractMatrix.prototype.or = function or(value) {\n    if (typeof value === 'number') return this.orS(value);\n    return this.orM(value);\n  };\n\n  AbstractMatrix.prototype.orS = function orS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.orM = function orM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.or = function or(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.or(value);\n  };\n\n  AbstractMatrix.prototype.xor = function xor(value) {\n    if (typeof value === 'number') return this.xorS(value);\n    return this.xorM(value);\n  };\n\n  AbstractMatrix.prototype.xorS = function xorS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.xorM = function xorM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.xor = function xor(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.xor(value);\n  };\n\n  AbstractMatrix.prototype.leftShift = function leftShift(value) {\n    if (typeof value === 'number') return this.leftShiftS(value);\n    return this.leftShiftM(value);\n  };\n\n  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.leftShift = function leftShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.leftShift(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {\n    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);\n    return this.signPropagatingRightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.signPropagatingRightShift(value);\n  };\n\n  AbstractMatrix.prototype.rightShift = function rightShift(value) {\n    if (typeof value === 'number') return this.rightShiftS(value);\n    return this.rightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.rightShift = function rightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.rightShift(value);\n  };\n  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;\n  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;\n  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;\n  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;\n\n  AbstractMatrix.prototype.not = function not() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, ~(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.not = function not(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.not();\n  };\n\n  AbstractMatrix.prototype.abs = function abs() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.abs(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.abs = function abs(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.abs();\n  };\n\n  AbstractMatrix.prototype.acos = function acos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acos = function acos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acos();\n  };\n\n  AbstractMatrix.prototype.acosh = function acosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acosh = function acosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acosh();\n  };\n\n  AbstractMatrix.prototype.asin = function asin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asin = function asin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asin();\n  };\n\n  AbstractMatrix.prototype.asinh = function asinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asinh = function asinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asinh();\n  };\n\n  AbstractMatrix.prototype.atan = function atan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atan = function atan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atan();\n  };\n\n  AbstractMatrix.prototype.atanh = function atanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atanh = function atanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atanh();\n  };\n\n  AbstractMatrix.prototype.cbrt = function cbrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cbrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cbrt = function cbrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cbrt();\n  };\n\n  AbstractMatrix.prototype.ceil = function ceil() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.ceil(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.ceil = function ceil(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.ceil();\n  };\n\n  AbstractMatrix.prototype.clz32 = function clz32() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.clz32(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.clz32 = function clz32(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.clz32();\n  };\n\n  AbstractMatrix.prototype.cos = function cos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cos = function cos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cos();\n  };\n\n  AbstractMatrix.prototype.cosh = function cosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cosh = function cosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cosh();\n  };\n\n  AbstractMatrix.prototype.exp = function exp() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.exp(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.exp = function exp(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.exp();\n  };\n\n  AbstractMatrix.prototype.expm1 = function expm1() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.expm1(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.expm1 = function expm1(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.expm1();\n  };\n\n  AbstractMatrix.prototype.floor = function floor() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.floor(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.floor = function floor(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.floor();\n  };\n\n  AbstractMatrix.prototype.fround = function fround() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.fround(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.fround = function fround(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.fround();\n  };\n\n  AbstractMatrix.prototype.log = function log() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log = function log(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log();\n  };\n\n  AbstractMatrix.prototype.log1p = function log1p() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log1p(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log1p = function log1p(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log1p();\n  };\n\n  AbstractMatrix.prototype.log10 = function log10() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log10(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log10 = function log10(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log10();\n  };\n\n  AbstractMatrix.prototype.log2 = function log2() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log2(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log2 = function log2(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log2();\n  };\n\n  AbstractMatrix.prototype.round = function round() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.round(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.round = function round(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.round();\n  };\n\n  AbstractMatrix.prototype.sign = function sign() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sign(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sign = function sign(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sign();\n  };\n\n  AbstractMatrix.prototype.sin = function sin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sin = function sin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sin();\n  };\n\n  AbstractMatrix.prototype.sinh = function sinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sinh = function sinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sinh();\n  };\n\n  AbstractMatrix.prototype.sqrt = function sqrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sqrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sqrt = function sqrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sqrt();\n  };\n\n  AbstractMatrix.prototype.tan = function tan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tan = function tan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tan();\n  };\n\n  AbstractMatrix.prototype.tanh = function tanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tanh = function tanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tanh();\n  };\n\n  AbstractMatrix.prototype.trunc = function trunc() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.trunc(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.trunc = function trunc(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.trunc();\n  };\n\n  AbstractMatrix.pow = function pow(matrix, arg0) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.pow(arg0);\n  };\n\n  AbstractMatrix.prototype.pow = function pow(value) {\n    if (typeof value === 'number') return this.powS(value);\n    return this.powM(value);\n  };\n\n  AbstractMatrix.prototype.powS = function powS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), value));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.powM = function powM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), matrix.get(i, j)));\n      }\n    }\n    return this;\n  };\n}\n","import rescale from 'ml-array-rescale';\n\nimport { inspectMatrix, inspectMatrixWithOptions } from './inspect';\nimport { installMathOperations } from './mathOperations';\nimport {\n  sumByRow,\n  sumByColumn,\n  sumAll,\n  productByRow,\n  productByColumn,\n  productAll,\n  varianceByRow,\n  varianceByColumn,\n  varianceAll,\n  centerByRow,\n  centerByColumn,\n  centerAll,\n  scaleByRow,\n  scaleByColumn,\n  scaleAll,\n  getScaleByRow,\n  getScaleByColumn,\n  getScaleAll,\n} from './stat';\nimport {\n  checkRowVector,\n  checkRowIndex,\n  checkColumnIndex,\n  checkColumnVector,\n  checkRange,\n  checkIndices,\n  checkNonEmpty,\n} from './util';\n\nexport class AbstractMatrix {\n  static from1DArray(newRows, newColumns, newData) {\n    let length = newRows * newColumns;\n    if (length !== newData.length) {\n      throw new RangeError('data length does not match given dimensions');\n    }\n    let newMatrix = new Matrix(newRows, newColumns);\n    for (let row = 0; row < newRows; row++) {\n      for (let column = 0; column < newColumns; column++) {\n        newMatrix.set(row, column, newData[row * newColumns + column]);\n      }\n    }\n    return newMatrix;\n  }\n\n  static rowVector(newData) {\n    let vector = new Matrix(1, newData.length);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(0, i, newData[i]);\n    }\n    return vector;\n  }\n\n  static columnVector(newData) {\n    let vector = new Matrix(newData.length, 1);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(i, 0, newData[i]);\n    }\n    return vector;\n  }\n\n  static zeros(rows, columns) {\n    return new Matrix(rows, columns);\n  }\n\n  static ones(rows, columns) {\n    return new Matrix(rows, columns).fill(1);\n  }\n\n  static rand(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { random = Math.random } = options;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.set(i, j, random());\n      }\n    }\n    return matrix;\n  }\n\n  static randInt(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1000, random = Math.random } = options;\n    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');\n    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let interval = max - min;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        let value = min + Math.round(random() * interval);\n        matrix.set(i, j, value);\n      }\n    }\n    return matrix;\n  }\n\n  static eye(rows, columns, value) {\n    if (columns === undefined) columns = rows;\n    if (value === undefined) value = 1;\n    let min = Math.min(rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, value);\n    }\n    return matrix;\n  }\n\n  static diag(data, rows, columns) {\n    let l = data.length;\n    if (rows === undefined) rows = l;\n    if (columns === undefined) columns = rows;\n    let min = Math.min(l, rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, data[i]);\n    }\n    return matrix;\n  }\n\n  static min(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static max(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new this(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static checkMatrix(value) {\n    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);\n  }\n\n  static isMatrix(value) {\n    return value != null && value.klass === 'Matrix';\n  }\n\n  get size() {\n    return this.rows * this.columns;\n  }\n\n  apply(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        callback.call(this, i, j);\n      }\n    }\n    return this;\n  }\n\n  to1DArray() {\n    let array = [];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        array.push(this.get(i, j));\n      }\n    }\n    return array;\n  }\n\n  to2DArray() {\n    let copy = [];\n    for (let i = 0; i < this.rows; i++) {\n      copy.push([]);\n      for (let j = 0; j < this.columns; j++) {\n        copy[i].push(this.get(i, j));\n      }\n    }\n    return copy;\n  }\n\n  toJSON() {\n    return this.to2DArray();\n  }\n\n  isRowVector() {\n    return this.rows === 1;\n  }\n\n  isColumnVector() {\n    return this.columns === 1;\n  }\n\n  isVector() {\n    return this.rows === 1 || this.columns === 1;\n  }\n\n  isSquare() {\n    return this.rows === this.columns;\n  }\n\n  isEmpty() {\n    return this.rows === 0 || this.columns === 0;\n  }\n\n  isSymmetric() {\n    if (this.isSquare()) {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j <= i; j++) {\n          if (this.get(i, j) !== this.get(j, i)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  isEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isEchelonForm = false;\n          checked = true;\n        }\n      }\n      i++;\n    }\n    return isEchelonForm;\n  }\n\n  isReducedEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isReducedEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isReducedEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isReducedEchelonForm = false;\n          checked = true;\n        }\n      }\n      for (let k = j + 1; k < this.rows; k++) {\n        if (this.get(i, k) !== 0) {\n          isReducedEchelonForm = false;\n        }\n      }\n      i++;\n    }\n    return isReducedEchelonForm;\n  }\n\n  echelonForm() {\n    let result = this.clone();\n    let h = 0;\n    let k = 0;\n    while (h < result.rows && k < result.columns) {\n      let iMax = h;\n      for (let i = h; i < result.rows; i++) {\n        if (result.get(i, k) > result.get(iMax, k)) {\n          iMax = i;\n        }\n      }\n      if (result.get(iMax, k) === 0) {\n        k++;\n      } else {\n        result.swapRows(h, iMax);\n        let tmp = result.get(h, k);\n        for (let j = k; j < result.columns; j++) {\n          result.set(h, j, result.get(h, j) / tmp);\n        }\n        for (let i = h + 1; i < result.rows; i++) {\n          let factor = result.get(i, k) / result.get(h, k);\n          result.set(i, k, 0);\n          for (let j = k + 1; j < result.columns; j++) {\n            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);\n          }\n        }\n        h++;\n        k++;\n      }\n    }\n    return result;\n  }\n\n  reducedEchelonForm() {\n    let result = this.echelonForm();\n    let m = result.columns;\n    let n = result.rows;\n    let h = n - 1;\n    while (h >= 0) {\n      if (result.maxRow(h) === 0) {\n        h--;\n      } else {\n        let p = 0;\n        let pivot = false;\n        while (p < n && pivot === false) {\n          if (result.get(h, p) === 1) {\n            pivot = true;\n          } else {\n            p++;\n          }\n        }\n        for (let i = 0; i < h; i++) {\n          let factor = result.get(i, p);\n          for (let j = p; j < m; j++) {\n            let tmp = result.get(i, j) - factor * result.get(h, j);\n            result.set(i, j, tmp);\n          }\n        }\n        h--;\n      }\n    }\n    return result;\n  }\n\n  set() {\n    throw new Error('set method is unimplemented');\n  }\n\n  get() {\n    throw new Error('get method is unimplemented');\n  }\n\n  repeat(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { rows = 1, columns = 1 } = options;\n    if (!Number.isInteger(rows) || rows <= 0) {\n      throw new TypeError('rows must be a positive integer');\n    }\n    if (!Number.isInteger(columns) || columns <= 0) {\n      throw new TypeError('columns must be a positive integer');\n    }\n    let matrix = new Matrix(this.rows * rows, this.columns * columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.setSubMatrix(this, this.rows * i, this.columns * j);\n      }\n    }\n    return matrix;\n  }\n\n  fill(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, value);\n      }\n    }\n    return this;\n  }\n\n  neg() {\n    return this.mulS(-1);\n  }\n\n  getRow(index) {\n    checkRowIndex(this, index);\n    let row = [];\n    for (let i = 0; i < this.columns; i++) {\n      row.push(this.get(index, i));\n    }\n    return row;\n  }\n\n  getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n  }\n\n  setRow(index, array) {\n    checkRowIndex(this, index);\n    array = checkRowVector(this, array);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, array[i]);\n    }\n    return this;\n  }\n\n  swapRows(row1, row2) {\n    checkRowIndex(this, row1);\n    checkRowIndex(this, row2);\n    for (let i = 0; i < this.columns; i++) {\n      let temp = this.get(row1, i);\n      this.set(row1, i, this.get(row2, i));\n      this.set(row2, i, temp);\n    }\n    return this;\n  }\n\n  getColumn(index) {\n    checkColumnIndex(this, index);\n    let column = [];\n    for (let i = 0; i < this.rows; i++) {\n      column.push(this.get(i, index));\n    }\n    return column;\n  }\n\n  getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n  }\n\n  setColumn(index, array) {\n    checkColumnIndex(this, index);\n    array = checkColumnVector(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, array[i]);\n    }\n    return this;\n  }\n\n  swapColumns(column1, column2) {\n    checkColumnIndex(this, column1);\n    checkColumnIndex(this, column2);\n    for (let i = 0; i < this.rows; i++) {\n      let temp = this.get(i, column1);\n      this.set(i, column1, this.get(i, column2));\n      this.set(i, column2, temp);\n    }\n    return this;\n  }\n\n  addRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[j]);\n      }\n    }\n    return this;\n  }\n\n  subRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[j]);\n      }\n    }\n    return this;\n  }\n\n  mulRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[j]);\n      }\n    }\n    return this;\n  }\n\n  divRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[j]);\n      }\n    }\n    return this;\n  }\n\n  addColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[i]);\n      }\n    }\n    return this;\n  }\n\n  subColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[i]);\n      }\n    }\n    return this;\n  }\n\n  divColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulRow(index, value) {\n    checkRowIndex(this, index);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, this.get(index, i) * value);\n    }\n    return this;\n  }\n\n  mulColumn(index, value) {\n    checkColumnIndex(this, index);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, this.get(i, index) * value);\n    }\n    return this;\n  }\n\n  max() {\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  maxIndex() {\n    checkNonEmpty(this);\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  min() {\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  minIndex() {\n    checkNonEmpty(this);\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  maxRow(row) {\n    checkRowIndex(this, row);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  maxRowIndex(row) {\n    checkRowIndex(this, row);\n    checkNonEmpty(this);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  minRow(row) {\n    checkRowIndex(this, row);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  minRowIndex(row) {\n    checkRowIndex(this, row);\n    checkNonEmpty(this);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  maxColumn(column) {\n    checkColumnIndex(this, column);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  maxColumnIndex(column) {\n    checkColumnIndex(this, column);\n    checkNonEmpty(this);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  minColumn(column) {\n    checkColumnIndex(this, column);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  minColumnIndex(column) {\n    checkColumnIndex(this, column);\n    checkNonEmpty(this);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  diag() {\n    let min = Math.min(this.rows, this.columns);\n    let diag = [];\n    for (let i = 0; i < min; i++) {\n      diag.push(this.get(i, i));\n    }\n    return diag;\n  }\n\n  norm(type = 'frobenius') {\n    let result = 0;\n    if (type === 'max') {\n      return this.max();\n    } else if (type === 'frobenius') {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j < this.columns; j++) {\n          result = result + this.get(i, j) * this.get(i, j);\n        }\n      }\n      return Math.sqrt(result);\n    } else {\n      throw new RangeError(`unknown norm type: ${type}`);\n    }\n  }\n\n  cumulativeSum() {\n    let sum = 0;\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        sum += this.get(i, j);\n        this.set(i, j, sum);\n      }\n    }\n    return this;\n  }\n\n  dot(vector2) {\n    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\n    let vector1 = this.to1DArray();\n    if (vector1.length !== vector2.length) {\n      throw new RangeError('vectors do not have the same size');\n    }\n    let dot = 0;\n    for (let i = 0; i < vector1.length; i++) {\n      dot += vector1[i] * vector2[i];\n    }\n    return dot;\n  }\n\n  mmul(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.columns;\n\n    let result = new Matrix(m, p);\n\n    let Bcolj = new Float64Array(n);\n    for (let j = 0; j < p; j++) {\n      for (let k = 0; k < n; k++) {\n        Bcolj[k] = other.get(k, j);\n      }\n\n      for (let i = 0; i < m; i++) {\n        let s = 0;\n        for (let k = 0; k < n; k++) {\n          s += this.get(i, k) * Bcolj[k];\n        }\n\n        result.set(i, j, s);\n      }\n    }\n    return result;\n  }\n\n  strassen2x2(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(2, 2);\n    const a11 = this.get(0, 0);\n    const b11 = other.get(0, 0);\n    const a12 = this.get(0, 1);\n    const b12 = other.get(0, 1);\n    const a21 = this.get(1, 0);\n    const b21 = other.get(1, 0);\n    const a22 = this.get(1, 1);\n    const b22 = other.get(1, 1);\n\n    // Compute intermediate values.\n    const m1 = (a11 + a22) * (b11 + b22);\n    const m2 = (a21 + a22) * b11;\n    const m3 = a11 * (b12 - b22);\n    const m4 = a22 * (b21 - b11);\n    const m5 = (a11 + a12) * b22;\n    const m6 = (a21 - a11) * (b11 + b12);\n    const m7 = (a12 - a22) * (b21 + b22);\n\n    // Combine intermediate values into the output.\n    const c00 = m1 + m4 - m5 + m7;\n    const c01 = m3 + m5;\n    const c10 = m2 + m4;\n    const c11 = m1 - m2 + m3 + m6;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    return result;\n  }\n\n  strassen3x3(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(3, 3);\n\n    const a00 = this.get(0, 0);\n    const a01 = this.get(0, 1);\n    const a02 = this.get(0, 2);\n    const a10 = this.get(1, 0);\n    const a11 = this.get(1, 1);\n    const a12 = this.get(1, 2);\n    const a20 = this.get(2, 0);\n    const a21 = this.get(2, 1);\n    const a22 = this.get(2, 2);\n\n    const b00 = other.get(0, 0);\n    const b01 = other.get(0, 1);\n    const b02 = other.get(0, 2);\n    const b10 = other.get(1, 0);\n    const b11 = other.get(1, 1);\n    const b12 = other.get(1, 2);\n    const b20 = other.get(2, 0);\n    const b21 = other.get(2, 1);\n    const b22 = other.get(2, 2);\n\n    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\n    const m2 = (a00 - a10) * (-b01 + b11);\n    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\n    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\n    const m5 = (a10 + a11) * (-b00 + b01);\n    const m6 = a00 * b00;\n    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\n    const m8 = (-a00 + a20) * (b02 - b12);\n    const m9 = (a20 + a21) * (-b00 + b02);\n    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\n    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\n    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\n    const m13 = (a02 - a22) * (b11 - b21);\n    const m14 = a02 * b20;\n    const m15 = (a21 + a22) * (-b20 + b21);\n    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\n    const m17 = (a02 - a12) * (b12 - b22);\n    const m18 = (a11 + a12) * (-b20 + b22);\n    const m19 = a01 * b10;\n    const m20 = a12 * b21;\n    const m21 = a10 * b02;\n    const m22 = a20 * b01;\n    const m23 = a22 * b22;\n\n    const c00 = m6 + m14 + m19;\n    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\n    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\n    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\n    const c11 = m2 + m4 + m5 + m6 + m20;\n    const c12 = m14 + m16 + m17 + m18 + m21;\n    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\n    const c21 = m12 + m13 + m14 + m15 + m22;\n    const c22 = m6 + m7 + m8 + m9 + m23;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(0, 2, c02);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    result.set(1, 2, c12);\n    result.set(2, 0, c20);\n    result.set(2, 1, c21);\n    result.set(2, 2, c22);\n    return result;\n  }\n\n  mmulStrassen(y) {\n    y = Matrix.checkMatrix(y);\n    let x = this.clone();\n    let r1 = x.rows;\n    let c1 = x.columns;\n    let r2 = y.rows;\n    let c2 = y.columns;\n    if (c1 !== r2) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,\n      );\n    }\n\n    // Put a matrix into the top left of a matrix of zeros.\n    // `rows` and `cols` are the dimensions of the output matrix.\n    function embed(mat, rows, cols) {\n      let r = mat.rows;\n      let c = mat.columns;\n      if (r === rows && c === cols) {\n        return mat;\n      } else {\n        let resultat = AbstractMatrix.zeros(rows, cols);\n        resultat = resultat.setSubMatrix(mat, 0, 0);\n        return resultat;\n      }\n    }\n\n    // Make sure both matrices are the same size.\n    // This is exclusively for simplicity:\n    // this algorithm can be implemented with matrices of different sizes.\n\n    let r = Math.max(r1, r2);\n    let c = Math.max(c1, c2);\n    x = embed(x, r, c);\n    y = embed(y, r, c);\n\n    // Our recursive multiplication function.\n    function blockMult(a, b, rows, cols) {\n      // For small matrices, resort to naive multiplication.\n      if (rows <= 512 || cols <= 512) {\n        return a.mmul(b); // a is equivalent to this\n      }\n\n      // Apply dynamic padding.\n      if (rows % 2 === 1 && cols % 2 === 1) {\n        a = embed(a, rows + 1, cols + 1);\n        b = embed(b, rows + 1, cols + 1);\n      } else if (rows % 2 === 1) {\n        a = embed(a, rows + 1, cols);\n        b = embed(b, rows + 1, cols);\n      } else if (cols % 2 === 1) {\n        a = embed(a, rows, cols + 1);\n        b = embed(b, rows, cols + 1);\n      }\n\n      let halfRows = parseInt(a.rows / 2, 10);\n      let halfCols = parseInt(a.columns / 2, 10);\n      // Subdivide input matrices.\n      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n\n      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\n      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\n\n      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\n      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\n\n      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\n      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\n\n      // Compute intermediate values.\n      let m1 = blockMult(\n        AbstractMatrix.add(a11, a22),\n        AbstractMatrix.add(b11, b22),\n        halfRows,\n        halfCols,\n      );\n      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);\n      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);\n      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);\n      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);\n      let m6 = blockMult(\n        AbstractMatrix.sub(a21, a11),\n        AbstractMatrix.add(b11, b12),\n        halfRows,\n        halfCols,\n      );\n      let m7 = blockMult(\n        AbstractMatrix.sub(a12, a22),\n        AbstractMatrix.add(b21, b22),\n        halfRows,\n        halfCols,\n      );\n\n      // Combine intermediate values into the output.\n      let c11 = AbstractMatrix.add(m1, m4);\n      c11.sub(m5);\n      c11.add(m7);\n      let c12 = AbstractMatrix.add(m3, m5);\n      let c21 = AbstractMatrix.add(m2, m4);\n      let c22 = AbstractMatrix.sub(m1, m2);\n      c22.add(m3);\n      c22.add(m6);\n\n      // Crop output to the desired size (undo dynamic padding).\n      let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);\n      resultat = resultat.setSubMatrix(c11, 0, 0);\n      resultat = resultat.setSubMatrix(c12, c11.rows, 0);\n      resultat = resultat.setSubMatrix(c21, 0, c11.columns);\n      resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);\n      return resultat.subMatrix(0, rows - 1, 0, cols - 1);\n    }\n    return blockMult(x, y, r, c);\n  }\n\n  scaleRows(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.rows; i++) {\n      const row = this.getRow(i);\n      if (row.length > 0) {\n        rescale(row, { min, max, output: row });\n      }\n      newMatrix.setRow(i, row);\n    }\n    return newMatrix;\n  }\n\n  scaleColumns(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.columns; i++) {\n      const column = this.getColumn(i);\n      if (column.length) {\n        rescale(column, {\n          min: min,\n          max: max,\n          output: column,\n        });\n      }\n      newMatrix.setColumn(i, column);\n    }\n    return newMatrix;\n  }\n\n  flipRows() {\n    const middle = Math.ceil(this.columns / 2);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < middle; j++) {\n        let first = this.get(i, j);\n        let last = this.get(i, this.columns - 1 - j);\n        this.set(i, j, last);\n        this.set(i, this.columns - 1 - j, first);\n      }\n    }\n    return this;\n  }\n\n  flipColumns() {\n    const middle = Math.ceil(this.rows / 2);\n    for (let j = 0; j < this.columns; j++) {\n      for (let i = 0; i < middle; i++) {\n        let first = this.get(i, j);\n        let last = this.get(this.rows - 1 - i, j);\n        this.set(i, j, last);\n        this.set(this.rows - 1 - i, j, first);\n      }\n    }\n    return this;\n  }\n\n  kroneckerProduct(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.rows;\n    let q = other.columns;\n\n    let result = new Matrix(m * p, n * q);\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        for (let k = 0; k < p; k++) {\n          for (let l = 0; l < q; l++) {\n            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  kroneckerSum(other) {\n    other = Matrix.checkMatrix(other);\n    if (!this.isSquare() || !other.isSquare()) {\n      throw new Error('Kronecker Sum needs two Square Matrices');\n    }\n    let m = this.rows;\n    let n = other.rows;\n    let AxI = this.kroneckerProduct(Matrix.eye(n, n));\n    let IxB = Matrix.eye(m, m).kroneckerProduct(other);\n    return AxI.add(IxB);\n  }\n\n  transpose() {\n    let result = new Matrix(this.columns, this.rows);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        result.set(j, i, this.get(i, j));\n      }\n    }\n    return result;\n  }\n\n  sortRows(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.rows; i++) {\n      this.setRow(i, this.getRow(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  sortColumns(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.columns; i++) {\n      this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  subMatrix(startRow, endRow, startColumn, endColumn) {\n    checkRange(this, startRow, endRow, startColumn, endColumn);\n    let newMatrix = new Matrix(\n      endRow - startRow + 1,\n      endColumn - startColumn + 1,\n    );\n    for (let i = startRow; i <= endRow; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixRow(indices, startColumn, endColumn) {\n    if (startColumn === undefined) startColumn = 0;\n    if (endColumn === undefined) endColumn = this.columns - 1;\n    if (\n      startColumn > endColumn ||\n      startColumn < 0 ||\n      startColumn >= this.columns ||\n      endColumn < 0 ||\n      endColumn >= this.columns\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        if (indices[i] < 0 || indices[i] >= this.rows) {\n          throw new RangeError(`Row index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(i, j - startColumn, this.get(indices[i], j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixColumn(indices, startRow, endRow) {\n    if (startRow === undefined) startRow = 0;\n    if (endRow === undefined) endRow = this.rows - 1;\n    if (\n      startRow > endRow ||\n      startRow < 0 ||\n      startRow >= this.rows ||\n      endRow < 0 ||\n      endRow >= this.rows\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startRow; j <= endRow; j++) {\n        if (indices[i] < 0 || indices[i] >= this.columns) {\n          throw new RangeError(`Column index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(j - startRow, i, this.get(j, indices[i]));\n      }\n    }\n    return newMatrix;\n  }\n\n  setSubMatrix(matrix, startRow, startColumn) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (matrix.isEmpty()) {\n      return this;\n    }\n    let endRow = startRow + matrix.rows - 1;\n    let endColumn = startColumn + matrix.columns - 1;\n    checkRange(this, startRow, endRow, startColumn, endColumn);\n    for (let i = 0; i < matrix.rows; i++) {\n      for (let j = 0; j < matrix.columns; j++) {\n        this.set(startRow + i, startColumn + j, matrix.get(i, j));\n      }\n    }\n    return this;\n  }\n\n  selection(rowIndices, columnIndices) {\n    let indices = checkIndices(this, rowIndices, columnIndices);\n    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);\n    for (let i = 0; i < indices.row.length; i++) {\n      let rowIndex = indices.row[i];\n      for (let j = 0; j < indices.column.length; j++) {\n        let columnIndex = indices.column[j];\n        newMatrix.set(i, j, this.get(rowIndex, columnIndex));\n      }\n    }\n    return newMatrix;\n  }\n\n  trace() {\n    let min = Math.min(this.rows, this.columns);\n    let trace = 0;\n    for (let i = 0; i < min; i++) {\n      trace += this.get(i, i);\n    }\n    return trace;\n  }\n\n  clone() {\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let row = 0; row < this.rows; row++) {\n      for (let column = 0; column < this.columns; column++) {\n        newMatrix.set(row, column, this.get(row, column));\n      }\n    }\n    return newMatrix;\n  }\n\n  sum(by) {\n    switch (by) {\n      case 'row':\n        return sumByRow(this);\n      case 'column':\n        return sumByColumn(this);\n      case undefined:\n        return sumAll(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  product(by) {\n    switch (by) {\n      case 'row':\n        return productByRow(this);\n      case 'column':\n        return productByColumn(this);\n      case undefined:\n        return productAll(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  mean(by) {\n    const sum = this.sum(by);\n    switch (by) {\n      case 'row': {\n        for (let i = 0; i < this.rows; i++) {\n          sum[i] /= this.columns;\n        }\n        return sum;\n      }\n      case 'column': {\n        for (let i = 0; i < this.columns; i++) {\n          sum[i] /= this.rows;\n        }\n        return sum;\n      }\n      case undefined:\n        return sum / this.size;\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  variance(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { unbiased = true, mean = this.mean(by) } = options;\n    if (typeof unbiased !== 'boolean') {\n      throw new TypeError('unbiased must be a boolean');\n    }\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return varianceByRow(this, unbiased, mean);\n      }\n      case 'column': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return varianceByColumn(this, unbiased, mean);\n      }\n      case undefined: {\n        if (typeof mean !== 'number') {\n          throw new TypeError('mean must be a number');\n        }\n        return varianceAll(this, unbiased, mean);\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  standardDeviation(by, options) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    const variance = this.variance(by, options);\n    if (by === undefined) {\n      return Math.sqrt(variance);\n    } else {\n      for (let i = 0; i < variance.length; i++) {\n        variance[i] = Math.sqrt(variance[i]);\n      }\n      return variance;\n    }\n  }\n\n  center(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { center = this.mean(by) } = options;\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        centerByRow(this, center);\n        return this;\n      }\n      case 'column': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        centerByColumn(this, center);\n        return this;\n      }\n      case undefined: {\n        if (typeof center !== 'number') {\n          throw new TypeError('center must be a number');\n        }\n        centerAll(this, center);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  scale(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    let scale = options.scale;\n    switch (by) {\n      case 'row': {\n        if (scale === undefined) {\n          scale = getScaleByRow(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        scaleByRow(this, scale);\n        return this;\n      }\n      case 'column': {\n        if (scale === undefined) {\n          scale = getScaleByColumn(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        scaleByColumn(this, scale);\n        return this;\n      }\n      case undefined: {\n        if (scale === undefined) {\n          scale = getScaleAll(this);\n        } else if (typeof scale !== 'number') {\n          throw new TypeError('scale must be a number');\n        }\n        scaleAll(this, scale);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  toString(options) {\n    return inspectMatrixWithOptions(this, options);\n  }\n}\n\nAbstractMatrix.prototype.klass = 'Matrix';\nif (typeof Symbol !== 'undefined') {\n  AbstractMatrix.prototype[\n    Symbol.for('nodejs.util.inspect.custom')\n  ] = inspectMatrix;\n}\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\n// Synonyms\nAbstractMatrix.random = AbstractMatrix.rand;\nAbstractMatrix.randomInt = AbstractMatrix.randInt;\nAbstractMatrix.diagonal = AbstractMatrix.diag;\nAbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;\nAbstractMatrix.identity = AbstractMatrix.eye;\nAbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;\nAbstractMatrix.prototype.tensorProduct =\n  AbstractMatrix.prototype.kroneckerProduct;\n\nexport default class Matrix extends AbstractMatrix {\n  constructor(nRows, nColumns) {\n    super();\n    if (Matrix.isMatrix(nRows)) {\n      // eslint-disable-next-line no-constructor-return\n      return nRows.clone();\n    } else if (Number.isInteger(nRows) && nRows >= 0) {\n      // Create an empty matrix\n      this.data = [];\n      if (Number.isInteger(nColumns) && nColumns >= 0) {\n        for (let i = 0; i < nRows; i++) {\n          this.data.push(new Float64Array(nColumns));\n        }\n      } else {\n        throw new TypeError('nColumns must be a positive integer');\n      }\n    } else if (Array.isArray(nRows)) {\n      // Copy the values from the 2D array\n      const arrayData = nRows;\n      nRows = arrayData.length;\n      nColumns = nRows ? arrayData[0].length : 0;\n      if (typeof nColumns !== 'number') {\n        throw new TypeError(\n          'Data must be a 2D array with at least one element',\n        );\n      }\n      this.data = [];\n      for (let i = 0; i < nRows; i++) {\n        if (arrayData[i].length !== nColumns) {\n          throw new RangeError('Inconsistent array dimensions');\n        }\n        this.data.push(Float64Array.from(arrayData[i]));\n      }\n    } else {\n      throw new TypeError(\n        'First argument must be a positive number or an array',\n      );\n    }\n    this.rows = nRows;\n    this.columns = nColumns;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n\n  removeRow(index) {\n    checkRowIndex(this, index);\n    this.data.splice(index, 1);\n    this.rows -= 1;\n    return this;\n  }\n\n  addRow(index, array) {\n    if (array === undefined) {\n      array = index;\n      index = this.rows;\n    }\n    checkRowIndex(this, index, true);\n    array = Float64Array.from(checkRowVector(this, array));\n    this.data.splice(index, 0, array);\n    this.rows += 1;\n    return this;\n  }\n\n  removeColumn(index) {\n    checkColumnIndex(this, index);\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns - 1);\n      for (let j = 0; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      for (let j = index + 1; j < this.columns; j++) {\n        newRow[j - 1] = this.data[i][j];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns -= 1;\n    return this;\n  }\n\n  addColumn(index, array) {\n    if (typeof array === 'undefined') {\n      array = index;\n      index = this.columns;\n    }\n    checkColumnIndex(this, index, true);\n    array = checkColumnVector(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns + 1);\n      let j = 0;\n      for (; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      newRow[j++] = array[i];\n      for (; j < this.columns + 1; j++) {\n        newRow[j] = this.data[i][j - 1];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns += 1;\n    return this;\n  }\n}\n\ninstallMathOperations(AbstractMatrix, Matrix);\n","import SVD from './dc/svd';\nimport Matrix from './matrix';\n\nexport function pseudoInverse(matrix, threshold = Number.EPSILON) {\n  matrix = Matrix.checkMatrix(matrix);\n  if (matrix.isEmpty()) {\n    // with a zero dimension, the pseudo-inverse is the transpose, since all 0xn and nx0 matrices are singular\n    // (0xn)*(nx0)*(0xn) = 0xn\n    // (nx0)*(0xn)*(nx0) = nx0\n    return matrix.transpose();\n  }\n  let svdSolution = new SVD(matrix, { autoTranspose: true });\n\n  let U = svdSolution.leftSingularVectors;\n  let V = svdSolution.rightSingularVectors;\n  let s = svdSolution.diagonal;\n\n  for (let i = 0; i < s.length; i++) {\n    if (Math.abs(s[i]) > threshold) {\n      s[i] = 1.0 / s[i];\n    } else {\n      s[i] = 0.0;\n    }\n  }\n\n  return V.mmul(Matrix.diag(s).mmul(U.transpose()));\n}\n","import { newArray } from './util';\n\nexport function sumByRow(matrix) {\n  let sum = newArray(matrix.rows);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function sumByColumn(matrix) {\n  let sum = newArray(matrix.columns);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function sumAll(matrix) {\n  let v = 0;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v += matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nexport function productByRow(matrix) {\n  let sum = newArray(matrix.rows, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function productByColumn(matrix) {\n  let sum = newArray(matrix.columns, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function productAll(matrix) {\n  let v = 1;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v *= matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nexport function varianceByRow(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let i = 0; i < rows; i++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean[i];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / cols) / cols);\n    }\n  }\n  return variance;\n}\n\nexport function varianceByColumn(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let j = 0; j < cols; j++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let i = 0; i < rows; i++) {\n      x = matrix.get(i, j) - mean[j];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / rows) / rows);\n    }\n  }\n  return variance;\n}\n\nexport function varianceAll(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const size = rows * cols;\n\n  let sum1 = 0;\n  let sum2 = 0;\n  let x = 0;\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean;\n      sum1 += x;\n      sum2 += x * x;\n    }\n  }\n  if (unbiased) {\n    return (sum2 - (sum1 * sum1) / size) / (size - 1);\n  } else {\n    return (sum2 - (sum1 * sum1) / size) / size;\n  }\n}\n\nexport function centerByRow(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[i]);\n    }\n  }\n}\n\nexport function centerByColumn(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[j]);\n    }\n  }\n}\n\nexport function centerAll(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean);\n    }\n  }\n}\n\nexport function getScaleByRow(matrix) {\n  const scale = [];\n  for (let i = 0; i < matrix.rows; i++) {\n    let sum = 0;\n    for (let j = 0; j < matrix.columns; j++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.columns - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nexport function scaleByRow(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[i]);\n    }\n  }\n}\n\nexport function getScaleByColumn(matrix) {\n  const scale = [];\n  for (let j = 0; j < matrix.columns; j++) {\n    let sum = 0;\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.rows - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nexport function scaleByColumn(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[j]);\n    }\n  }\n}\n\nexport function getScaleAll(matrix) {\n  const divider = matrix.size - 1;\n  let sum = 0;\n  for (let j = 0; j < matrix.columns; j++) {\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / divider;\n    }\n  }\n  return Math.sqrt(sum);\n}\n\nexport function scaleAll(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale);\n    }\n  }\n}\n","/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexport function checkRowIndex(matrix, index, outer) {\n  let max = outer ? matrix.rows : matrix.rows - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Row index out of range');\n  }\n}\n\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexport function checkColumnIndex(matrix, index, outer) {\n  let max = outer ? matrix.columns : matrix.columns - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Column index out of range');\n  }\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexport function checkRowVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.columns) {\n    throw new RangeError(\n      'vector size must be the same as the number of columns',\n    );\n  }\n  return vector;\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexport function checkColumnVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.rows) {\n    throw new RangeError('vector size must be the same as the number of rows');\n  }\n  return vector;\n}\n\nexport function checkIndices(matrix, rowIndices, columnIndices) {\n  return {\n    row: checkRowIndices(matrix, rowIndices),\n    column: checkColumnIndices(matrix, columnIndices),\n  };\n}\n\nexport function checkRowIndices(matrix, rowIndices) {\n  if (typeof rowIndices !== 'object') {\n    throw new TypeError('unexpected type for row indices');\n  }\n\n  let rowOut = rowIndices.some((r) => {\n    return r < 0 || r >= matrix.rows;\n  });\n\n  if (rowOut) {\n    throw new RangeError('row indices are out of range');\n  }\n\n  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\n\n  return rowIndices;\n}\n\nexport function checkColumnIndices(matrix, columnIndices) {\n  if (typeof columnIndices !== 'object') {\n    throw new TypeError('unexpected type for column indices');\n  }\n\n  let columnOut = columnIndices.some((c) => {\n    return c < 0 || c >= matrix.columns;\n  });\n\n  if (columnOut) {\n    throw new RangeError('column indices are out of range');\n  }\n  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);\n\n  return columnIndices;\n}\n\nexport function checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n  if (arguments.length !== 5) {\n    throw new RangeError('expected 4 arguments');\n  }\n  checkNumber('startRow', startRow);\n  checkNumber('endRow', endRow);\n  checkNumber('startColumn', startColumn);\n  checkNumber('endColumn', endColumn);\n  if (\n    startRow > endRow ||\n    startColumn > endColumn ||\n    startRow < 0 ||\n    startRow >= matrix.rows ||\n    endRow < 0 ||\n    endRow >= matrix.rows ||\n    startColumn < 0 ||\n    startColumn >= matrix.columns ||\n    endColumn < 0 ||\n    endColumn >= matrix.columns\n  ) {\n    throw new RangeError('Submatrix indices are out of range');\n  }\n}\n\nexport function newArray(length, value = 0) {\n  let array = [];\n  for (let i = 0; i < length; i++) {\n    array.push(value);\n  }\n  return array;\n}\n\nfunction checkNumber(name, value) {\n  if (typeof value !== 'number') {\n    throw new TypeError(`${name} must be a number`);\n  }\n}\n\nexport function checkNonEmpty(matrix) {\n  if (matrix.isEmpty()) {\n    throw new Error('Empty matrix has no elements to index');\n  }\n}\n","import { AbstractMatrix } from '../matrix';\n\nexport default class BaseView extends AbstractMatrix {\n  constructor(matrix, rows, columns) {\n    super();\n    this.matrix = matrix;\n    this.rows = rows;\n    this.columns = columns;\n  }\n}\n","import { checkColumnIndex } from '../util';\n\nimport BaseView from './base';\n\nexport default class MatrixColumnView extends BaseView {\n  constructor(matrix, column) {\n    checkColumnIndex(matrix, column);\n    super(matrix, matrix.rows, 1);\n    this.column = column;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(rowIndex, this.column, value);\n    return this;\n  }\n\n  get(rowIndex) {\n    return this.matrix.get(rowIndex, this.column);\n  }\n}\n","import { checkColumnIndices } from '../util';\n\nimport BaseView from './base';\n\nexport default class MatrixColumnSelectionView extends BaseView {\n  constructor(matrix, columnIndices) {\n    columnIndices = checkColumnIndices(matrix, columnIndices);\n    super(matrix, matrix.rows, columnIndices.length);\n    this.columnIndices = columnIndices;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);\n  }\n}\n","import BaseView from './base';\n\nexport default class MatrixFlipColumnView extends BaseView {\n  constructor(matrix) {\n    super(matrix, matrix.rows, matrix.columns);\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(rowIndex, this.columns - columnIndex - 1);\n  }\n}\n","import BaseView from './base';\n\nexport default class MatrixFlipRowView extends BaseView {\n  constructor(matrix) {\n    super(matrix, matrix.rows, matrix.columns);\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(this.rows - rowIndex - 1, columnIndex);\n  }\n}\n","export { default as MatrixColumnView } from './column';\nexport { default as MatrixColumnSelectionView } from './columnSelection';\nexport { default as MatrixFlipColumnView } from './flipColumn';\nexport { default as MatrixFlipRowView } from './flipRow';\nexport { default as MatrixRowView } from './row';\nexport { default as MatrixRowSelectionView } from './rowSelection';\nexport { default as MatrixSelectionView } from './selection';\nexport { default as MatrixSubView } from './sub';\nexport { default as MatrixTransposeView } from './transpose';\n","import { checkRowIndex } from '../util';\n\nimport BaseView from './base';\n\nexport default class MatrixRowView extends BaseView {\n  constructor(matrix, row) {\n    checkRowIndex(matrix, row);\n    super(matrix, 1, matrix.columns);\n    this.row = row;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(this.row, columnIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(this.row, columnIndex);\n  }\n}\n","import { checkRowIndices } from '../util';\n\nimport BaseView from './base';\n\nexport default class MatrixRowSelectionView extends BaseView {\n  constructor(matrix, rowIndices) {\n    rowIndices = checkRowIndices(matrix, rowIndices);\n    super(matrix, rowIndices.length, matrix.columns);\n    this.rowIndices = rowIndices;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(this.rowIndices[rowIndex], columnIndex);\n  }\n}\n","import { checkIndices } from '../util';\n\nimport BaseView from './base';\n\nexport default class MatrixSelectionView extends BaseView {\n  constructor(matrix, rowIndices, columnIndices) {\n    let indices = checkIndices(matrix, rowIndices, columnIndices);\n    super(matrix, indices.row.length, indices.column.length);\n    this.rowIndices = indices.row;\n    this.columnIndices = indices.column;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(\n      this.rowIndices[rowIndex],\n      this.columnIndices[columnIndex],\n      value,\n    );\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(\n      this.rowIndices[rowIndex],\n      this.columnIndices[columnIndex],\n    );\n  }\n}\n","import { checkRange } from '../util';\n\nimport BaseView from './base';\n\nexport default class MatrixSubView extends BaseView {\n  constructor(matrix, startRow, endRow, startColumn, endColumn) {\n    checkRange(matrix, startRow, endRow, startColumn, endColumn);\n    super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);\n    this.startRow = startRow;\n    this.startColumn = startColumn;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(\n      this.startRow + rowIndex,\n      this.startColumn + columnIndex,\n      value,\n    );\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(\n      this.startRow + rowIndex,\n      this.startColumn + columnIndex,\n    );\n  }\n}\n","import BaseView from './base';\n\nexport default class MatrixTransposeView extends BaseView {\n  constructor(matrix) {\n    super(matrix, matrix.columns, matrix.rows);\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(columnIndex, rowIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(columnIndex, rowIndex);\n  }\n}\n","import { AbstractMatrix } from '../matrix';\n\nexport default class WrapperMatrix1D extends AbstractMatrix {\n  constructor(data, options = {}) {\n    const { rows = 1 } = options;\n\n    if (data.length % rows !== 0) {\n      throw new Error('the data length is not divisible by the number of rows');\n    }\n    super();\n    this.rows = rows;\n    this.columns = data.length / rows;\n    this.data = data;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    let index = this._calculateIndex(rowIndex, columnIndex);\n    this.data[index] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    let index = this._calculateIndex(rowIndex, columnIndex);\n    return this.data[index];\n  }\n\n  _calculateIndex(row, column) {\n    return row * this.columns + column;\n  }\n}\n","import { AbstractMatrix } from '../matrix';\n\nexport default class WrapperMatrix2D extends AbstractMatrix {\n  constructor(data) {\n    super();\n    this.data = data;\n    this.rows = data.length;\n    this.columns = data[0].length;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n}\n","import WrapperMatrix1D from './WrapperMatrix1D';\nimport WrapperMatrix2D from './WrapperMatrix2D';\n\nexport function wrap(array, options) {\n  if (Array.isArray(array)) {\n    if (array[0] && Array.isArray(array[0])) {\n      return new WrapperMatrix2D(array);\n    } else {\n      return new WrapperMatrix1D(array, options);\n    }\n  } else {\n    throw new Error('the argument is not an array');\n  }\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.smallestFlagged = exports.deheapSort = exports.buildCandidates = exports.uncheckedHeapPush = exports.heapPush = exports.rejectionSample = exports.makeHeap = void 0;\r\nconst utils = require(\"./utils\");\r\n/**\r\n *  Constructor for the heap objects. The heaps are used\r\n * for approximate nearest neighbor search, maintaining a list of potential\r\n * neighbors sorted by their distance. We also flag if potential neighbors\r\n * are newly added to the list or not. Internally this is stored as\r\n * a single array; the first axis determines whether we are looking at the\r\n * array of candidate indices, the array of distances, or the flag array for\r\n * whether elements are new or not. Each of these arrays are of shape\r\n * (``nPoints``, ``size``)\r\n */\r\nfunction makeHeap(nPoints, size) {\r\n    const makeArrays = (fillValue) => {\r\n        return utils.empty(nPoints).map(() => {\r\n            return utils.filled(size, fillValue);\r\n        });\r\n    };\r\n    const heap = [];\r\n    heap.push(makeArrays(-1));\r\n    heap.push(makeArrays(Infinity));\r\n    heap.push(makeArrays(0));\r\n    return heap;\r\n}\r\nexports.makeHeap = makeHeap;\r\n/**\r\n * Generate n_samples many integers from 0 to pool_size such that no\r\n * integer is selected twice. The duplication constraint is achieved via\r\n * rejection sampling.\r\n */\r\nfunction rejectionSample(nSamples, poolSize, random) {\r\n    const result = utils.zeros(nSamples);\r\n    for (let i = 0; i < nSamples; i++) {\r\n        let rejectSample = true;\r\n        let j = 0;\r\n        while (rejectSample) {\r\n            j = utils.tauRandInt(poolSize, random);\r\n            let broken = false;\r\n            for (let k = 0; k < i; k++) {\r\n                if (j === result[k]) {\r\n                    broken = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!broken)\r\n                rejectSample = false;\r\n        }\r\n        result[i] = j;\r\n    }\r\n    return result;\r\n}\r\nexports.rejectionSample = rejectionSample;\r\n/**\r\n * Push a new element onto the heap. The heap stores potential neighbors\r\n * for each data point. The ``row`` parameter determines which data point we\r\n * are addressing, the ``weight`` determines the distance (for heap sorting),\r\n * the ``index`` is the element to add, and the flag determines whether this\r\n * is to be considered a new addition.\r\n */\r\nfunction heapPush(heap, row, weight, index, flag) {\r\n    row = Math.floor(row);\r\n    const indices = heap[0][row];\r\n    const weights = heap[1][row];\r\n    const isNew = heap[2][row];\r\n    if (weight >= weights[0]) {\r\n        return 0;\r\n    }\r\n    // Break if we already have this element.\r\n    for (let i = 0; i < indices.length; i++) {\r\n        if (index === indices[i]) {\r\n            return 0;\r\n        }\r\n    }\r\n    return uncheckedHeapPush(heap, row, weight, index, flag);\r\n}\r\nexports.heapPush = heapPush;\r\n/**\r\n * Push a new element onto the heap. The heap stores potential neighbors\r\n * for each data point. The ``row`` parameter determines which data point we\r\n * are addressing, the ``weight`` determines the distance (for heap sorting),\r\n * the ``index`` is the element to add, and the flag determines whether this\r\n * is to be considered a new addition.\r\n */\r\nfunction uncheckedHeapPush(heap, row, weight, index, flag) {\r\n    const indices = heap[0][row];\r\n    const weights = heap[1][row];\r\n    const isNew = heap[2][row];\r\n    if (weight >= weights[0]) {\r\n        return 0;\r\n    }\r\n    // Insert val at position zero\r\n    weights[0] = weight;\r\n    indices[0] = index;\r\n    isNew[0] = flag;\r\n    // Descend the heap, swapping values until the max heap criterion is met\r\n    let i = 0;\r\n    let iSwap = 0;\r\n    while (true) {\r\n        const ic1 = 2 * i + 1;\r\n        const ic2 = ic1 + 1;\r\n        const heapShape2 = heap[0][0].length;\r\n        if (ic1 >= heapShape2) {\r\n            break;\r\n        }\r\n        else if (ic2 >= heapShape2) {\r\n            if (weights[ic1] > weight) {\r\n                iSwap = ic1;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        else if (weights[ic1] >= weights[ic2]) {\r\n            if (weight < weights[ic1]) {\r\n                iSwap = ic1;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            if (weight < weights[ic2]) {\r\n                iSwap = ic2;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        weights[i] = weights[iSwap];\r\n        indices[i] = indices[iSwap];\r\n        isNew[i] = isNew[iSwap];\r\n        i = iSwap;\r\n    }\r\n    weights[i] = weight;\r\n    indices[i] = index;\r\n    isNew[i] = flag;\r\n    return 1;\r\n}\r\nexports.uncheckedHeapPush = uncheckedHeapPush;\r\n/**\r\n * Build a heap of candidate neighbors for nearest neighbor descent. For\r\n * each vertex the candidate neighbors are any current neighbors, and any\r\n * vertices that have the vertex as one of their nearest neighbors.\r\n */\r\nfunction buildCandidates(currentGraph, nVertices, nNeighbors, maxCandidates, random) {\r\n    const candidateNeighbors = makeHeap(nVertices, maxCandidates);\r\n    for (let i = 0; i < nVertices; i++) {\r\n        for (let j = 0; j < nNeighbors; j++) {\r\n            if (currentGraph[0][i][j] < 0) {\r\n                continue;\r\n            }\r\n            const idx = currentGraph[0][i][j];\r\n            const isn = currentGraph[2][i][j];\r\n            const d = utils.tauRand(random);\r\n            heapPush(candidateNeighbors, i, d, idx, isn);\r\n            heapPush(candidateNeighbors, idx, d, i, isn);\r\n            currentGraph[2][i][j] = 0;\r\n        }\r\n    }\r\n    return candidateNeighbors;\r\n}\r\nexports.buildCandidates = buildCandidates;\r\n/**\r\n * Given an array of heaps (of indices and weights), unpack the heap\r\n * out to give and array of sorted lists of indices and weights by increasing\r\n * weight. This is effectively just the second half of heap sort (the first\r\n * half not being required since we already have the data in a heap).\r\n */\r\nfunction deheapSort(heap) {\r\n    const indices = heap[0];\r\n    const weights = heap[1];\r\n    for (let i = 0; i < indices.length; i++) {\r\n        const indHeap = indices[i];\r\n        const distHeap = weights[i];\r\n        for (let j = 0; j < indHeap.length - 1; j++) {\r\n            const indHeapIndex = indHeap.length - j - 1;\r\n            const distHeapIndex = distHeap.length - j - 1;\r\n            const temp1 = indHeap[0];\r\n            indHeap[0] = indHeap[indHeapIndex];\r\n            indHeap[indHeapIndex] = temp1;\r\n            const temp2 = distHeap[0];\r\n            distHeap[0] = distHeap[distHeapIndex];\r\n            distHeap[distHeapIndex] = temp2;\r\n            siftDown(distHeap, indHeap, distHeapIndex, 0);\r\n        }\r\n    }\r\n    return { indices, weights };\r\n}\r\nexports.deheapSort = deheapSort;\r\n/**\r\n * Restore the heap property for a heap with an out of place element\r\n * at position ``elt``. This works with a heap pair where heap1 carries\r\n * the weights and heap2 holds the corresponding elements.\r\n */\r\nfunction siftDown(heap1, heap2, ceiling, elt) {\r\n    while (elt * 2 + 1 < ceiling) {\r\n        const leftChild = elt * 2 + 1;\r\n        const rightChild = leftChild + 1;\r\n        let swap = elt;\r\n        if (heap1[swap] < heap1[leftChild]) {\r\n            swap = leftChild;\r\n        }\r\n        if (rightChild < ceiling && heap1[swap] < heap1[rightChild]) {\r\n            swap = rightChild;\r\n        }\r\n        if (swap === elt) {\r\n            break;\r\n        }\r\n        else {\r\n            const temp1 = heap1[elt];\r\n            heap1[elt] = heap1[swap];\r\n            heap1[swap] = temp1;\r\n            const temp2 = heap2[elt];\r\n            heap2[elt] = heap2[swap];\r\n            heap2[swap] = temp2;\r\n            elt = swap;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Search the heap for the smallest element that is still flagged.\r\n */\r\nfunction smallestFlagged(heap, row) {\r\n    const ind = heap[0][row];\r\n    const dist = heap[1][row];\r\n    const flag = heap[2][row];\r\n    let minDist = Infinity;\r\n    let resultIndex = -1;\r\n    for (let i = 0; i > ind.length; i++) {\r\n        if (flag[i] === 1 && dist[i] < minDist) {\r\n            minDist = dist[i];\r\n            resultIndex = i;\r\n        }\r\n    }\r\n    if (resultIndex >= 0) {\r\n        flag[resultIndex] = 0;\r\n        return Math.floor(ind[resultIndex]);\r\n    }\r\n    else {\r\n        return -1;\r\n    }\r\n}\r\nexports.smallestFlagged = smallestFlagged;\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar umap_1 = require(\"./umap\");\r\nObject.defineProperty(exports, \"UMAP\", { enumerable: true, get: function () { return umap_1.UMAP; } });\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getCSR = exports.normalize = exports.eliminateZeros = exports.multiplyScalar = exports.maximum = exports.subtract = exports.add = exports.pairwiseMultiply = exports.identity = exports.transpose = exports.SparseMatrix = void 0;\r\nconst utils = require(\"./utils\");\r\n/**\r\n * Internal 2-dimensional sparse matrix class\r\n */\r\nclass SparseMatrix {\r\n    constructor(rows, cols, values, dims) {\r\n        this.entries = new Map();\r\n        this.nRows = 0;\r\n        this.nCols = 0;\r\n        if (rows.length !== cols.length || rows.length !== values.length) {\r\n            throw new Error('rows, cols and values arrays must all have the same length');\r\n        }\r\n        // TODO: Assert that dims are legit.\r\n        this.nRows = dims[0];\r\n        this.nCols = dims[1];\r\n        for (let i = 0; i < values.length; i++) {\r\n            const row = rows[i];\r\n            const col = cols[i];\r\n            this.checkDims(row, col);\r\n            const key = this.makeKey(row, col);\r\n            this.entries.set(key, { value: values[i], row, col });\r\n        }\r\n    }\r\n    makeKey(row, col) {\r\n        return `${row}:${col}`;\r\n    }\r\n    checkDims(row, col) {\r\n        const withinBounds = row < this.nRows && col < this.nCols;\r\n        if (!withinBounds) {\r\n            throw new Error('row and/or col specified outside of matrix dimensions');\r\n        }\r\n    }\r\n    set(row, col, value) {\r\n        this.checkDims(row, col);\r\n        const key = this.makeKey(row, col);\r\n        if (!this.entries.has(key)) {\r\n            this.entries.set(key, { value, row, col });\r\n        }\r\n        else {\r\n            this.entries.get(key).value = value;\r\n        }\r\n    }\r\n    get(row, col, defaultValue = 0) {\r\n        this.checkDims(row, col);\r\n        const key = this.makeKey(row, col);\r\n        if (this.entries.has(key)) {\r\n            return this.entries.get(key).value;\r\n        }\r\n        else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n    getAll(ordered = true) {\r\n        const rowColValues = [];\r\n        this.entries.forEach(value => {\r\n            rowColValues.push(value);\r\n        });\r\n        if (ordered) {\r\n            // Ordering the result isn't required for processing but it does make it easier to write tests\r\n            rowColValues.sort((a, b) => {\r\n                if (a.row === b.row) {\r\n                    return a.col - b.col;\r\n                }\r\n                else {\r\n                    return a.row - b.row;\r\n                }\r\n            });\r\n        }\r\n        return rowColValues;\r\n    }\r\n    getDims() {\r\n        return [this.nRows, this.nCols];\r\n    }\r\n    getRows() {\r\n        return Array.from(this.entries, ([key, value]) => value.row);\r\n    }\r\n    getCols() {\r\n        return Array.from(this.entries, ([key, value]) => value.col);\r\n    }\r\n    getValues() {\r\n        return Array.from(this.entries, ([key, value]) => value.value);\r\n    }\r\n    forEach(fn) {\r\n        this.entries.forEach(value => fn(value.value, value.row, value.col));\r\n    }\r\n    map(fn) {\r\n        let vals = [];\r\n        this.entries.forEach(value => {\r\n            vals.push(fn(value.value, value.row, value.col));\r\n        });\r\n        const dims = [this.nRows, this.nCols];\r\n        return new SparseMatrix(this.getRows(), this.getCols(), vals, dims);\r\n    }\r\n    toArray() {\r\n        const rows = utils.empty(this.nRows);\r\n        const output = rows.map(() => {\r\n            return utils.zeros(this.nCols);\r\n        });\r\n        this.entries.forEach(value => {\r\n            output[value.row][value.col] = value.value;\r\n        });\r\n        return output;\r\n    }\r\n}\r\nexports.SparseMatrix = SparseMatrix;\r\n/**\r\n * Transpose a sparse matrix\r\n */\r\nfunction transpose(matrix) {\r\n    const cols = [];\r\n    const rows = [];\r\n    const vals = [];\r\n    matrix.forEach((value, row, col) => {\r\n        cols.push(row);\r\n        rows.push(col);\r\n        vals.push(value);\r\n    });\r\n    const dims = [matrix.nCols, matrix.nRows];\r\n    return new SparseMatrix(rows, cols, vals, dims);\r\n}\r\nexports.transpose = transpose;\r\n/**\r\n * Construct a sparse identity matrix\r\n */\r\nfunction identity(size) {\r\n    const [rows] = size;\r\n    const matrix = new SparseMatrix([], [], [], size);\r\n    for (let i = 0; i < rows; i++) {\r\n        matrix.set(i, i, 1);\r\n    }\r\n    return matrix;\r\n}\r\nexports.identity = identity;\r\n/**\r\n * Element-wise multiplication of two matrices\r\n */\r\nfunction pairwiseMultiply(a, b) {\r\n    return elementWise(a, b, (x, y) => x * y);\r\n}\r\nexports.pairwiseMultiply = pairwiseMultiply;\r\n/**\r\n * Element-wise addition of two matrices\r\n */\r\nfunction add(a, b) {\r\n    return elementWise(a, b, (x, y) => x + y);\r\n}\r\nexports.add = add;\r\n/**\r\n * Element-wise subtraction of two matrices\r\n */\r\nfunction subtract(a, b) {\r\n    return elementWise(a, b, (x, y) => x - y);\r\n}\r\nexports.subtract = subtract;\r\n/**\r\n * Element-wise maximum of two matrices\r\n */\r\nfunction maximum(a, b) {\r\n    return elementWise(a, b, (x, y) => (x > y ? x : y));\r\n}\r\nexports.maximum = maximum;\r\n/**\r\n * Scalar multiplication of two matrices\r\n */\r\nfunction multiplyScalar(a, scalar) {\r\n    return a.map((value) => {\r\n        return value * scalar;\r\n    });\r\n}\r\nexports.multiplyScalar = multiplyScalar;\r\n/**\r\n * Returns a new matrix with zero entries removed.\r\n */\r\nfunction eliminateZeros(m) {\r\n    const zeroIndices = new Set();\r\n    const values = m.getValues();\r\n    const rows = m.getRows();\r\n    const cols = m.getCols();\r\n    for (let i = 0; i < values.length; i++) {\r\n        if (values[i] === 0) {\r\n            zeroIndices.add(i);\r\n        }\r\n    }\r\n    const removeByZeroIndex = (_, index) => !zeroIndices.has(index);\r\n    const nextValues = values.filter(removeByZeroIndex);\r\n    const nextRows = rows.filter(removeByZeroIndex);\r\n    const nextCols = cols.filter(removeByZeroIndex);\r\n    return new SparseMatrix(nextRows, nextCols, nextValues, m.getDims());\r\n}\r\nexports.eliminateZeros = eliminateZeros;\r\n/**\r\n * Normalization of a sparse matrix.\r\n */\r\nfunction normalize(m, normType = \"l2\" /* l2 */) {\r\n    const normFn = normFns[normType];\r\n    const colsByRow = new Map();\r\n    m.forEach((_, row, col) => {\r\n        const cols = colsByRow.get(row) || [];\r\n        cols.push(col);\r\n        colsByRow.set(row, cols);\r\n    });\r\n    const nextMatrix = new SparseMatrix([], [], [], m.getDims());\r\n    for (let row of colsByRow.keys()) {\r\n        const cols = colsByRow.get(row).sort();\r\n        const vals = cols.map(col => m.get(row, col));\r\n        const norm = normFn(vals);\r\n        for (let i = 0; i < norm.length; i++) {\r\n            nextMatrix.set(row, cols[i], norm[i]);\r\n        }\r\n    }\r\n    return nextMatrix;\r\n}\r\nexports.normalize = normalize;\r\nconst normFns = {\r\n    [\"max\" /* max */]: (xs) => {\r\n        let max = -Infinity;\r\n        for (let i = 0; i < xs.length; i++) {\r\n            max = xs[i] > max ? xs[i] : max;\r\n        }\r\n        return xs.map(x => x / max);\r\n    },\r\n    [\"l1\" /* l1 */]: (xs) => {\r\n        let sum = 0;\r\n        for (let i = 0; i < xs.length; i++) {\r\n            sum += xs[i];\r\n        }\r\n        return xs.map(x => x / sum);\r\n    },\r\n    [\"l2\" /* l2 */]: (xs) => {\r\n        let sum = 0;\r\n        for (let i = 0; i < xs.length; i++) {\r\n            sum += xs[i] ** 2;\r\n        }\r\n        return xs.map(x => Math.sqrt(x ** 2 / sum));\r\n    },\r\n};\r\n/**\r\n * Helper function for element-wise operations.\r\n */\r\nfunction elementWise(a, b, op) {\r\n    const visited = new Set();\r\n    const rows = [];\r\n    const cols = [];\r\n    const vals = [];\r\n    const operate = (row, col) => {\r\n        rows.push(row);\r\n        cols.push(col);\r\n        const nextValue = op(a.get(row, col), b.get(row, col));\r\n        vals.push(nextValue);\r\n    };\r\n    const valuesA = a.getValues();\r\n    const rowsA = a.getRows();\r\n    const colsA = a.getCols();\r\n    for (let i = 0; i < valuesA.length; i++) {\r\n        const row = rowsA[i];\r\n        const col = colsA[i];\r\n        const key = `${row}:${col}`;\r\n        visited.add(key);\r\n        operate(row, col);\r\n    }\r\n    const valuesB = b.getValues();\r\n    const rowsB = b.getRows();\r\n    const colsB = b.getCols();\r\n    for (let i = 0; i < valuesB.length; i++) {\r\n        const row = rowsB[i];\r\n        const col = colsB[i];\r\n        const key = `${row}:${col}`;\r\n        if (visited.has(key))\r\n            continue;\r\n        operate(row, col);\r\n    }\r\n    const dims = [a.nRows, a.nCols];\r\n    return new SparseMatrix(rows, cols, vals, dims);\r\n}\r\n/**\r\n * Helper function for getting data, indices, and inptr arrays from a sparse\r\n * matrix to follow csr matrix conventions. Super inefficient (and kind of\r\n * defeats the purpose of this convention) but a lot of the ported python tree\r\n * search logic depends on this data format.\r\n */\r\nfunction getCSR(x) {\r\n    const entries = [];\r\n    x.forEach((value, row, col) => {\r\n        entries.push({ value, row, col });\r\n    });\r\n    entries.sort((a, b) => {\r\n        if (a.row === b.row) {\r\n            return a.col - b.col;\r\n        }\r\n        else {\r\n            return a.row - b.row;\r\n        }\r\n    });\r\n    const indices = [];\r\n    const values = [];\r\n    const indptr = [];\r\n    let currentRow = -1;\r\n    for (let i = 0; i < entries.length; i++) {\r\n        const { row, col, value } = entries[i];\r\n        if (row !== currentRow) {\r\n            currentRow = row;\r\n            indptr.push(i);\r\n        }\r\n        indices.push(col);\r\n        values.push(value);\r\n    }\r\n    return { indices, values, indptr };\r\n}\r\nexports.getCSR = getCSR;\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.initializeSearch = exports.makeInitializedNNSearch = exports.makeInitializations = exports.makeNNDescent = void 0;\r\n/**\r\n * This is a JavaScript reimplementation of UMAP (original license below), from\r\n * the python implementation found at https://github.com/lmcinnes/umap.\r\n *\r\n * @author andycoenen@google.com (Andy Coenen)\r\n */\r\n/**\r\n * @license\r\n * BSD 3-Clause License\r\n *\r\n * Copyright (c) 2017, Leland McInnes\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n *\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * * Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from\r\n *   this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nconst heap = require(\"./heap\");\r\nconst matrix = require(\"./matrix\");\r\nconst tree = require(\"./tree\");\r\nconst utils = require(\"./utils\");\r\n/**\r\n * Create a version of nearest neighbor descent.\r\n */\r\nfunction makeNNDescent(distanceFn, random) {\r\n    return function nNDescent(data, leafArray, nNeighbors, nIters = 10, maxCandidates = 50, delta = 0.001, rho = 0.5, rpTreeInit = true) {\r\n        const nVertices = data.length;\r\n        const currentGraph = heap.makeHeap(data.length, nNeighbors);\r\n        for (let i = 0; i < data.length; i++) {\r\n            const indices = heap.rejectionSample(nNeighbors, data.length, random);\r\n            for (let j = 0; j < indices.length; j++) {\r\n                const d = distanceFn(data[i], data[indices[j]]);\r\n                heap.heapPush(currentGraph, i, d, indices[j], 1);\r\n                heap.heapPush(currentGraph, indices[j], d, i, 1);\r\n            }\r\n        }\r\n        if (rpTreeInit) {\r\n            for (let n = 0; n < leafArray.length; n++) {\r\n                for (let i = 0; i < leafArray[n].length; i++) {\r\n                    if (leafArray[n][i] < 0) {\r\n                        break;\r\n                    }\r\n                    for (let j = i + 1; j < leafArray[n].length; j++) {\r\n                        if (leafArray[n][j] < 0) {\r\n                            break;\r\n                        }\r\n                        const d = distanceFn(data[leafArray[n][i]], data[leafArray[n][j]]);\r\n                        heap.heapPush(currentGraph, leafArray[n][i], d, leafArray[n][j], 1);\r\n                        heap.heapPush(currentGraph, leafArray[n][j], d, leafArray[n][i], 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (let n = 0; n < nIters; n++) {\r\n            const candidateNeighbors = heap.buildCandidates(currentGraph, nVertices, nNeighbors, maxCandidates, random);\r\n            let c = 0;\r\n            for (let i = 0; i < nVertices; i++) {\r\n                for (let j = 0; j < maxCandidates; j++) {\r\n                    let p = Math.floor(candidateNeighbors[0][i][j]);\r\n                    if (p < 0 || utils.tauRand(random) < rho) {\r\n                        continue;\r\n                    }\r\n                    for (let k = 0; k < maxCandidates; k++) {\r\n                        const q = Math.floor(candidateNeighbors[0][i][k]);\r\n                        const cj = candidateNeighbors[2][i][j];\r\n                        const ck = candidateNeighbors[2][i][k];\r\n                        if (q < 0 || (!cj && !ck)) {\r\n                            continue;\r\n                        }\r\n                        const d = distanceFn(data[p], data[q]);\r\n                        c += heap.heapPush(currentGraph, p, d, q, 1);\r\n                        c += heap.heapPush(currentGraph, q, d, p, 1);\r\n                    }\r\n                }\r\n            }\r\n            if (c <= delta * nNeighbors * data.length) {\r\n                break;\r\n            }\r\n        }\r\n        const sorted = heap.deheapSort(currentGraph);\r\n        return sorted;\r\n    };\r\n}\r\nexports.makeNNDescent = makeNNDescent;\r\nfunction makeInitializations(distanceFn) {\r\n    function initFromRandom(nNeighbors, data, queryPoints, _heap, random) {\r\n        for (let i = 0; i < queryPoints.length; i++) {\r\n            const indices = utils.rejectionSample(nNeighbors, data.length, random);\r\n            for (let j = 0; j < indices.length; j++) {\r\n                if (indices[j] < 0) {\r\n                    continue;\r\n                }\r\n                const d = distanceFn(data[indices[j]], queryPoints[i]);\r\n                heap.heapPush(_heap, i, d, indices[j], 1);\r\n            }\r\n        }\r\n    }\r\n    function initFromTree(_tree, data, queryPoints, _heap, random) {\r\n        for (let i = 0; i < queryPoints.length; i++) {\r\n            const indices = tree.searchFlatTree(queryPoints[i], _tree, random);\r\n            for (let j = 0; j < indices.length; j++) {\r\n                if (indices[j] < 0) {\r\n                    return;\r\n                }\r\n                const d = distanceFn(data[indices[j]], queryPoints[i]);\r\n                heap.heapPush(_heap, i, d, indices[j], 1);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    return { initFromRandom, initFromTree };\r\n}\r\nexports.makeInitializations = makeInitializations;\r\nfunction makeInitializedNNSearch(distanceFn) {\r\n    return function nnSearchFn(data, graph, initialization, queryPoints) {\r\n        const { indices, indptr } = matrix.getCSR(graph);\r\n        for (let i = 0; i < queryPoints.length; i++) {\r\n            const tried = new Set(initialization[0][i]);\r\n            while (true) {\r\n                // Find smallest flagged vertex\r\n                const vertex = heap.smallestFlagged(initialization, i);\r\n                if (vertex === -1) {\r\n                    break;\r\n                }\r\n                const candidates = indices.slice(indptr[vertex], indptr[vertex + 1]);\r\n                for (const candidate of candidates) {\r\n                    if (candidate === vertex ||\r\n                        candidate === -1 ||\r\n                        tried.has(candidate)) {\r\n                        continue;\r\n                    }\r\n                    const d = distanceFn(data[candidate], queryPoints[i]);\r\n                    heap.uncheckedHeapPush(initialization, i, d, candidate, 1);\r\n                    tried.add(candidate);\r\n                }\r\n            }\r\n        }\r\n        return initialization;\r\n    };\r\n}\r\nexports.makeInitializedNNSearch = makeInitializedNNSearch;\r\nfunction initializeSearch(forest, data, queryPoints, nNeighbors, initFromRandom, initFromTree, random) {\r\n    const results = heap.makeHeap(queryPoints.length, nNeighbors);\r\n    initFromRandom(nNeighbors, data, queryPoints, results, random);\r\n    if (forest) {\r\n        for (let tree of forest) {\r\n            initFromTree(tree, data, queryPoints, results, random);\r\n        }\r\n    }\r\n    return results;\r\n}\r\nexports.initializeSearch = initializeSearch;\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.searchFlatTree = exports.makeLeafArray = exports.makeForest = exports.FlatTree = void 0;\r\n/**\r\n * This is a JavaScript reimplementation of UMAP (original license below), from\r\n * the python implementation found at https://github.com/lmcinnes/umap.\r\n *\r\n * @author andycoenen@google.com (Andy Coenen)\r\n */\r\n/**\r\n * @license\r\n * BSD 3-Clause License\r\n *\r\n * Copyright (c) 2017, Leland McInnes\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n *\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * * Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from\r\n *   this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nconst utils = require(\"./utils\");\r\nclass FlatTree {\r\n    constructor(hyperplanes, offsets, children, indices) {\r\n        this.hyperplanes = hyperplanes;\r\n        this.offsets = offsets;\r\n        this.children = children;\r\n        this.indices = indices;\r\n    }\r\n}\r\nexports.FlatTree = FlatTree;\r\n/**\r\n * Build a random projection forest with ``nTrees``.\r\n */\r\nfunction makeForest(data, nNeighbors, nTrees, random) {\r\n    const leafSize = Math.max(10, nNeighbors);\r\n    const trees = utils\r\n        .range(nTrees)\r\n        .map((_, i) => makeTree(data, leafSize, i, random));\r\n    const forest = trees.map(tree => flattenTree(tree, leafSize));\r\n    return forest;\r\n}\r\nexports.makeForest = makeForest;\r\n/**\r\n * Construct a random projection tree based on ``data`` with leaves\r\n * of size at most ``leafSize``\r\n */\r\nfunction makeTree(data, leafSize = 30, n, random) {\r\n    const indices = utils.range(data.length);\r\n    const tree = makeEuclideanTree(data, indices, leafSize, n, random);\r\n    return tree;\r\n}\r\nfunction makeEuclideanTree(data, indices, leafSize = 30, q, random) {\r\n    if (indices.length > leafSize) {\r\n        const splitResults = euclideanRandomProjectionSplit(data, indices, random);\r\n        const { indicesLeft, indicesRight, hyperplane, offset } = splitResults;\r\n        const leftChild = makeEuclideanTree(data, indicesLeft, leafSize, q + 1, random);\r\n        const rightChild = makeEuclideanTree(data, indicesRight, leafSize, q + 1, random);\r\n        const node = { leftChild, rightChild, isLeaf: false, hyperplane, offset };\r\n        return node;\r\n    }\r\n    else {\r\n        const node = { indices, isLeaf: true };\r\n        return node;\r\n    }\r\n}\r\n/**\r\n * Given a set of ``indices`` for data points from ``data``, create\r\n * a random hyperplane to split the data, returning two arrays indices\r\n * that fall on either side of the hyperplane. This is the basis for a\r\n * random projection tree, which simply uses this splitting recursively.\r\n * This particular split uses euclidean distance to determine the hyperplane\r\n * and which side each data sample falls on.\r\n */\r\nfunction euclideanRandomProjectionSplit(data, indices, random) {\r\n    const dim = data[0].length;\r\n    // Select two random points, set the hyperplane between them\r\n    let leftIndex = utils.tauRandInt(indices.length, random);\r\n    let rightIndex = utils.tauRandInt(indices.length, random);\r\n    rightIndex += leftIndex === rightIndex ? 1 : 0;\r\n    rightIndex = rightIndex % indices.length;\r\n    const left = indices[leftIndex];\r\n    const right = indices[rightIndex];\r\n    // Compute the normal vector to the hyperplane (the vector between the two\r\n    // points) and the offset from the origin\r\n    let hyperplaneOffset = 0;\r\n    const hyperplaneVector = utils.zeros(dim);\r\n    for (let i = 0; i < hyperplaneVector.length; i++) {\r\n        hyperplaneVector[i] = data[left][i] - data[right][i];\r\n        hyperplaneOffset -=\r\n            (hyperplaneVector[i] * (data[left][i] + data[right][i])) / 2.0;\r\n    }\r\n    // For each point compute the margin (project into normal vector)\r\n    // If we are on lower side of the hyperplane put in one pile, otherwise\r\n    // put it in the other pile (if we hit hyperplane on the nose, flip a coin)\r\n    let nLeft = 0;\r\n    let nRight = 0;\r\n    const side = utils.zeros(indices.length);\r\n    for (let i = 0; i < indices.length; i++) {\r\n        let margin = hyperplaneOffset;\r\n        for (let d = 0; d < dim; d++) {\r\n            margin += hyperplaneVector[d] * data[indices[i]][d];\r\n        }\r\n        if (margin === 0) {\r\n            side[i] = utils.tauRandInt(2, random);\r\n            if (side[i] === 0) {\r\n                nLeft += 1;\r\n            }\r\n            else {\r\n                nRight += 1;\r\n            }\r\n        }\r\n        else if (margin > 0) {\r\n            side[i] = 0;\r\n            nLeft += 1;\r\n        }\r\n        else {\r\n            side[i] = 1;\r\n            nRight += 1;\r\n        }\r\n    }\r\n    // Now that we have the counts, allocate arrays\r\n    const indicesLeft = utils.zeros(nLeft);\r\n    const indicesRight = utils.zeros(nRight);\r\n    // Populate the arrays with indices according to which side they fell on\r\n    nLeft = 0;\r\n    nRight = 0;\r\n    for (let i in utils.range(side.length)) {\r\n        if (side[i] === 0) {\r\n            indicesLeft[nLeft] = indices[i];\r\n            nLeft += 1;\r\n        }\r\n        else {\r\n            indicesRight[nRight] = indices[i];\r\n            nRight += 1;\r\n        }\r\n    }\r\n    return {\r\n        indicesLeft,\r\n        indicesRight,\r\n        hyperplane: hyperplaneVector,\r\n        offset: hyperplaneOffset,\r\n    };\r\n}\r\nfunction flattenTree(tree, leafSize) {\r\n    const nNodes = numNodes(tree);\r\n    const nLeaves = numLeaves(tree);\r\n    // TODO: Verify that sparse code is not relevant...\r\n    const hyperplanes = utils\r\n        .range(nNodes)\r\n        .map(() => utils.zeros(tree.hyperplane ? tree.hyperplane.length : 0));\r\n    const offsets = utils.zeros(nNodes);\r\n    const children = utils.range(nNodes).map(() => [-1, -1]);\r\n    const indices = utils\r\n        .range(nLeaves)\r\n        .map(() => utils.range(leafSize).map(() => -1));\r\n    recursiveFlatten(tree, hyperplanes, offsets, children, indices, 0, 0);\r\n    return new FlatTree(hyperplanes, offsets, children, indices);\r\n}\r\nfunction recursiveFlatten(tree, hyperplanes, offsets, children, indices, nodeNum, leafNum) {\r\n    if (tree.isLeaf) {\r\n        children[nodeNum][0] = -leafNum;\r\n        // TODO: Triple check this operation corresponds to\r\n        // indices[leafNum : tree.indices.shape[0]] = tree.indices\r\n        indices[leafNum].splice(0, tree.indices.length, ...tree.indices);\r\n        leafNum += 1;\r\n        return { nodeNum, leafNum };\r\n    }\r\n    else {\r\n        hyperplanes[nodeNum] = tree.hyperplane;\r\n        offsets[nodeNum] = tree.offset;\r\n        children[nodeNum][0] = nodeNum + 1;\r\n        const oldNodeNum = nodeNum;\r\n        let res = recursiveFlatten(tree.leftChild, hyperplanes, offsets, children, indices, nodeNum + 1, leafNum);\r\n        nodeNum = res.nodeNum;\r\n        leafNum = res.leafNum;\r\n        children[oldNodeNum][1] = nodeNum + 1;\r\n        res = recursiveFlatten(tree.rightChild, hyperplanes, offsets, children, indices, nodeNum + 1, leafNum);\r\n        return { nodeNum: res.nodeNum, leafNum: res.leafNum };\r\n    }\r\n}\r\nfunction numNodes(tree) {\r\n    if (tree.isLeaf) {\r\n        return 1;\r\n    }\r\n    else {\r\n        return 1 + numNodes(tree.leftChild) + numNodes(tree.rightChild);\r\n    }\r\n}\r\nfunction numLeaves(tree) {\r\n    if (tree.isLeaf) {\r\n        return 1;\r\n    }\r\n    else {\r\n        return numLeaves(tree.leftChild) + numLeaves(tree.rightChild);\r\n    }\r\n}\r\n/**\r\n * Generate an array of sets of candidate nearest neighbors by\r\n * constructing a random projection forest and taking the leaves of all the\r\n * trees. Any given tree has leaves that are a set of potential nearest\r\n * neighbors. Given enough trees the set of all such leaves gives a good\r\n * likelihood of getting a good set of nearest neighbors in composite. Since\r\n * such a random projection forest is inexpensive to compute, this can be a\r\n * useful means of seeding other nearest neighbor algorithms.\r\n */\r\nfunction makeLeafArray(rpForest) {\r\n    if (rpForest.length > 0) {\r\n        const output = [];\r\n        for (let tree of rpForest) {\r\n            output.push(...tree.indices);\r\n        }\r\n        return output;\r\n    }\r\n    else {\r\n        return [[-1]];\r\n    }\r\n}\r\nexports.makeLeafArray = makeLeafArray;\r\n/**\r\n * Selects the side of the tree to search during flat tree search.\r\n */\r\nfunction selectSide(hyperplane, offset, point, random) {\r\n    let margin = offset;\r\n    for (let d = 0; d < point.length; d++) {\r\n        margin += hyperplane[d] * point[d];\r\n    }\r\n    if (margin === 0) {\r\n        const side = utils.tauRandInt(2, random);\r\n        return side;\r\n    }\r\n    else if (margin > 0) {\r\n        return 0;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n}\r\n/**\r\n * Searches a flattened rp-tree for a point.\r\n */\r\nfunction searchFlatTree(point, tree, random) {\r\n    let node = 0;\r\n    while (tree.children[node][0] > 0) {\r\n        const side = selectSide(tree.hyperplanes[node], tree.offsets[node], point, random);\r\n        if (side === 0) {\r\n            node = tree.children[node][0];\r\n        }\r\n        else {\r\n            node = tree.children[node][1];\r\n        }\r\n    }\r\n    const index = -1 * tree.children[node][0];\r\n    return tree.indices[index];\r\n}\r\nexports.searchFlatTree = searchFlatTree;\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.initTransform = exports.resetLocalConnectivity = exports.fastIntersection = exports.findABParams = exports.cosine = exports.euclidean = exports.jaccard = exports.UMAP = void 0;\r\n/**\r\n * This is a JavaScript reimplementation of UMAP (original license below), from\r\n * the python implementation found at https://github.com/lmcinnes/umap.\r\n *\r\n * @author andycoenen@google.com (Andy Coenen)\r\n */\r\n/**\r\n * @license\r\n * BSD 3-Clause License\r\n *\r\n * Copyright (c) 2017, Leland McInnes\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n *\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * * Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from\r\n *   this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nconst heap = require(\"./heap\");\r\nconst matrix = require(\"./matrix\");\r\nconst nnDescent = require(\"./nn_descent\");\r\nconst tree = require(\"./tree\");\r\nconst utils = require(\"./utils\");\r\nconst ml_levenberg_marquardt_1 = require(\"ml-levenberg-marquardt\");\r\nconst SMOOTH_K_TOLERANCE = 1e-5;\r\nconst MIN_K_DIST_SCALE = 1e-3;\r\n/**\r\n * UMAP projection system, based on the python implementation from McInnes, L,\r\n * Healy, J, UMAP: Uniform Manifold Approximation and Projection for Dimension\r\n * Reduction (https://github.com/lmcinnes/umap).\r\n *\r\n * This implementation differs in a few regards:\r\n * a) The initialization of the embedding for optimization is not computed using\r\n *    a spectral method, rather it is initialized randomly. This avoids some\r\n *    computationally intensive matrix eigen computations that aren't easily\r\n *    ported to JavaScript.\r\n * b) A lot of \"extra\" functionality has been omitted from this implementation,\r\n *    most notably a great deal of alternate distance functions.\r\n *\r\n * This implementation provides three methods of reducing dimensionality:\r\n * 1) fit: fit the data synchronously\r\n * 2) fitAsync: fit the data asynchronously, with a callback function provided\r\n *      that is invoked on each optimization step.\r\n * 3) initializeFit / step: manually initialize the algorithm then explictly\r\n *      step through each epoch of the SGD optimization\r\n */\r\nclass UMAP {\r\n    constructor(params = {}) {\r\n        this.learningRate = 1.0;\r\n        this.localConnectivity = 1.0;\r\n        this.minDist = 0.1;\r\n        this.nComponents = 2;\r\n        this.nEpochs = 0;\r\n        this.nNeighbors = 15;\r\n        this.negativeSampleRate = 5;\r\n        this.random = Math.random;\r\n        this.repulsionStrength = 1.0;\r\n        this.setOpMixRatio = 1.0;\r\n        this.spread = 1.0;\r\n        this.transformQueueSize = 4.0;\r\n        // Supervised projection params\r\n        this.targetMetric = \"categorical\" /* categorical */;\r\n        this.targetWeight = 0.5;\r\n        this.targetNNeighbors = this.nNeighbors;\r\n        this.distanceFn = euclidean;\r\n        this.isInitialized = false;\r\n        this.rpForest = [];\r\n        // Projected embedding\r\n        this.embedding = [];\r\n        this.optimizationState = new OptimizationState();\r\n        const setParam = (key) => {\r\n            if (params[key] !== undefined)\r\n                this[key] = params[key];\r\n        };\r\n        setParam('distanceFn');\r\n        setParam('learningRate');\r\n        setParam('localConnectivity');\r\n        setParam('minDist');\r\n        setParam('nComponents');\r\n        setParam('nEpochs');\r\n        setParam('nNeighbors');\r\n        setParam('negativeSampleRate');\r\n        setParam('random');\r\n        setParam('repulsionStrength');\r\n        setParam('setOpMixRatio');\r\n        setParam('spread');\r\n        setParam('transformQueueSize');\r\n    }\r\n    /**\r\n     * Fit the data to a projected embedding space synchronously.\r\n     */\r\n    fit(X, initialEmbedding) {\r\n        this.initializeFit(X, initialEmbedding);\r\n        this.optimizeLayout();\r\n        return this.embedding;\r\n    }\r\n    /**\r\n     * Fit the data to a projected embedding space asynchronously, with a callback\r\n     * function invoked on every epoch of optimization.\r\n     */\r\n    fitAsync(X, initialEmbedding, callback = () => true) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.initializeFit(X, initialEmbedding);\r\n            yield this.optimizeLayoutAsync(callback);\r\n            return this.embedding;\r\n        });\r\n    }\r\n    /**\r\n     * Initializes parameters needed for supervised projection.\r\n     */\r\n    setSupervisedProjection(Y, params = {}) {\r\n        this.Y = Y;\r\n        this.targetMetric = params.targetMetric || this.targetMetric;\r\n        this.targetWeight = params.targetWeight || this.targetWeight;\r\n        this.targetNNeighbors = params.targetNNeighbors || this.targetNNeighbors;\r\n    }\r\n    /**\r\n     * Initializes umap with precomputed KNN indices and distances.\r\n     */\r\n    setPrecomputedKNN(knnIndices, knnDistances) {\r\n        this.knnIndices = knnIndices;\r\n        this.knnDistances = knnDistances;\r\n    }\r\n    /**\r\n     * Initializes fit by computing KNN and a fuzzy simplicial set, as well as\r\n     * initializing the projected embeddings. Sets the optimization state ahead\r\n     * of optimization steps. Returns the number of epochs to be used for the\r\n     * SGD optimization.\r\n     */\r\n    initializeFit(X, initialEmbedding) {\r\n        if (X.length <= this.nNeighbors) {\r\n            throw new Error(`Not enough data points (${X.length}) to create nNeighbors: ${this.nNeighbors}.  Add more data points or adjust the configuration.`);\r\n        }\r\n        // We don't need to reinitialize if we've already initialized for this data.\r\n        if (this.X === X && this.isInitialized) {\r\n            return this.getNEpochs();\r\n        }\r\n        this.X = X;\r\n        if (!this.knnIndices && !this.knnDistances) {\r\n            const knnResults = this.nearestNeighbors(X);\r\n            this.knnIndices = knnResults.knnIndices;\r\n            this.knnDistances = knnResults.knnDistances;\r\n        }\r\n        this.graph = this.fuzzySimplicialSet(X, this.nNeighbors, this.setOpMixRatio);\r\n        // Set up the search graph for subsequent transformation.\r\n        this.makeSearchFns();\r\n        this.searchGraph = this.makeSearchGraph(X);\r\n        // Check if supervised projection, then adjust the graph.\r\n        this.processGraphForSupervisedProjection();\r\n        const { head, tail, epochsPerSample, } = this.initializeSimplicialSetEmbedding(initialEmbedding);\r\n        // Set the optimization routine state\r\n        this.optimizationState.head = head;\r\n        this.optimizationState.tail = tail;\r\n        this.optimizationState.epochsPerSample = epochsPerSample;\r\n        // Now, initialize the optimization steps\r\n        this.initializeOptimization();\r\n        this.prepareForOptimizationLoop();\r\n        this.isInitialized = true;\r\n        return this.getNEpochs();\r\n    }\r\n    makeSearchFns() {\r\n        const { initFromTree, initFromRandom } = nnDescent.makeInitializations(this.distanceFn);\r\n        this.initFromTree = initFromTree;\r\n        this.initFromRandom = initFromRandom;\r\n        this.search = nnDescent.makeInitializedNNSearch(this.distanceFn);\r\n    }\r\n    makeSearchGraph(X) {\r\n        const knnIndices = this.knnIndices;\r\n        const knnDistances = this.knnDistances;\r\n        const dims = [X.length, X.length];\r\n        const searchGraph = new matrix.SparseMatrix([], [], [], dims);\r\n        for (let i = 0; i < knnIndices.length; i++) {\r\n            const knn = knnIndices[i];\r\n            const distances = knnDistances[i];\r\n            for (let j = 0; j < knn.length; j++) {\r\n                const neighbor = knn[j];\r\n                const distance = distances[j];\r\n                if (distance > 0) {\r\n                    searchGraph.set(i, neighbor, distance);\r\n                }\r\n            }\r\n        }\r\n        const transpose = matrix.transpose(searchGraph);\r\n        return matrix.maximum(searchGraph, transpose);\r\n    }\r\n    /**\r\n     * Transforms data to the existing embedding space.\r\n     */\r\n    transform(toTransform) {\r\n        // Use the previous rawData\r\n        const rawData = this.X;\r\n        if (rawData === undefined || rawData.length === 0) {\r\n            throw new Error('No data has been fit.');\r\n        }\r\n        let nNeighbors = Math.floor(this.nNeighbors * this.transformQueueSize);\r\n        nNeighbors = Math.min(rawData.length, nNeighbors);\r\n        const init = nnDescent.initializeSearch(this.rpForest, rawData, toTransform, nNeighbors, this.initFromRandom, this.initFromTree, this.random);\r\n        const result = this.search(rawData, this.searchGraph, init, toTransform);\r\n        let { indices, weights: distances } = heap.deheapSort(result);\r\n        indices = indices.map(x => x.slice(0, this.nNeighbors));\r\n        distances = distances.map(x => x.slice(0, this.nNeighbors));\r\n        const adjustedLocalConnectivity = Math.max(0, this.localConnectivity - 1);\r\n        const { sigmas, rhos } = this.smoothKNNDistance(distances, this.nNeighbors, adjustedLocalConnectivity);\r\n        const { rows, cols, vals } = this.computeMembershipStrengths(indices, distances, sigmas, rhos);\r\n        const size = [toTransform.length, rawData.length];\r\n        let graph = new matrix.SparseMatrix(rows, cols, vals, size);\r\n        // This was a very specially constructed graph with constant degree.\r\n        // That lets us do fancy unpacking by reshaping the csr matrix indices\r\n        // and data. Doing so relies on the constant degree assumption!\r\n        const normed = matrix.normalize(graph, \"l1\" /* l1 */);\r\n        const csrMatrix = matrix.getCSR(normed);\r\n        const nPoints = toTransform.length;\r\n        const eIndices = utils.reshape2d(csrMatrix.indices, nPoints, this.nNeighbors);\r\n        const eWeights = utils.reshape2d(csrMatrix.values, nPoints, this.nNeighbors);\r\n        const embedding = initTransform(eIndices, eWeights, this.embedding);\r\n        const nEpochs = this.nEpochs\r\n            ? this.nEpochs / 3\r\n            : graph.nRows <= 10000\r\n                ? 100\r\n                : 30;\r\n        const graphMax = graph\r\n            .getValues()\r\n            .reduce((max, val) => (val > max ? val : max), 0);\r\n        graph = graph.map(value => (value < graphMax / nEpochs ? 0 : value));\r\n        graph = matrix.eliminateZeros(graph);\r\n        const epochsPerSample = this.makeEpochsPerSample(graph.getValues(), nEpochs);\r\n        const head = graph.getRows();\r\n        const tail = graph.getCols();\r\n        // Initialize optimization slightly differently than the fit method.\r\n        this.assignOptimizationStateParameters({\r\n            headEmbedding: embedding,\r\n            tailEmbedding: this.embedding,\r\n            head,\r\n            tail,\r\n            currentEpoch: 0,\r\n            nEpochs,\r\n            nVertices: graph.getDims()[1],\r\n            epochsPerSample,\r\n        });\r\n        this.prepareForOptimizationLoop();\r\n        return this.optimizeLayout();\r\n    }\r\n    /**\r\n     * Checks if we're using supervised projection, then process the graph\r\n     * accordingly.\r\n     */\r\n    processGraphForSupervisedProjection() {\r\n        const { Y, X } = this;\r\n        if (Y) {\r\n            if (Y.length !== X.length) {\r\n                throw new Error('Length of X and y must be equal');\r\n            }\r\n            if (this.targetMetric === \"categorical\" /* categorical */) {\r\n                const lt = this.targetWeight < 1.0;\r\n                const farDist = lt ? 2.5 * (1.0 / (1.0 - this.targetWeight)) : 1.0e12;\r\n                this.graph = this.categoricalSimplicialSetIntersection(this.graph, Y, farDist);\r\n            }\r\n            // TODO (andycoenen@): add non-categorical supervised embeddings.\r\n        }\r\n    }\r\n    /**\r\n     * Manually step through the optimization process one epoch at a time.\r\n     */\r\n    step() {\r\n        const { currentEpoch } = this.optimizationState;\r\n        if (currentEpoch < this.getNEpochs()) {\r\n            this.optimizeLayoutStep(currentEpoch);\r\n        }\r\n        return this.optimizationState.currentEpoch;\r\n    }\r\n    /**\r\n     * Returns the computed projected embedding.\r\n     */\r\n    getEmbedding() {\r\n        return this.embedding;\r\n    }\r\n    /**\r\n     * Compute the ``nNeighbors`` nearest points for each data point in ``X``\r\n     * This may be exact, but more likely is approximated via nearest neighbor\r\n     * descent.\r\n     */\r\n    nearestNeighbors(X) {\r\n        const { distanceFn, nNeighbors } = this;\r\n        const log2 = (n) => Math.log(n) / Math.log(2);\r\n        const metricNNDescent = nnDescent.makeNNDescent(distanceFn, this.random);\r\n        // Handle python3 rounding down from 0.5 discrpancy\r\n        const round = (n) => {\r\n            return n === 0.5 ? 0 : Math.round(n);\r\n        };\r\n        const nTrees = 5 + Math.floor(round(X.length ** 0.5 / 20.0));\r\n        const nIters = Math.max(5, Math.floor(Math.round(log2(X.length))));\r\n        this.rpForest = tree.makeForest(X, nNeighbors, nTrees, this.random);\r\n        const leafArray = tree.makeLeafArray(this.rpForest);\r\n        const { indices, weights } = metricNNDescent(X, leafArray, nNeighbors, nIters);\r\n        return { knnIndices: indices, knnDistances: weights };\r\n    }\r\n    /**\r\n     * Given a set of data X, a neighborhood size, and a measure of distance\r\n     * compute the fuzzy simplicial set (here represented as a fuzzy graph in\r\n     * the form of a sparse matrix) associated to the data. This is done by\r\n     * locally approximating geodesic distance at each point, creating a fuzzy\r\n     * simplicial set for each such point, and then combining all the local\r\n     * fuzzy simplicial sets into a global one via a fuzzy union.\r\n     */\r\n    fuzzySimplicialSet(X, nNeighbors, setOpMixRatio = 1.0) {\r\n        const { knnIndices = [], knnDistances = [], localConnectivity } = this;\r\n        const { sigmas, rhos } = this.smoothKNNDistance(knnDistances, nNeighbors, localConnectivity);\r\n        const { rows, cols, vals } = this.computeMembershipStrengths(knnIndices, knnDistances, sigmas, rhos);\r\n        const size = [X.length, X.length];\r\n        const sparseMatrix = new matrix.SparseMatrix(rows, cols, vals, size);\r\n        const transpose = matrix.transpose(sparseMatrix);\r\n        const prodMatrix = matrix.pairwiseMultiply(sparseMatrix, transpose);\r\n        const a = matrix.subtract(matrix.add(sparseMatrix, transpose), prodMatrix);\r\n        const b = matrix.multiplyScalar(a, setOpMixRatio);\r\n        const c = matrix.multiplyScalar(prodMatrix, 1.0 - setOpMixRatio);\r\n        const result = matrix.add(b, c);\r\n        return result;\r\n    }\r\n    /**\r\n     * Combine a fuzzy simplicial set with another fuzzy simplicial set\r\n     * generated from categorical data using categorical distances. The target\r\n     * data is assumed to be categorical label data (a vector of labels),\r\n     * and this will update the fuzzy simplicial set to respect that label data.\r\n     */\r\n    categoricalSimplicialSetIntersection(simplicialSet, target, farDist, unknownDist = 1.0) {\r\n        let intersection = fastIntersection(simplicialSet, target, unknownDist, farDist);\r\n        intersection = matrix.eliminateZeros(intersection);\r\n        return resetLocalConnectivity(intersection);\r\n    }\r\n    /**\r\n     * Compute a continuous version of the distance to the kth nearest\r\n     * neighbor. That is, this is similar to knn-distance but allows continuous\r\n     * k values rather than requiring an integral k. In esscence we are simply\r\n     * computing the distance such that the cardinality of fuzzy set we generate\r\n     * is k.\r\n     */\r\n    smoothKNNDistance(distances, k, localConnectivity = 1.0, nIter = 64, bandwidth = 1.0) {\r\n        const target = (Math.log(k) / Math.log(2)) * bandwidth;\r\n        const rho = utils.zeros(distances.length);\r\n        const result = utils.zeros(distances.length);\r\n        for (let i = 0; i < distances.length; i++) {\r\n            let lo = 0.0;\r\n            let hi = Infinity;\r\n            let mid = 1.0;\r\n            // TODO: This is very inefficient, but will do for now. FIXME\r\n            const ithDistances = distances[i];\r\n            const nonZeroDists = ithDistances.filter(d => d > 0.0);\r\n            if (nonZeroDists.length >= localConnectivity) {\r\n                let index = Math.floor(localConnectivity);\r\n                let interpolation = localConnectivity - index;\r\n                if (index > 0) {\r\n                    rho[i] = nonZeroDists[index - 1];\r\n                    if (interpolation > SMOOTH_K_TOLERANCE) {\r\n                        rho[i] +=\r\n                            interpolation * (nonZeroDists[index] - nonZeroDists[index - 1]);\r\n                    }\r\n                }\r\n                else {\r\n                    rho[i] = interpolation * nonZeroDists[0];\r\n                }\r\n            }\r\n            else if (nonZeroDists.length > 0) {\r\n                rho[i] = utils.max(nonZeroDists);\r\n            }\r\n            for (let n = 0; n < nIter; n++) {\r\n                let psum = 0.0;\r\n                for (let j = 1; j < distances[i].length; j++) {\r\n                    const d = distances[i][j] - rho[i];\r\n                    if (d > 0) {\r\n                        psum += Math.exp(-(d / mid));\r\n                    }\r\n                    else {\r\n                        psum += 1.0;\r\n                    }\r\n                }\r\n                if (Math.abs(psum - target) < SMOOTH_K_TOLERANCE) {\r\n                    break;\r\n                }\r\n                if (psum > target) {\r\n                    hi = mid;\r\n                    mid = (lo + hi) / 2.0;\r\n                }\r\n                else {\r\n                    lo = mid;\r\n                    if (hi === Infinity) {\r\n                        mid *= 2;\r\n                    }\r\n                    else {\r\n                        mid = (lo + hi) / 2.0;\r\n                    }\r\n                }\r\n            }\r\n            result[i] = mid;\r\n            // TODO: This is very inefficient, but will do for now. FIXME\r\n            if (rho[i] > 0.0) {\r\n                const meanIthDistances = utils.mean(ithDistances);\r\n                if (result[i] < MIN_K_DIST_SCALE * meanIthDistances) {\r\n                    result[i] = MIN_K_DIST_SCALE * meanIthDistances;\r\n                }\r\n            }\r\n            else {\r\n                const meanDistances = utils.mean(distances.map(utils.mean));\r\n                if (result[i] < MIN_K_DIST_SCALE * meanDistances) {\r\n                    result[i] = MIN_K_DIST_SCALE * meanDistances;\r\n                }\r\n            }\r\n        }\r\n        return { sigmas: result, rhos: rho };\r\n    }\r\n    /**\r\n     * Construct the membership strength data for the 1-skeleton of each local\r\n     * fuzzy simplicial set -- this is formed as a sparse matrix where each row is\r\n     * a local fuzzy simplicial set, with a membership strength for the\r\n     * 1-simplex to each other data point.\r\n     */\r\n    computeMembershipStrengths(knnIndices, knnDistances, sigmas, rhos) {\r\n        const nSamples = knnIndices.length;\r\n        const nNeighbors = knnIndices[0].length;\r\n        const rows = utils.zeros(nSamples * nNeighbors);\r\n        const cols = utils.zeros(nSamples * nNeighbors);\r\n        const vals = utils.zeros(nSamples * nNeighbors);\r\n        for (let i = 0; i < nSamples; i++) {\r\n            for (let j = 0; j < nNeighbors; j++) {\r\n                let val = 0;\r\n                if (knnIndices[i][j] === -1) {\r\n                    continue; // We didn't get the full knn for i\r\n                }\r\n                if (knnIndices[i][j] === i) {\r\n                    val = 0.0;\r\n                }\r\n                else if (knnDistances[i][j] - rhos[i] <= 0.0) {\r\n                    val = 1.0;\r\n                }\r\n                else {\r\n                    val = Math.exp(-((knnDistances[i][j] - rhos[i]) / sigmas[i]));\r\n                }\r\n                rows[i * nNeighbors + j] = i;\r\n                cols[i * nNeighbors + j] = knnIndices[i][j];\r\n                vals[i * nNeighbors + j] = val;\r\n            }\r\n        }\r\n        return { rows, cols, vals };\r\n    }\r\n    /**\r\n     * Initialize a fuzzy simplicial set embedding, using a specified\r\n     * initialisation method and then minimizing the fuzzy set cross entropy\r\n     * between the 1-skeletons of the high and low dimensional fuzzy simplicial\r\n     * sets.\r\n     */\r\n    initializeSimplicialSetEmbedding(initialEmbedding) {\r\n        const nEpochs = this.getNEpochs();\r\n        const { nComponents } = this;\r\n        const graphValues = this.graph.getValues();\r\n        let graphMax = 0;\r\n        for (let i = 0; i < graphValues.length; i++) {\r\n            const value = graphValues[i];\r\n            if (graphMax < graphValues[i]) {\r\n                graphMax = value;\r\n            }\r\n        }\r\n        const graph = this.graph.map(value => {\r\n            if (value < graphMax / nEpochs) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return value;\r\n            }\r\n        });\r\n        // We're not computing the spectral initialization in this implementation\r\n        // until we determine a better eigenvalue/eigenvector computation\r\n        // approach\r\n        if (initialEmbedding) {\r\n            this.embedding = initialEmbedding;\r\n        }\r\n        else {\r\n            this.embedding = utils.zeros(graph.nRows).map(() => {\r\n                return utils.zeros(nComponents).map(() => {\r\n                    return utils.tauRand(this.random) * 20 + -10; // Random from -10 to 10\r\n                });\r\n            });\r\n        }\r\n        // Get graph data in ordered way...\r\n        const weights = [];\r\n        const head = [];\r\n        const tail = [];\r\n        const rowColValues = graph.getAll();\r\n        for (let i = 0; i < rowColValues.length; i++) {\r\n            const entry = rowColValues[i];\r\n            if (entry.value) {\r\n                weights.push(entry.value);\r\n                tail.push(entry.row);\r\n                head.push(entry.col);\r\n            }\r\n        }\r\n        const epochsPerSample = this.makeEpochsPerSample(weights, nEpochs);\r\n        return { head, tail, epochsPerSample };\r\n    }\r\n    /**\r\n     * Given a set of weights and number of epochs generate the number of\r\n     * epochs per sample for each weight.\r\n     */\r\n    makeEpochsPerSample(weights, nEpochs) {\r\n        const result = utils.filled(weights.length, -1.0);\r\n        const max = utils.max(weights);\r\n        const nSamples = weights.map(w => (w / max) * nEpochs);\r\n        nSamples.forEach((n, i) => {\r\n            if (n > 0)\r\n                result[i] = nEpochs / nSamples[i];\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * Assigns optimization state parameters from a partial optimization state.\r\n     */\r\n    assignOptimizationStateParameters(state) {\r\n        Object.assign(this.optimizationState, state);\r\n    }\r\n    /**\r\n     * Sets a few optimization state parameters that are necessary before entering\r\n     * the optimization step loop.\r\n     */\r\n    prepareForOptimizationLoop() {\r\n        // Hyperparameters\r\n        const { repulsionStrength, learningRate, negativeSampleRate } = this;\r\n        const { epochsPerSample, headEmbedding, tailEmbedding, } = this.optimizationState;\r\n        const dim = headEmbedding[0].length;\r\n        const moveOther = headEmbedding.length === tailEmbedding.length;\r\n        const epochsPerNegativeSample = epochsPerSample.map(e => e / negativeSampleRate);\r\n        const epochOfNextNegativeSample = [...epochsPerNegativeSample];\r\n        const epochOfNextSample = [...epochsPerSample];\r\n        this.assignOptimizationStateParameters({\r\n            epochOfNextSample,\r\n            epochOfNextNegativeSample,\r\n            epochsPerNegativeSample,\r\n            moveOther,\r\n            initialAlpha: learningRate,\r\n            alpha: learningRate,\r\n            gamma: repulsionStrength,\r\n            dim,\r\n        });\r\n    }\r\n    /**\r\n     * Initializes optimization state for stepwise optimization.\r\n     */\r\n    initializeOptimization() {\r\n        // Algorithm state\r\n        const headEmbedding = this.embedding;\r\n        const tailEmbedding = this.embedding;\r\n        // Initialized in initializeSimplicialSetEmbedding()\r\n        const { head, tail, epochsPerSample } = this.optimizationState;\r\n        const nEpochs = this.getNEpochs();\r\n        const nVertices = this.graph.nCols;\r\n        const { a, b } = findABParams(this.spread, this.minDist);\r\n        this.assignOptimizationStateParameters({\r\n            headEmbedding,\r\n            tailEmbedding,\r\n            head,\r\n            tail,\r\n            epochsPerSample,\r\n            a,\r\n            b,\r\n            nEpochs,\r\n            nVertices,\r\n        });\r\n    }\r\n    /**\r\n     * Improve an embedding using stochastic gradient descent to minimize the\r\n     * fuzzy set cross entropy between the 1-skeletons of the high dimensional\r\n     * and low dimensional fuzzy simplicial sets. In practice this is done by\r\n     * sampling edges based on their membership strength (with the (1-p) terms\r\n     * coming from negative sampling similar to word2vec).\r\n     */\r\n    optimizeLayoutStep(n) {\r\n        const { optimizationState } = this;\r\n        const { head, tail, headEmbedding, tailEmbedding, epochsPerSample, epochOfNextSample, epochOfNextNegativeSample, epochsPerNegativeSample, moveOther, initialAlpha, alpha, gamma, a, b, dim, nEpochs, nVertices, } = optimizationState;\r\n        const clipValue = 4.0;\r\n        for (let i = 0; i < epochsPerSample.length; i++) {\r\n            if (epochOfNextSample[i] > n) {\r\n                continue;\r\n            }\r\n            const j = head[i];\r\n            const k = tail[i];\r\n            const current = headEmbedding[j];\r\n            const other = tailEmbedding[k];\r\n            const distSquared = rDist(current, other);\r\n            let gradCoeff = 0;\r\n            if (distSquared > 0) {\r\n                gradCoeff = -2.0 * a * b * Math.pow(distSquared, b - 1.0);\r\n                gradCoeff /= a * Math.pow(distSquared, b) + 1.0;\r\n            }\r\n            for (let d = 0; d < dim; d++) {\r\n                const gradD = clip(gradCoeff * (current[d] - other[d]), clipValue);\r\n                current[d] += gradD * alpha;\r\n                if (moveOther) {\r\n                    other[d] += -gradD * alpha;\r\n                }\r\n            }\r\n            epochOfNextSample[i] += epochsPerSample[i];\r\n            const nNegSamples = Math.floor((n - epochOfNextNegativeSample[i]) / epochsPerNegativeSample[i]);\r\n            for (let p = 0; p < nNegSamples; p++) {\r\n                const k = utils.tauRandInt(nVertices, this.random);\r\n                const other = tailEmbedding[k];\r\n                const distSquared = rDist(current, other);\r\n                let gradCoeff = 0.0;\r\n                if (distSquared > 0.0) {\r\n                    gradCoeff = 2.0 * gamma * b;\r\n                    gradCoeff /=\r\n                        (0.001 + distSquared) * (a * Math.pow(distSquared, b) + 1);\r\n                }\r\n                else if (j === k) {\r\n                    continue;\r\n                }\r\n                for (let d = 0; d < dim; d++) {\r\n                    let gradD = 4.0;\r\n                    if (gradCoeff > 0.0) {\r\n                        gradD = clip(gradCoeff * (current[d] - other[d]), clipValue);\r\n                    }\r\n                    current[d] += gradD * alpha;\r\n                }\r\n            }\r\n            epochOfNextNegativeSample[i] += nNegSamples * epochsPerNegativeSample[i];\r\n        }\r\n        optimizationState.alpha = initialAlpha * (1.0 - n / nEpochs);\r\n        optimizationState.currentEpoch += 1;\r\n        return headEmbedding;\r\n    }\r\n    /**\r\n     * Improve an embedding using stochastic gradient descent to minimize the\r\n     * fuzzy set cross entropy between the 1-skeletons of the high dimensional\r\n     * and low dimensional fuzzy simplicial sets. In practice this is done by\r\n     * sampling edges based on their membership strength (with the (1-p) terms\r\n     * coming from negative sampling similar to word2vec).\r\n     */\r\n    optimizeLayoutAsync(epochCallback = () => true) {\r\n        return new Promise((resolve, reject) => {\r\n            const step = () => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    const { nEpochs, currentEpoch } = this.optimizationState;\r\n                    this.embedding = this.optimizeLayoutStep(currentEpoch);\r\n                    const epochCompleted = this.optimizationState.currentEpoch;\r\n                    const shouldStop = epochCallback(epochCompleted) === false;\r\n                    const isFinished = epochCompleted === nEpochs;\r\n                    if (!shouldStop && !isFinished) {\r\n                        setTimeout(() => step(), 0);\r\n                    }\r\n                    else {\r\n                        return resolve(isFinished);\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    reject(err);\r\n                }\r\n            });\r\n            setTimeout(() => step(), 0);\r\n        });\r\n    }\r\n    /**\r\n     * Improve an embedding using stochastic gradient descent to minimize the\r\n     * fuzzy set cross entropy between the 1-skeletons of the high dimensional\r\n     * and low dimensional fuzzy simplicial sets. In practice this is done by\r\n     * sampling edges based on their membership strength (with the (1-p) terms\r\n     * coming from negative sampling similar to word2vec).\r\n     */\r\n    optimizeLayout(epochCallback = () => true) {\r\n        let isFinished = false;\r\n        let embedding = [];\r\n        while (!isFinished) {\r\n            const { nEpochs, currentEpoch } = this.optimizationState;\r\n            embedding = this.optimizeLayoutStep(currentEpoch);\r\n            const epochCompleted = this.optimizationState.currentEpoch;\r\n            const shouldStop = epochCallback(epochCompleted) === false;\r\n            isFinished = epochCompleted === nEpochs || shouldStop;\r\n        }\r\n        return embedding;\r\n    }\r\n    /**\r\n     * Gets the number of epochs for optimizing the projection.\r\n     * NOTE: This heuristic differs from the python version\r\n     */\r\n    getNEpochs() {\r\n        const graph = this.graph;\r\n        if (this.nEpochs > 0) {\r\n            return this.nEpochs;\r\n        }\r\n        const length = graph.nRows;\r\n        if (length <= 2500) {\r\n            return 500;\r\n        }\r\n        else if (length <= 5000) {\r\n            return 400;\r\n        }\r\n        else if (length <= 7500) {\r\n            return 300;\r\n        }\r\n        else {\r\n            return 200;\r\n        }\r\n    }\r\n}\r\nexports.UMAP = UMAP;\r\n// https://github.com/ecto/jaccard TODO: also for tsne and other projection methods\r\nfunction jaccard(x, y) {\r\n    var jaccard_dist = require('jaccard');\r\n    return jaccard_dist.index(x, y);\r\n}\r\nexports.jaccard = jaccard;\r\nfunction euclidean(x, y) {\r\n    let result = 0;\r\n    for (let i = 0; i < x.length; i++) {\r\n        result += (x[i] - y[i]) ** 2;\r\n    }\r\n    return Math.sqrt(result);\r\n}\r\nexports.euclidean = euclidean;\r\nfunction cosine(x, y) {\r\n    let result = 0.0;\r\n    let normX = 0.0;\r\n    let normY = 0.0;\r\n    for (let i = 0; i < x.length; i++) {\r\n        result += x[i] * y[i];\r\n        normX += x[i] ** 2;\r\n        normY += y[i] ** 2;\r\n    }\r\n    if (normX === 0 && normY === 0) {\r\n        return 0;\r\n    }\r\n    else if (normX === 0 || normY === 0) {\r\n        return 1.0;\r\n    }\r\n    else {\r\n        return 1.0 - result / Math.sqrt(normX * normY);\r\n    }\r\n}\r\nexports.cosine = cosine;\r\n/**\r\n * An interface representing the optimization state tracked between steps of\r\n * the SGD optimization\r\n */\r\nclass OptimizationState {\r\n    constructor() {\r\n        this.currentEpoch = 0;\r\n        // Data tracked during optimization steps.\r\n        this.headEmbedding = [];\r\n        this.tailEmbedding = [];\r\n        this.head = [];\r\n        this.tail = [];\r\n        this.epochsPerSample = [];\r\n        this.epochOfNextSample = [];\r\n        this.epochOfNextNegativeSample = [];\r\n        this.epochsPerNegativeSample = [];\r\n        this.moveOther = true;\r\n        this.initialAlpha = 1.0;\r\n        this.alpha = 1.0;\r\n        this.gamma = 1.0;\r\n        this.a = 1.5769434603113077;\r\n        this.b = 0.8950608779109733;\r\n        this.dim = 2;\r\n        this.nEpochs = 500;\r\n        this.nVertices = 0;\r\n    }\r\n}\r\n/**\r\n * Standard clamping of a value into a fixed range\r\n */\r\nfunction clip(x, clipValue) {\r\n    if (x > clipValue)\r\n        return clipValue;\r\n    else if (x < -clipValue)\r\n        return -clipValue;\r\n    else\r\n        return x;\r\n}\r\n/**\r\n * Reduced Euclidean distance.\r\n */\r\nfunction rDist(x, y) {\r\n    let result = 0.0;\r\n    for (let i = 0; i < x.length; i++) {\r\n        result += Math.pow(x[i] - y[i], 2);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Fit a, b params for the differentiable curve used in lower\r\n * dimensional fuzzy simplicial complex construction. We want the\r\n * smooth curve (from a pre-defined family with simple gradient) that\r\n * best matches an offset exponential decay.\r\n */\r\nfunction findABParams(spread, minDist) {\r\n    const curve = ([a, b]) => (x) => {\r\n        return 1.0 / (1.0 + a * x ** (2 * b));\r\n    };\r\n    const xv = utils\r\n        .linear(0, spread * 3, 300)\r\n        .map(val => (val < minDist ? 1.0 : val));\r\n    const yv = utils.zeros(xv.length).map((val, index) => {\r\n        const gte = xv[index] >= minDist;\r\n        return gte ? Math.exp(-(xv[index] - minDist) / spread) : val;\r\n    });\r\n    const initialValues = [0.5, 0.5];\r\n    const data = { x: xv, y: yv };\r\n    // Default options for the algorithm (from github example)\r\n    const options = {\r\n        damping: 1.5,\r\n        initialValues,\r\n        gradientDifference: 10e-2,\r\n        maxIterations: 100,\r\n        errorTolerance: 10e-3,\r\n    };\r\n    const { parameterValues } = ml_levenberg_marquardt_1.default(data, curve, options);\r\n    const [a, b] = parameterValues;\r\n    return { a, b };\r\n}\r\nexports.findABParams = findABParams;\r\n/**\r\n * Under the assumption of categorical distance for the intersecting\r\n * simplicial set perform a fast intersection.\r\n */\r\nfunction fastIntersection(graph, target, unknownDist = 1.0, farDist = 5.0) {\r\n    return graph.map((value, row, col) => {\r\n        if (target[row] === -1 || target[col] === -1) {\r\n            return value * Math.exp(-unknownDist);\r\n        }\r\n        else if (target[row] !== target[col]) {\r\n            return value * Math.exp(-farDist);\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    });\r\n}\r\nexports.fastIntersection = fastIntersection;\r\n/**\r\n * Reset the local connectivity requirement -- each data sample should\r\n * have complete confidence in at least one 1-simplex in the simplicial set.\r\n * We can enforce this by locally rescaling confidences, and then remerging the\r\n * different local simplicial sets together.\r\n */\r\nfunction resetLocalConnectivity(simplicialSet) {\r\n    simplicialSet = matrix.normalize(simplicialSet, \"max\" /* max */);\r\n    const transpose = matrix.transpose(simplicialSet);\r\n    const prodMatrix = matrix.pairwiseMultiply(transpose, simplicialSet);\r\n    simplicialSet = matrix.add(simplicialSet, matrix.subtract(transpose, prodMatrix));\r\n    return matrix.eliminateZeros(simplicialSet);\r\n}\r\nexports.resetLocalConnectivity = resetLocalConnectivity;\r\n/**\r\n * Given indices and weights and an original embeddings\r\n * initialize the positions of new points relative to the\r\n * indices and weights (of their neighbors in the source data).\r\n */\r\nfunction initTransform(indices, weights, embedding) {\r\n    const result = utils\r\n        .zeros(indices.length)\r\n        .map(z => utils.zeros(embedding[0].length));\r\n    for (let i = 0; i < indices.length; i++) {\r\n        for (let j = 0; j < indices[0].length; j++) {\r\n            for (let d = 0; d < embedding[0].length; d++) {\r\n                const a = indices[i][j];\r\n                result[i][d] += weights[i][j] * embedding[a][d];\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.initTransform = initTransform;\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.reshape2d = exports.rejectionSample = exports.max2d = exports.max = exports.mean = exports.sum = exports.linear = exports.ones = exports.zeros = exports.filled = exports.range = exports.empty = exports.norm = exports.tauRand = exports.tauRandInt = void 0;\r\n/**\r\n * Simple random integer function\r\n */\r\nfunction tauRandInt(n, random) {\r\n    return Math.floor(random() * n);\r\n}\r\nexports.tauRandInt = tauRandInt;\r\n/**\r\n * Simple random float function\r\n */\r\nfunction tauRand(random) {\r\n    return random();\r\n}\r\nexports.tauRand = tauRand;\r\n/**\r\n * Compute the (standard l2) norm of a vector.\r\n */\r\nfunction norm(vec) {\r\n    let result = 0;\r\n    for (let item of vec) {\r\n        result += item ** 2;\r\n    }\r\n    return Math.sqrt(result);\r\n}\r\nexports.norm = norm;\r\n/**\r\n * Creates an empty array (filled with undefined)\r\n */\r\nfunction empty(n) {\r\n    const output = [];\r\n    for (let i = 0; i < n; i++) {\r\n        output.push(undefined);\r\n    }\r\n    return output;\r\n}\r\nexports.empty = empty;\r\n/**\r\n * Creates an array filled with index values\r\n */\r\nfunction range(n) {\r\n    return empty(n).map((_, i) => i);\r\n}\r\nexports.range = range;\r\n/**\r\n * Creates an array filled with a specific value\r\n */\r\nfunction filled(n, v) {\r\n    return empty(n).map(() => v);\r\n}\r\nexports.filled = filled;\r\n/**\r\n * Creates an array filled with zeros\r\n */\r\nfunction zeros(n) {\r\n    return filled(n, 0);\r\n}\r\nexports.zeros = zeros;\r\n/**\r\n * Creates an array filled with ones\r\n */\r\nfunction ones(n) {\r\n    return filled(n, 1);\r\n}\r\nexports.ones = ones;\r\n/**\r\n * Creates an array from a to b, of length len, inclusive\r\n */\r\nfunction linear(a, b, len) {\r\n    return empty(len).map((_, i) => {\r\n        return a + i * ((b - a) / (len - 1));\r\n    });\r\n}\r\nexports.linear = linear;\r\n/**\r\n * Returns the sum of an array\r\n */\r\nfunction sum(input) {\r\n    return input.reduce((sum, val) => sum + val);\r\n}\r\nexports.sum = sum;\r\n/**\r\n * Returns the mean of an array\r\n */\r\nfunction mean(input) {\r\n    return sum(input) / input.length;\r\n}\r\nexports.mean = mean;\r\n/**\r\n * Returns the maximum value of an array\r\n */\r\nfunction max(input) {\r\n    let max = 0;\r\n    for (let i = 0; i < input.length; i++) {\r\n        max = input[i] > max ? input[i] : max;\r\n    }\r\n    return max;\r\n}\r\nexports.max = max;\r\n/**\r\n * Returns the maximum value of a 2d array\r\n */\r\nfunction max2d(input) {\r\n    let max = 0;\r\n    for (let i = 0; i < input.length; i++) {\r\n        for (let j = 0; j < input[i].length; j++) {\r\n            max = input[i][j] > max ? input[i][j] : max;\r\n        }\r\n    }\r\n    return max;\r\n}\r\nexports.max2d = max2d;\r\n/**\r\n * Generate nSamples many integers from 0 to poolSize such that no\r\n * integer is selected twice. The duplication constraint is achieved via\r\n * rejection sampling.\r\n */\r\nfunction rejectionSample(nSamples, poolSize, random) {\r\n    const result = zeros(nSamples);\r\n    for (let i = 0; i < nSamples; i++) {\r\n        let rejectSample = true;\r\n        while (rejectSample) {\r\n            const j = tauRandInt(poolSize, random);\r\n            let broken = false;\r\n            for (let k = 0; k < i; k++) {\r\n                if (j === result[k]) {\r\n                    broken = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!broken) {\r\n                rejectSample = false;\r\n            }\r\n            result[i] = j;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.rejectionSample = rejectionSample;\r\n/**\r\n * Reshapes a 1d array into a 2D of given dimensions.\r\n */\r\nfunction reshape2d(x, a, b) {\r\n    const rows = [];\r\n    let count = 0;\r\n    let index = 0;\r\n    if (x.length !== a * b) {\r\n        throw new Error('Array dimensions must match input length.');\r\n    }\r\n    for (let i = 0; i < a; i++) {\r\n        const col = [];\r\n        for (let j = 0; j < b; j++) {\r\n            col.push(x[index]);\r\n            index += 1;\r\n        }\r\n        rows.push(col);\r\n        count += 1;\r\n    }\r\n    return rows;\r\n}\r\nexports.reshape2d = reshape2d;\r\n"],"sourceRoot":""}